export class Shaders {
    constructor() {
        this.particleVertex = `
    // @author brunoimbrizi / http://brunoimbrizi.com

    precision highp float;
    #define GLSLIFY 1

    attribute float pindex;
    attribute vec3 position;
    attribute vec3 offset;
    attribute vec2 uv;
    attribute float angle;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    uniform float uTime;
    uniform float uRandom;
    uniform float uDepth;
    uniform float uSize;
    uniform vec2 uTextureSize;
    uniform sampler2D uTexture;
    uniform sampler2D uTouch;

    varying vec2 vPUv;
    varying vec2 vUv;

    //
    // Description : Array and textureless GLSL 2D simplex noise function.
    //      Author : Ian McEwan, Ashima Arts.
    //  Maintainer : ijm
    //     Lastmod : 20110822 (ijm)
    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
    //               Distributed under the MIT License. See LICENSE file.
    //               https://github.com/ashima/webgl-noise
    //

    vec3 mod289_1_0(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec2 mod289_1_0(vec2 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec3 permute_1_1(vec3 x) {
      return mod289_1_0(((x*34.0)+1.0)*x);
    }

    float snoise_1_2(vec2 v)
      {
      const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                          0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                         -0.577350269189626,  // -1.0 + 2.0 * C.x
                          0.024390243902439); // 1.0 / 41.0
    // First corner
      vec2 i  = floor(v + dot(v, C.yy) );
      vec2 x0 = v -   i + dot(i, C.xx);

    // Other corners
      vec2 i1;
      //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
      //i1.y = 1.0 - i1.x;
      i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      // x0 = x0 - 0.0 + 0.0 * C.xx ;
      // x1 = x0 - i1 + 1.0 * C.xx ;
      // x2 = x0 - 1.0 + 2.0 * C.xx ;
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;

     // Permutations
      i = mod289_1_0(i); // Avoid truncation effects in permutation
      vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));

      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m ;
      m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
      m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
      vec3 g;
      g.x  = a0.x  * x0.x  + h.x  * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    float random(float n) {
      return fract(sin(n) * 43758.5453123);
    }

    void main() {
      vUv = uv;

      // particle uv
      vec2 puv = offset.xy / uTextureSize;
      vPUv = puv;

      // pixel color
      vec4 colA = texture2D(uTexture, puv);
      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;

      // displacement
      vec3 displaced = offset;
      // randomise
      displaced.xy += vec2(random(pindex) - 0.5, random(offset.x + pindex) - 0.5) * uRandom;
      float rndz = (random(pindex) + snoise_1_2(vec2(pindex * 0.1, uTime * 0.1)));
      displaced.z += rndz * (random(pindex) * 2.0 * uDepth);
      // center
      displaced.xy -= uTextureSize * 0.5;

      // touch
      float t = texture2D(uTouch, puv).r;
      displaced.z += t * 20.0 * rndz;
      displaced.x += cos(angle) * t * 20.0 * rndz;
      displaced.y += sin(angle) * t * 20.0 * rndz;

      // particle size
      float psize = (snoise_1_2(vec2(uTime, pindex) * 0.5) + 2.0);
      psize *= max(grey, 0.2);
      psize *= uSize;

      // final position
      vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);
      mvPosition.xyz += position * psize;
      vec4 finalPosition = projectionMatrix * mvPosition;

      gl_Position = finalPosition;
    }
    `;
        this.particleFragment = `
    // @author brunoimbrizi / http://brunoimbrizi.com

    precision highp float;
    #define GLSLIFY 1

    uniform sampler2D uTexture;

    varying vec2 vPUv;
    varying vec2 vUv;

    void main() {
      vec4 color = vec4(0.0);
      vec2 uv = vUv;
      vec2 puv = vPUv;

      // pixel color
      vec4 colA = texture2D(uTexture, puv);

      // greyscale
      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;
      //vec4 colB = vec4(grey, grey, grey, 1.0);
      vec4 colB = vec4(colA.r, colA.g, colA.b, 1.0);

      // circle
      float border = 0.3;
      float radius = 0.5;
      float dist = radius - distance(uv, vec2(0.5));
      float t = smoothstep(0.0, border, dist);

      // final color
      color = colB;
      color.a = t;

      gl_FragColor = color;
    }
    `;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1hY3V3L3NyYy9saWIvaW1hZ2UtYXMtcGFydGljbGVzL3NjcmlwdHMvc2hhZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLE9BQU8sT0FBTztJQUFwQjtRQUNJLG1CQUFjLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0EySWhCLENBQUM7UUFFRixxQkFBZ0IsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBb0NsQixDQUFDO0lBQ04sQ0FBQztDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFNoYWRlcnMge1xuICAgIHBhcnRpY2xlVmVydGV4ID0gYFxuICAgIC8vIEBhdXRob3IgYnJ1bm9pbWJyaXppIC8gaHR0cDovL2JydW5vaW1icml6aS5jb21cblxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjZGVmaW5lIEdMU0xJRlkgMVxuXG4gICAgYXR0cmlidXRlIGZsb2F0IHBpbmRleDtcbiAgICBhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMyBvZmZzZXQ7XG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XG4gICAgYXR0cmlidXRlIGZsb2F0IGFuZ2xlO1xuXG4gICAgdW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcbiAgICB1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcblxuICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7XG4gICAgdW5pZm9ybSBmbG9hdCB1UmFuZG9tO1xuICAgIHVuaWZvcm0gZmxvYXQgdURlcHRoO1xuICAgIHVuaWZvcm0gZmxvYXQgdVNpemU7XG4gICAgdW5pZm9ybSB2ZWMyIHVUZXh0dXJlU2l6ZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VG91Y2g7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlBVdjtcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgLy9cbiAgICAvLyBEZXNjcmlwdGlvbiA6IEFycmF5IGFuZCB0ZXh0dXJlbGVzcyBHTFNMIDJEIHNpbXBsZXggbm9pc2UgZnVuY3Rpb24uXG4gICAgLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cbiAgICAvLyAgTWFpbnRhaW5lciA6IGlqbVxuICAgIC8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcbiAgICAvLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICAvLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cbiAgICAvLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcbiAgICAvL1xuXG4gICAgdmVjMyBtb2QyODlfMV8wKHZlYzMgeCkge1xuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbiAgICB9XG5cbiAgICB2ZWMyIG1vZDI4OV8xXzAodmVjMiB4KSB7XG4gICAgICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xuICAgIH1cblxuICAgIHZlYzMgcGVybXV0ZV8xXzEodmVjMyB4KSB7XG4gICAgICByZXR1cm4gbW9kMjg5XzFfMCgoKHgqMzQuMCkrMS4wKSp4KTtcbiAgICB9XG5cbiAgICBmbG9hdCBzbm9pc2VfMV8yKHZlYzIgdilcbiAgICAgIHtcbiAgICAgIGNvbnN0IHZlYzQgQyA9IHZlYzQoMC4yMTEzMjQ4NjU0MDUxODcsICAvLyAoMy4wLXNxcnQoMy4wKSkvNi4wXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDAuMzY2MDI1NDAzNzg0NDM5LCAgLy8gMC41KihzcXJ0KDMuMCktMS4wKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC0wLjU3NzM1MDI2OTE4OTYyNiwgIC8vIC0xLjAgKyAyLjAgKiBDLnhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMC4wMjQzOTAyNDM5MDI0MzkpOyAvLyAxLjAgLyA0MS4wXG4gICAgLy8gRmlyc3QgY29ybmVyXG4gICAgICB2ZWMyIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSApO1xuICAgICAgdmVjMiB4MCA9IHYgLSAgIGkgKyBkb3QoaSwgQy54eCk7XG5cbiAgICAvLyBPdGhlciBjb3JuZXJzXG4gICAgICB2ZWMyIGkxO1xuICAgICAgLy9pMS54ID0gc3RlcCggeDAueSwgeDAueCApOyAvLyB4MC54ID4geDAueSA/IDEuMCA6IDAuMFxuICAgICAgLy9pMS55ID0gMS4wIC0gaTEueDtcbiAgICAgIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG4gICAgICAvLyB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eCA7XG4gICAgICAvLyB4MSA9IHgwIC0gaTEgKyAxLjAgKiBDLnh4IDtcbiAgICAgIC8vIHgyID0geDAgLSAxLjAgKyAyLjAgKiBDLnh4IDtcbiAgICAgIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcbiAgICAgIHgxMi54eSAtPSBpMTtcblxuICAgICAvLyBQZXJtdXRhdGlvbnNcbiAgICAgIGkgPSBtb2QyODlfMV8wKGkpOyAvLyBBdm9pZCB0cnVuY2F0aW9uIGVmZmVjdHMgaW4gcGVybXV0YXRpb25cbiAgICAgIHZlYzMgcCA9IHBlcm11dGVfMV8xKCBwZXJtdXRlXzFfMSggaS55ICsgdmVjMygwLjAsIGkxLnksIDEuMCApKVxuICAgICAgICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjAgKSk7XG5cbiAgICAgIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MTIueHkseDEyLnh5KSwgZG90KHgxMi56dyx4MTIuencpKSwgMC4wKTtcbiAgICAgIG0gPSBtKm0gO1xuICAgICAgbSA9IG0qbSA7XG5cbiAgICAvLyBHcmFkaWVudHM6IDQxIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIGxpbmUsIG1hcHBlZCBvbnRvIGEgZGlhbW9uZC5cbiAgICAvLyBUaGUgcmluZyBzaXplIDE3KjE3ID0gMjg5IGlzIGNsb3NlIHRvIGEgbXVsdGlwbGUgb2YgNDEgKDQxKjcgPSAyODcpXG5cbiAgICAgIHZlYzMgeCA9IDIuMCAqIGZyYWN0KHAgKiBDLnd3dykgLSAxLjA7XG4gICAgICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XG4gICAgICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XG4gICAgICB2ZWMzIGEwID0geCAtIG94O1xuXG4gICAgLy8gTm9ybWFsaXNlIGdyYWRpZW50cyBpbXBsaWNpdGx5IGJ5IHNjYWxpbmcgbVxuICAgIC8vIEFwcHJveGltYXRpb24gb2Y6IG0gKj0gaW52ZXJzZXNxcnQoIGEwKmEwICsgaCpoICk7XG4gICAgICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKCBhMCphMCArIGgqaCApO1xuXG4gICAgLy8gQ29tcHV0ZSBmaW5hbCBub2lzZSB2YWx1ZSBhdCBQXG4gICAgICB2ZWMzIGc7XG4gICAgICBnLnggID0gYTAueCAgKiB4MC54ICArIGgueCAgKiB4MC55O1xuICAgICAgZy55eiA9IGEwLnl6ICogeDEyLnh6ICsgaC55eiAqIHgxMi55dztcbiAgICAgIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcbiAgICB9XG5cbiAgICBmbG9hdCByYW5kb20oZmxvYXQgbikge1xuICAgICAgcmV0dXJuIGZyYWN0KHNpbihuKSAqIDQzNzU4LjU0NTMxMjMpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZVdiA9IHV2O1xuXG4gICAgICAvLyBwYXJ0aWNsZSB1dlxuICAgICAgdmVjMiBwdXYgPSBvZmZzZXQueHkgLyB1VGV4dHVyZVNpemU7XG4gICAgICB2UFV2ID0gcHV2O1xuXG4gICAgICAvLyBwaXhlbCBjb2xvclxuICAgICAgdmVjNCBjb2xBID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBwdXYpO1xuICAgICAgZmxvYXQgZ3JleSA9IGNvbEEuciAqIDAuMjEgKyBjb2xBLmcgKiAwLjcxICsgY29sQS5iICogMC4wNztcblxuICAgICAgLy8gZGlzcGxhY2VtZW50XG4gICAgICB2ZWMzIGRpc3BsYWNlZCA9IG9mZnNldDtcbiAgICAgIC8vIHJhbmRvbWlzZVxuICAgICAgZGlzcGxhY2VkLnh5ICs9IHZlYzIocmFuZG9tKHBpbmRleCkgLSAwLjUsIHJhbmRvbShvZmZzZXQueCArIHBpbmRleCkgLSAwLjUpICogdVJhbmRvbTtcbiAgICAgIGZsb2F0IHJuZHogPSAocmFuZG9tKHBpbmRleCkgKyBzbm9pc2VfMV8yKHZlYzIocGluZGV4ICogMC4xLCB1VGltZSAqIDAuMSkpKTtcbiAgICAgIGRpc3BsYWNlZC56ICs9IHJuZHogKiAocmFuZG9tKHBpbmRleCkgKiAyLjAgKiB1RGVwdGgpO1xuICAgICAgLy8gY2VudGVyXG4gICAgICBkaXNwbGFjZWQueHkgLT0gdVRleHR1cmVTaXplICogMC41O1xuXG4gICAgICAvLyB0b3VjaFxuICAgICAgZmxvYXQgdCA9IHRleHR1cmUyRCh1VG91Y2gsIHB1dikucjtcbiAgICAgIGRpc3BsYWNlZC56ICs9IHQgKiAyMC4wICogcm5kejtcbiAgICAgIGRpc3BsYWNlZC54ICs9IGNvcyhhbmdsZSkgKiB0ICogMjAuMCAqIHJuZHo7XG4gICAgICBkaXNwbGFjZWQueSArPSBzaW4oYW5nbGUpICogdCAqIDIwLjAgKiBybmR6O1xuXG4gICAgICAvLyBwYXJ0aWNsZSBzaXplXG4gICAgICBmbG9hdCBwc2l6ZSA9IChzbm9pc2VfMV8yKHZlYzIodVRpbWUsIHBpbmRleCkgKiAwLjUpICsgMi4wKTtcbiAgICAgIHBzaXplICo9IG1heChncmV5LCAwLjIpO1xuICAgICAgcHNpemUgKj0gdVNpemU7XG5cbiAgICAgIC8vIGZpbmFsIHBvc2l0aW9uXG4gICAgICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KGRpc3BsYWNlZCwgMS4wKTtcbiAgICAgIG12UG9zaXRpb24ueHl6ICs9IHBvc2l0aW9uICogcHNpemU7XG4gICAgICB2ZWM0IGZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcblxuICAgICAgZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uO1xuICAgIH1cbiAgICBgO1xuXG4gICAgcGFydGljbGVGcmFnbWVudCA9IGBcbiAgICAvLyBAYXV0aG9yIGJydW5vaW1icml6aSAvIGh0dHA6Ly9icnVub2ltYnJpemkuY29tXG5cbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgI2RlZmluZSBHTFNMSUZZIDFcblxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZQVXY7XG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICB2ZWMyIHV2ID0gdlV2O1xuICAgICAgdmVjMiBwdXYgPSB2UFV2O1xuXG4gICAgICAvLyBwaXhlbCBjb2xvclxuICAgICAgdmVjNCBjb2xBID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBwdXYpO1xuXG4gICAgICAvLyBncmV5c2NhbGVcbiAgICAgIGZsb2F0IGdyZXkgPSBjb2xBLnIgKiAwLjIxICsgY29sQS5nICogMC43MSArIGNvbEEuYiAqIDAuMDc7XG4gICAgICAvL3ZlYzQgY29sQiA9IHZlYzQoZ3JleSwgZ3JleSwgZ3JleSwgMS4wKTtcbiAgICAgIHZlYzQgY29sQiA9IHZlYzQoY29sQS5yLCBjb2xBLmcsIGNvbEEuYiwgMS4wKTtcblxuICAgICAgLy8gY2lyY2xlXG4gICAgICBmbG9hdCBib3JkZXIgPSAwLjM7XG4gICAgICBmbG9hdCByYWRpdXMgPSAwLjU7XG4gICAgICBmbG9hdCBkaXN0ID0gcmFkaXVzIC0gZGlzdGFuY2UodXYsIHZlYzIoMC41KSk7XG4gICAgICBmbG9hdCB0ID0gc21vb3Roc3RlcCgwLjAsIGJvcmRlciwgZGlzdCk7XG5cbiAgICAgIC8vIGZpbmFsIGNvbG9yXG4gICAgICBjb2xvciA9IGNvbEI7XG4gICAgICBjb2xvci5hID0gdDtcblxuICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XG4gICAgfVxuICAgIGA7XG59XG4iXX0=