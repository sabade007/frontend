(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('three'), require('rxjs'), require('@angular/animations'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('three/examples/jsm/renderers/CSS3DRenderer')) :
    typeof define === 'function' && define.amd ? define('ngx-acuw', ['exports', '@angular/core', 'three', 'rxjs', '@angular/animations', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/portal', 'three/examples/jsm/renderers/CSS3DRenderer'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-acuw'] = {}, global.ng.core, global.three, global.rxjs, global.ng.animations, global.ng.common, global.ng.cdk.overlay, global.ng.cdk.portal, global.CSS3DRenderer));
}(this, (function (exports, core, three, rxjs, animations, common, overlay, portal, CSS3DRenderer) { 'use strict';

    var TouchTexture = /** @class */ (function () {
        function TouchTexture() {
            this.size = 64;
            this.maxAge = 120;
            this.radius = 0.15;
            this.trail = new Array();
            this.initTexture();
        }
        /**
         * Initializes the texture for the touch area
         */
        TouchTexture.prototype.initTexture = function () {
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.canvas.height = this.size;
            this.ctx = this.canvas.getContext('2d');
            this.ctx.fillStyle = 'black';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.texture = new three.Texture(this.canvas);
            this.canvas.id = 'touchTexture';
            this.canvas.style.width = this.canvas.style.height = this.canvas.width + "px";
        };
        /**
         * Updates the trail
         */
        TouchTexture.prototype.update = function () {
            var _this = this;
            this.clear();
            // age points
            this.trail.forEach(function (point, i) {
                point.age++;
                // remove old
                if (point.age > _this.maxAge) {
                    _this.trail.splice(i, 1);
                }
            });
            this.trail.forEach(function (point, i) {
                _this.drawTouch(point);
            });
            this.texture.needsUpdate = true;
        };
        TouchTexture.prototype.clear = function () {
            this.ctx.fillStyle = 'black';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        };
        TouchTexture.prototype.addTouch = function (px, py) {
            var force = 0;
            var last = this.trail[this.trail.length - 1];
            if (last) {
                var dx = last.x - px;
                var dy = last.y - py;
                var dd = dx * dx + dy * dy;
                force = Math.min(dd * 10000, 1);
            }
            this.trail.push({ x: px, y: py, age: 0, force: force });
        };
        TouchTexture.prototype.drawTouch = function (point) {
            var pos = {
                x: point.x * this.size,
                y: (1 - point.y) * this.size
            };
            var intensity = 1;
            if (point.age < this.maxAge * 0.3) {
                intensity = this.easeOutSine(point.age / (this.maxAge * 0.3), 0, 1, 1);
            }
            else {
                intensity = this.easeOutSine(1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7), 0, 1, 1);
            }
            intensity *= point.force;
            var radius = this.size * this.radius * intensity;
            var grd = this.ctx.createRadialGradient(pos.x, pos.y, radius * 0.25, pos.x, pos.y, radius);
            grd.addColorStop(0, "rgba(255, 255, 255, 0.2)");
            grd.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
            this.ctx.beginPath();
            this.ctx.fillStyle = grd;
            this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        };
        TouchTexture.prototype.easeOutSine = function (t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        };
        return TouchTexture;
    }());

    var Shaders = /** @class */ (function () {
        function Shaders() {
            this.particleVertex = "\n    // @author brunoimbrizi / http://brunoimbrizi.com\n\n    precision highp float;\n    #define GLSLIFY 1\n\n    attribute float pindex;\n    attribute vec3 position;\n    attribute vec3 offset;\n    attribute vec2 uv;\n    attribute float angle;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    uniform float uTime;\n    uniform float uRandom;\n    uniform float uDepth;\n    uniform float uSize;\n    uniform vec2 uTextureSize;\n    uniform sampler2D uTexture;\n    uniform sampler2D uTouch;\n\n    varying vec2 vPUv;\n    varying vec2 vUv;\n\n    //\n    // Description : Array and textureless GLSL 2D simplex noise function.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    //\n\n    vec3 mod289_1_0(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec2 mod289_1_0(vec2 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec3 permute_1_1(vec3 x) {\n      return mod289_1_0(((x*34.0)+1.0)*x);\n    }\n\n    float snoise_1_2(vec2 v)\n      {\n      const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n      vec2 i  = floor(v + dot(v, C.yy) );\n      vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n      vec2 i1;\n      //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n      //i1.y = 1.0 - i1.x;\n      i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n      // x0 = x0 - 0.0 + 0.0 * C.xx ;\n      // x1 = x0 - i1 + 1.0 * C.xx ;\n      // x2 = x0 - 1.0 + 2.0 * C.xx ;\n      vec4 x12 = x0.xyxy + C.xxzz;\n      x12.xy -= i1;\n\n     // Permutations\n      i = mod289_1_0(i); // Avoid truncation effects in permutation\n      vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n      m = m*m ;\n      m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n      vec3 x = 2.0 * fract(p * C.www) - 1.0;\n      vec3 h = abs(x) - 0.5;\n      vec3 ox = floor(x + 0.5);\n      vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n      m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n      vec3 g;\n      g.x  = a0.x  * x0.x  + h.x  * x0.y;\n      g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n      return 130.0 * dot(m, g);\n    }\n\n    float random(float n) {\n      return fract(sin(n) * 43758.5453123);\n    }\n\n    void main() {\n      vUv = uv;\n\n      // particle uv\n      vec2 puv = offset.xy / uTextureSize;\n      vPUv = puv;\n\n      // pixel color\n      vec4 colA = texture2D(uTexture, puv);\n      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;\n\n      // displacement\n      vec3 displaced = offset;\n      // randomise\n      displaced.xy += vec2(random(pindex) - 0.5, random(offset.x + pindex) - 0.5) * uRandom;\n      float rndz = (random(pindex) + snoise_1_2(vec2(pindex * 0.1, uTime * 0.1)));\n      displaced.z += rndz * (random(pindex) * 2.0 * uDepth);\n      // center\n      displaced.xy -= uTextureSize * 0.5;\n\n      // touch\n      float t = texture2D(uTouch, puv).r;\n      displaced.z += t * 20.0 * rndz;\n      displaced.x += cos(angle) * t * 20.0 * rndz;\n      displaced.y += sin(angle) * t * 20.0 * rndz;\n\n      // particle size\n      float psize = (snoise_1_2(vec2(uTime, pindex) * 0.5) + 2.0);\n      psize *= max(grey, 0.2);\n      psize *= uSize;\n\n      // final position\n      vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);\n      mvPosition.xyz += position * psize;\n      vec4 finalPosition = projectionMatrix * mvPosition;\n\n      gl_Position = finalPosition;\n    }\n    ";
            this.particleFragment = "\n    // @author brunoimbrizi / http://brunoimbrizi.com\n\n    precision highp float;\n    #define GLSLIFY 1\n\n    uniform sampler2D uTexture;\n\n    varying vec2 vPUv;\n    varying vec2 vUv;\n\n    void main() {\n      vec4 color = vec4(0.0);\n      vec2 uv = vUv;\n      vec2 puv = vPUv;\n\n      // pixel color\n      vec4 colA = texture2D(uTexture, puv);\n\n      // greyscale\n      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;\n      //vec4 colB = vec4(grey, grey, grey, 1.0);\n      vec4 colB = vec4(colA.r, colA.g, colA.b, 1.0);\n\n      // circle\n      float border = 0.3;\n      float radius = 0.5;\n      float dist = radius - distance(uv, vec2(0.5));\n      float t = smoothstep(0.0, border, dist);\n\n      // final color\n      color = colB;\n      color.a = t;\n\n      gl_FragColor = color;\n    }\n    ";
        }
        return Shaders;
    }());

    var RxjsTween;
    (function (RxjsTween) {
        function createTween(easingFunction, b, c, d, s) {
            return new rxjs.Observable(function (observer) {
                var startTime;
                var sample = function (time) {
                    startTime = startTime || time;
                    var t = time - startTime;
                    if (t < d) {
                        if (Array.isArray(b) && Array.isArray(c)) {
                            var tweenVals = new Array();
                            for (var idx = 0; idx < b.length; idx++) {
                                tweenVals.push(easingFunction(t, b[idx], c[idx], d, s));
                            }
                            observer.next(tweenVals);
                        }
                        else {
                            observer.next(easingFunction(t, b, c, d, s));
                        }
                        // Request the animation frame again
                        requestAnimationFrame(sample);
                    }
                    else {
                        // End value reached
                        if (Array.isArray(b) && Array.isArray(c)) {
                            var tweenVals = new Array();
                            for (var idx = 0; idx < b.length; idx++) {
                                tweenVals.push(c[idx]);
                            }
                            // Emitt end value of arry
                            observer.next(tweenVals);
                        }
                        else {
                            // Emitt end value
                            observer.next(c);
                        }
                        // Complete the observable
                        observer.complete();
                    }
                };
                // Initially request the animation frame
                requestAnimationFrame(sample);
            });
        }
        RxjsTween.createTween = createTween;
        function linear(t, b, pc, d) {
            var c = pc - b;
            return c * t / d + b;
        }
        RxjsTween.linear = linear;
        function easeInOutQuad(t, b, pc, d) {
            var c = pc - b;
            if ((t /= d / 2) < 1) {
                return c / 2 * t * t + b;
            }
            else {
                return -c / 2 * ((--t) * (t - 2) - 1) + b;
            }
        }
        RxjsTween.easeInOutQuad = easeInOutQuad;
    })(RxjsTween || (RxjsTween = {}));

    var ImageAsParticlesComponent = /** @class */ (function () {
        function ImageAsParticlesComponent(ngZone) {
            this.ngZone = ngZone;
            // Declare variables
            this.renderer = new three.WebGLRenderer({ antialias: true, alpha: true });
            this.scene = new three.Scene();
            this.clock = new three.Clock(true);
            this.texture = new three.Texture();
            this.width = 0;
            this.height = 0;
            this.touch = new TouchTexture();
            this.mouse = new three.Vector2();
            this.raycaster = new three.Raycaster();
            this.pImageUrl = '';
            this.pImageChanging = false;
            this.gestureInfo$ = rxjs.interval(2000);
            this.gestureInfoSubscription = new rxjs.Subscription();
            this.showTouchGestureInfo = false;
            this.justifyContent = 'center';
            this.alignItems = 'center';
            this.backgroundColor = '#000000';
            this.imageWidth = '100%';
            this.imageHeight = '100%';
            this.animationEnabled = true;
        }
        Object.defineProperty(ImageAsParticlesComponent.prototype, "imageUrl", {
            get: function () { return this.pImageUrl; },
            // Inputs
            set: function (imageUrl) {
                this.pImageUrl = imageUrl;
                if (this.pImageChanging === true) {
                    return;
                }
                if (this.mesh != null) {
                    this.pImageChanging = true;
                    this.triggerImageChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageAsParticlesComponent.prototype, "horizontalAlignment", {
            get: function () { return this.justifyContent; },
            set: function (horizontalAlignment) {
                switch (horizontalAlignment) {
                    case 'start':
                        this.justifyContent = 'flex-start';
                        break;
                    case 'center':
                        this.justifyContent = 'center';
                        break;
                    case 'end':
                        this.justifyContent = 'flex-end';
                        break;
                    default:
                        this.justifyContent = 'center';
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageAsParticlesComponent.prototype, "verticalAlignment", {
            get: function () { return this.alignItems; },
            set: function (verticalAlignment) {
                switch (verticalAlignment) {
                    case 'top':
                        this.alignItems = 'flex-start';
                        break;
                    case 'center':
                        this.alignItems = 'center';
                        break;
                    case 'bottom':
                        this.alignItems = 'flex-end';
                        break;
                    default:
                        this.alignItems = 'center';
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        ImageAsParticlesComponent.prototype.ngAfterViewInit = function () {
            if (this.pImageUrl === '') {
                return;
            }
            var canvasWidth = this.canvasRef.nativeElement.clientWidth;
            var canvasHeight = this.canvasRef.nativeElement.clientHeight;
            // Set camera
            this.camera = new three.PerspectiveCamera(50, canvasWidth / canvasHeight, 1, 10000);
            this.camera.position.z = 300;
            // Init particles
            this.initParticles(this.pImageUrl);
            // Init renderer
            this.renderer.setSize(canvasWidth - 1, canvasHeight);
            this.canvasRef.nativeElement.appendChild(this.renderer.domElement);
            // Start animation
            this.animate();
        };
        ImageAsParticlesComponent.prototype.ngOnDestroy = function () {
            this.scene.clear();
            this.renderer.clear();
            this.texture.dispose();
            this.renderer.dispose();
        };
        /**
         * Creates the particles depending on the image and initializes the touch canvas
         * @param url url of the image
         */
        ImageAsParticlesComponent.prototype.initParticles = function (url) {
            var _this = this;
            var loader = new three.TextureLoader();
            loader.load(url, function (texture) {
                _this.texture = texture;
                _this.texture.minFilter = three.LinearFilter;
                _this.texture.magFilter = three.LinearFilter;
                _this.texture.format = three.RGBFormat;
                _this.width = texture.image.width;
                _this.height = texture.image.height;
                _this.initPoints(true);
                _this.initHitArea();
                _this.initTouch();
                _this.resize();
                _this.show();
            });
        };
        /**
         * Initializes the points
         * @param discard discard pixels darker than threshold #22
         */
        ImageAsParticlesComponent.prototype.initPoints = function (discard) {
            var numPoints = this.width * this.height;
            var numVisible = numPoints;
            var threshold = 0;
            var originalColors = new Float32Array();
            if (discard) {
                // discard pixels darker than threshold #22
                numVisible = 0;
                threshold = 34;
                var img = this.texture.image;
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                canvas.width = this.width;
                canvas.height = this.height;
                if (ctx != null) {
                    ctx.scale(1, -1);
                    ctx.drawImage(img, 0, 0, this.width, this.height * -1);
                    var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    originalColors = Float32Array.from(imgData.data);
                    for (var i = 0; i < numPoints; i++) {
                        if (originalColors[i * 4 + 0] > threshold) {
                            numVisible++;
                        }
                    }
                }
            }
            var uniforms = {
                uTime: { value: 0 },
                uRandom: { value: 1.0 },
                uDepth: { value: 2.0 },
                uSize: { value: 0.0 },
                uTextureSize: { value: new three.Vector2(this.width, this.height) },
                uTexture: { value: this.texture },
                uTouch: { value: null },
            };
            var shaders = new Shaders();
            var material = new three.RawShaderMaterial({
                uniforms: uniforms,
                vertexShader: shaders.particleVertex,
                fragmentShader: shaders.particleFragment,
                depthTest: false,
                transparent: true,
                // blending: THREE.AdditiveBlending
            });
            var geometry = new three.InstancedBufferGeometry();
            // positions
            var positions = new three.BufferAttribute(new Float32Array(4 * 3), 3);
            positions.setXYZ(0, -0.5, 0.5, 0.0);
            positions.setXYZ(1, 0.5, 0.5, 0.0);
            positions.setXYZ(2, -0.5, -0.5, 0.0);
            positions.setXYZ(3, 0.5, -0.5, 0.0);
            geometry.setAttribute('position', positions);
            // uvs
            var uvs = new three.BufferAttribute(new Float32Array(4 * 2), 2);
            uvs.setXY(0, 0.0, 0.0);
            uvs.setXY(1, 1.0, 0.0);
            uvs.setXY(2, 0.0, 1.0);
            uvs.setXY(3, 1.0, 1.0);
            geometry.setAttribute('uv', uvs);
            // index
            geometry.setIndex(new three.BufferAttribute(new Uint16Array([0, 2, 1, 2, 3, 1]), 1));
            var indices = new Uint16Array(numVisible);
            var offsets = new Float32Array(numVisible * 3);
            var angles = new Float32Array(numVisible);
            for (var i = 0, j = 0; i < numPoints; i++) {
                if (discard && originalColors[i * 4 + 0] <= threshold) {
                    continue;
                }
                offsets[j * 3 + 0] = i % this.width;
                offsets[j * 3 + 1] = Math.floor(i / this.width);
                indices[j] = i;
                angles[j] = Math.random() * Math.PI;
                j++;
            }
            geometry.setAttribute('pindex', new three.InstancedBufferAttribute(indices, 1, false));
            geometry.setAttribute('offset', new three.InstancedBufferAttribute(offsets, 3, false));
            geometry.setAttribute('angle', new three.InstancedBufferAttribute(angles, 1, false));
            this.mesh = new three.Mesh(geometry, material);
            var object3d = new three.Object3D();
            object3d.add(this.mesh);
            this.scene.add(object3d);
        };
        /**
         * Initializes the touch area
         */
        ImageAsParticlesComponent.prototype.initTouch = function () {
            this.mesh.material.uniforms.uTouch.value = this.touch.texture;
        };
        /**
         * Initializes the hit area
         */
        ImageAsParticlesComponent.prototype.initHitArea = function () {
            var geometry = new three.PlaneGeometry(this.width, this.height, 1, 1);
            var material = new three.MeshBasicMaterial({ color: 0xFFFFFF, wireframe: true, depthTest: false });
            material.visible = false;
            this.hitArea = new three.Mesh(geometry, material);
            this.mesh.add(this.hitArea);
        };
        /**
         * animation for showing the particles
         * @param time time of animation in ms
         */
        ImageAsParticlesComponent.prototype.show = function (time) {
            var _this = this;
            if (time === void 0) { time = 1000; }
            // Tween in
            this.ngZone.runOutsideAngular(function () {
                RxjsTween.createTween(RxjsTween.easeInOutQuad, [0.5, 0.0, 70.0], [1.5, 2.0, 4.0], time).subscribe(function (val) {
                    _this.mesh.material.uniforms.uSize.value = val[0];
                    _this.mesh.material.uniforms.uRandom.value = val[1];
                    _this.mesh.material.uniforms.uDepth.value = val[2];
                }, function () { }, function () {
                    _this.pImageChanging = false;
                });
            });
        };
        /**
         * animation for tween out the particles and destroy everything
         * @param time time of animation in ms
         */
        ImageAsParticlesComponent.prototype.triggerImageChange = function (time) {
            var _this = this;
            if (time === void 0) { time = 1000; }
            var uSizeStart = this.mesh.material.uniforms.uSize.value;
            var uRandomStart = this.mesh.material.uniforms.uRandom.value;
            var uDepth = this.mesh.material.uniforms.uDepth.value;
            this.ngZone.runOutsideAngular(function () {
                // Tween out
                RxjsTween.createTween(RxjsTween.easeInOutQuad, [uSizeStart, uRandomStart, uDepth], [0.0, 5.0, -20.0], time).subscribe(function (val) {
                    _this.mesh.material.uniforms.uSize.value = val[0];
                    _this.mesh.material.uniforms.uRandom.value = val[1];
                    _this.mesh.material.uniforms.uDepth.value = val[2];
                }, function () { }, function () {
                    if (_this.mesh != null) {
                        if (_this.mesh.parent != null) {
                            _this.mesh.parent.remove(_this.mesh);
                        }
                        _this.mesh.geometry.dispose();
                        _this.mesh.material.dispose();
                    }
                    if (_this.hitArea != null) {
                        if (_this.hitArea.parent != null) {
                            _this.hitArea.parent.remove(_this.hitArea);
                        }
                        _this.hitArea.geometry.dispose();
                        _this.hitArea.material.dispose();
                    }
                    _this.initParticles(_this.pImageUrl);
                    _this.pImageChanging = false;
                });
            });
        };
        /**
         * Method for triggering the animation
         */
        ImageAsParticlesComponent.prototype.animate = function () {
            var _this = this;
            this.ngZone.runOutsideAngular(function () {
                window.requestAnimationFrame(function () { return _this.animate(); });
                if (_this.animationEnabled === true) {
                    var delta = _this.clock.getDelta();
                    if (_this.mesh != null) {
                        if (_this.touch) {
                            _this.touch.update();
                        }
                        _this.mesh.material.uniforms.uTime.value += delta;
                    }
                    _this.renderer.render(_this.scene, _this.camera);
                }
            });
        };
        /**
         * Handle mouse move event
         * @param event mouse event
         */
        ImageAsParticlesComponent.prototype.onMouseMove = function (event) {
            // getBoundingClientRect retruns the distance in pixels of the top left corner of the element
            // to the top left corner of the viewport
            var domRect = this.canvasRef.nativeElement.getBoundingClientRect();
            // get the offset distance between the canvas, which contains the particles, to the outer container element
            var canvasEl = this.canvasRef.nativeElement.children[0];
            // Calculate the relative mouse position
            this.mouse.x = (event.clientX - domRect.left - canvasEl.offsetLeft) / canvasEl.clientWidth * 2 - 1;
            this.mouse.y = -(event.clientY - domRect.top - canvasEl.offsetTop) / canvasEl.clientHeight * 2 + 1;
            // console.info('raw: x= ' + event.clientX + ' , y= ' + event.clientY);
            // console.info('normalized: x= ' + this.mouse.x + ' , y= ' + this.mouse.y);
            this.raycaster.setFromCamera(this.mouse, this.camera);
            if (this.hitArea === undefined) {
                return;
            }
            var intersects = this.raycaster.intersectObject(this.hitArea);
            if (intersects !== undefined && intersects.length > 0 && this.touch && intersects[0].uv !== undefined) {
                this.touch.addTouch(intersects[0].uv.x, intersects[0].uv.y);
            }
        };
        /**
         * Handle touch move envent
         * @param event mouse event
         */
        ImageAsParticlesComponent.prototype.onTouchMove = function (event) {
            var _this = this;
            if (event.touches.length < 2) {
                this.showTouchGestureInfo = true;
                this.gestureInfoSubscription.unsubscribe();
                this.gestureInfoSubscription = this.gestureInfo$.subscribe({
                    next: function () {
                        _this.showTouchGestureInfo = false;
                        _this.gestureInfoSubscription.unsubscribe();
                    }
                });
                return;
            }
            event.preventDefault();
            // getBoundingClientRect retruns the distance in pixels of the top left corner of the element
            // to the top left corner of the viewport
            var domRect = this.canvasRef.nativeElement.getBoundingClientRect();
            // get the offset distance between the canvas, which contains the particles, to the outer container element
            var canvasEl = this.canvasRef.nativeElement.children[0];
            // Calculate the relative mouse position
            this.mouse.x = (event.touches[0].clientX - domRect.left - canvasEl.offsetLeft) / canvasEl.clientWidth * 2 - 1;
            this.mouse.y = -(event.touches[0].clientY - domRect.top - canvasEl.offsetTop) / canvasEl.clientHeight * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, this.camera);
            var intersects = this.raycaster.intersectObject(this.hitArea);
            if (intersects !== undefined && intersects.length > 0 && this.touch && intersects[0].uv !== undefined) {
                this.touch.addTouch(intersects[0].uv.x, intersects[0].uv.y);
            }
        };
        ImageAsParticlesComponent.prototype.resize = function () {
            if (this.height !== undefined) {
                this.camera.aspect = this.canvasRef.nativeElement.clientWidth / this.canvasRef.nativeElement.clientHeight;
                this.camera.updateProjectionMatrix();
                var fovHeight = 2 * Math.tan(this.camera.fov * Math.PI / 180 / 2) * this.camera.position.z;
                var scale = fovHeight / this.height;
                this.mesh.scale.set(scale, scale, 1);
                // this.hitArea.scale.set(scale, scale, 1);
                if (this.renderer !== undefined) {
                    var width = this.imageWidth == null ? this.canvasRef.nativeElement.clientWidth :
                        this.distanceAsNumber(this.imageWidth, this.canvasRef.nativeElement.clientWidth);
                    var height = this.imageHeight == null ? this.canvasRef.nativeElement.clientHeight :
                        this.distanceAsNumber(this.imageHeight, this.canvasRef.nativeElement.clientHeight);
                    this.renderer.setSize(width, height);
                }
            }
        };
        ImageAsParticlesComponent.prototype.distanceAsNumber = function (distance, parentDistance) {
            var returnVal = 0;
            if (distance.includes('px')) {
                returnVal = Number.parseInt(distance.replace('px', ''), 10);
            }
            else if (distance.includes('%')) {
                returnVal = Number.parseInt(distance.replace('%', ''), 10) / 100 * parentDistance;
            }
            else {
                returnVal = Number.parseInt(distance, 10);
            }
            return returnVal;
        };
        return ImageAsParticlesComponent;
    }());
    ImageAsParticlesComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'lib-image-as-particles',
                    template: "\n    <div #container class=\"threejs-container\" [style.background-color]=\"backgroundColor\"\n                      [style.justify-content]=\"justifyContent\"\n                      [style.align-items]=\"alignItems\"\n                      (mousemove)=\"onMouseMove($event)\" (touchmove)=\"onTouchMove($event)\"></div>\n    <div *ngIf=\"showTouchGestureInfo==true\" class=\"touch-gesture-info\" [@showHideGestureInformation]>\n      <div>\n        <span>Use two fingers for touch animation</span>\n        <svg xmlns=\"http://www.w3.org/2000/svg\" enable-background=\"new 0 0 24 24\" viewBox=\"0 0 24 24\" fill=\"white\" width=\"18px\" height=\"18px\">\n          <g><rect fill=\"none\" height=\"24\" width=\"24\" x=\"0\"/></g><g><g><g>\n            <path d=\"M9,11.24V7.5C9,6.12,10.12,5,11.5,5S14,6.12,14,7.5v3.74c1.21-0.81,2-2.18,2-3.74C16,5.01,13.99,3,11.5,3S7,5.01,7,7.5 C7,9.06,7.79,10.43,9,11.24z M18.84,15.87l-4.54-2.26c-0.17-0.07-0.35-0.11-0.54-0.11H13v-6C13,6.67,12.33,6,11.5,6 S10,6.67,10,7.5v10.74c-3.6-0.76-3.54-0.75-3.67-0.75c-0.31,0-0.59,0.13-0.79,0.33l-0.79,0.8l4.94,4.94 C9.96,23.83,10.34,24,10.75,24h6.79c0.75,0,1.33-0.55,1.44-1.28l0.75-5.27c0.01-0.07,0.02-0.14,0.02-0.2 C19.75,16.63,19.37,16.09,18.84,15.87z\"/></g></g></g>\n          </svg>\n      </div>\n    </div>\n  ",
                    animations: [
                        animations.trigger('showHideGestureInformation', [
                            animations.transition(':enter', [
                                animations.style({ opacity: '0' }),
                                animations.animate('300ms ease-in', animations.style({ opacity: '1' }))
                            ]),
                            animations.transition(':leave', [
                                animations.style({ opacity: '1' }),
                                animations.animate('300ms ease-in', animations.style({ opacity: '0' }))
                            ])
                        ])
                    ],
                    styles: ["\n    .threejs-container{\n      position: relative;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      width: 100%;\n      height: 100%;\n      background-color: #222222;\n    }\n\n    .touch-gesture-info{\n      position: absolute;\n      width: 100%;\n      display: flex;\n      flex-direction: row;\n      justify-content: center;\n      top: 20px;\n      color: white;\n    }\n\n    .touch-gesture-info div{\n      background-color: rgba(0,0,0,0.3);\n      display: flex;\n      flex-direction: row;\n      padding: 6px 10px 6px 10px;\n      border-radius: 5px;\n    }\n  "]
                },] }
    ];
    ImageAsParticlesComponent.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    ImageAsParticlesComponent.propDecorators = {
        imageUrl: [{ type: core.Input }],
        backgroundColor: [{ type: core.Input }],
        imageWidth: [{ type: core.Input }],
        imageHeight: [{ type: core.Input }],
        horizontalAlignment: [{ type: core.Input }],
        verticalAlignment: [{ type: core.Input }],
        animationEnabled: [{ type: core.Input }],
        canvasRef: [{ type: core.ViewChild, args: ['container',] }],
        resize: [{ type: core.HostListener, args: ['window:resize',] }]
    };

    var ImageAsParticlesModule = /** @class */ (function () {
        function ImageAsParticlesModule() {
        }
        return ImageAsParticlesModule;
    }());
    ImageAsParticlesModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ImageAsParticlesComponent],
                    imports: [
                        common.CommonModule
                    ],
                    exports: [ImageAsParticlesComponent]
                },] }
    ];

    var ImageTransitionShaders = /** @class */ (function () {
        function ImageTransitionShaders() {
            this.vertex = "varying vec2 vUv;void main() {vUv = uv;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}";
            this.splitTransitionFrag = "\n            uniform float progress;\n            uniform float intensity;\n            uniform sampler2D texture1;\n            uniform sampler2D texture2;\n            uniform vec4 resolution1;\n            uniform vec4 resolution2;\n            varying vec2 vUv;\n            mat2 rotate(float a) {\n              float s = sin(a);\n              float c = cos(a);\n              return mat2(c, -s, s, c);\n            }\n            void main()\t{\n              vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);\n              vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);\n              vec2 uvDivided1 = fract(newUV1*vec2(intensity,1.));\n              vec2 uvDivided2 = fract(newUV2*vec2(intensity,1.));\n              vec2 uvDisplaced1 = newUV1 + rotate(3.1415926/4.)*uvDivided1*progress*0.1;\n              vec2 uvDisplaced2 = newUV2 + rotate(3.1415926/4.)*uvDivided2*(1. - progress)*0.1;\n              vec4 t1 = texture2D(texture1,uvDisplaced1);\n              vec4 t2 = texture2D(texture2,uvDisplaced2);\n              // Use black background color\n              // Top right\n              vec2 tr1 = step(newUV1, vec2(1.0, 1.0));\n              vec2 tr2 = step(newUV2, vec2(1.0, 1.0));\n              float pct1 = tr1.x * tr1.y;\n              float pct2 = tr2.x * tr2.y;\n              // Bottom left\n              vec2 bl1 = step(vec2(0.0, 0.0), newUV1);\n              vec2 bl2 = step(vec2(0.0, 0.0), newUV2);\n              pct1 *= bl1.x * bl1.y;\n              pct2 *= bl2.x * bl2.y;\n              vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);\n              vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);\n              gl_FragColor = mix(t1wb, t2wb, progress);\n            }\n    ";
            this.fadeFrag = "\n            uniform float progress;\n            uniform sampler2D texture1;\n            uniform sampler2D texture2;\n            uniform vec4 resolution1;\n            uniform vec4 resolution2;\n            varying vec2 vUv;\n            mat2 rotate(float a) {\n              float s = sin(a);\n              float c = cos(a);\n              return mat2(c, -s, s, c);\n            }\n            void main()\t{\n              vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);\n              vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);\n              vec2 uvDisplaced1 = newUV1 + vec2(1.0,0)*progress*0.1;\n              vec2 uvDisplaced2 = newUV2 + vec2(1.0,0)*(1. - progress)*0.1;\n              vec4 t1 = texture2D(texture1,uvDisplaced1);\n              vec4 t2 = texture2D(texture2,uvDisplaced2);\n              // Use black background color\n              // Top right\n              vec2 tr1 = step(newUV1, vec2(1.0, 1.0));\n              vec2 tr2 = step(newUV2, vec2(1.0, 1.0));\n              float pct1 = tr1.x * tr1.y;\n              float pct2 = tr2.x * tr2.y;\n              // Bottom left\n              vec2 bl1 = step(vec2(0.0, 0.0), newUV1);\n              vec2 bl2 = step(vec2(0.0, 0.0), newUV2);\n              pct1 *= bl1.x * bl1.y;\n              pct2 *= bl2.x * bl2.y;\n              vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);\n              vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);\n              gl_FragColor = mix(t1wb, t2wb, progress);\n            }\n    ";
            this.noiseFrag = "\n\t\tuniform float time;\n\t\tuniform float progress;\n\t\tuniform float width;\n\t\tuniform float scaleX;\n\t\tuniform float scaleY;\n\t\tuniform sampler2D texture1;\n\t\tuniform sampler2D texture2;\n\t\tuniform sampler2D displacement;\n\t\tuniform vec4 resolution1;\n\t\tuniform vec4 resolution2;\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vPosition;\n\t\t//\tClassic Perlin 3D Noise\n\t\t//\tby Stefan Gustavson\n\t\t//\n\t\tvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\t\tvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\t\tvec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\t\tfloat cnoise(vec4 P){\n\t\t  ;\n\t\t  vec4 Pi0 = floor(P); // Integer part for indexing\n\t\t  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n\t\t  Pi0 = mod(Pi0, 289.0);\n\t\t  Pi1 = mod(Pi1, 289.0);\n\t\t  vec4 Pf0 = fract(P); // Fractional part for interpolation\n\t\t  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n\t\t  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t\t  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t\t  vec4 iz0 = vec4(Pi0.zzzz);\n\t\t  vec4 iz1 = vec4(Pi1.zzzz);\n\t\t  vec4 iw0 = vec4(Pi0.wwww);\n\t\t  vec4 iw1 = vec4(Pi1.wwww);\n\t\t  vec4 ixy = permute(permute(ix) + iy);\n\t\t  vec4 ixy0 = permute(ixy + iz0);\n\t\t  vec4 ixy1 = permute(ixy + iz1);\n\t\t  vec4 ixy00 = permute(ixy0 + iw0);\n\t\t  vec4 ixy01 = permute(ixy0 + iw1);\n\t\t  vec4 ixy10 = permute(ixy1 + iw0);\n\t\t  vec4 ixy11 = permute(ixy1 + iw1);\n\t\t  vec4 gx00 = ixy00 / 7.0;\n\t\t  vec4 gy00 = floor(gx00) / 7.0;\n\t\t  vec4 gz00 = floor(gy00) / 6.0;\n\t\t  gx00 = fract(gx00) - 0.5;\n\t\t  gy00 = fract(gy00) - 0.5;\n\t\t  gz00 = fract(gz00) - 0.5;\n\t\t  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n\t\t  vec4 sw00 = step(gw00, vec4(0.0));\n\t\t  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n\t\t  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\t\t  vec4 gx01 = ixy01 / 7.0;\n\t\t  vec4 gy01 = floor(gx01) / 7.0;\n\t\t  vec4 gz01 = floor(gy01) / 6.0;\n\t\t  gx01 = fract(gx01) - 0.5;\n\t\t  gy01 = fract(gy01) - 0.5;\n\t\t  gz01 = fract(gz01) - 0.5;\n\t\t  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n\t\t  vec4 sw01 = step(gw01, vec4(0.0));\n\t\t  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n\t\t  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\t\t  vec4 gx10 = ixy10 / 7.0;\n\t\t  vec4 gy10 = floor(gx10) / 7.0;\n\t\t  vec4 gz10 = floor(gy10) / 6.0;\n\t\t  gx10 = fract(gx10) - 0.5;\n\t\t  gy10 = fract(gy10) - 0.5;\n\t\t  gz10 = fract(gz10) - 0.5;\n\t\t  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n\t\t  vec4 sw10 = step(gw10, vec4(0.0));\n\t\t  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n\t\t  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\t\t  vec4 gx11 = ixy11 / 7.0;\n\t\t  vec4 gy11 = floor(gx11) / 7.0;\n\t\t  vec4 gz11 = floor(gy11) / 6.0;\n\t\t  gx11 = fract(gx11) - 0.5;\n\t\t  gy11 = fract(gy11) - 0.5;\n\t\t  gz11 = fract(gz11) - 0.5;\n\t\t  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n\t\t  vec4 sw11 = step(gw11, vec4(0.0));\n\t\t  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n\t\t  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\t\t  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n\t\t  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n\t\t  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n\t\t  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n\t\t  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n\t\t  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n\t\t  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n\t\t  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n\t\t  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n\t\t  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n\t\t  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n\t\t  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n\t\t  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n\t\t  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n\t\t  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n\t\t  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\t\t  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n\t\t  g0000 *= norm00.x;\n\t\t  g0100 *= norm00.y;\n\t\t  g1000 *= norm00.z;\n\t\t  g1100 *= norm00.w;\n\t\t  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n\t\t  g0001 *= norm01.x;\n\t\t  g0101 *= norm01.y;\n\t\t  g1001 *= norm01.z;\n\t\t  g1101 *= norm01.w;\n\t\t  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n\t\t  g0010 *= norm10.x;\n\t\t  g0110 *= norm10.y;\n\t\t  g1010 *= norm10.z;\n\t\t  g1110 *= norm10.w;\n\t\t  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n\t\t  g0011 *= norm11.x;\n\t\t  g0111 *= norm11.y;\n\t\t  g1011 *= norm11.z;\n\t\t  g1111 *= norm11.w;\n\t\t  float n0000 = dot(g0000, Pf0);\n\t\t  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n\t\t  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n\t\t  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n\t\t  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n\t\t  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n\t\t  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n\t\t  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n\t\t  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n\t\t  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n\t\t  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n\t\t  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n\t\t  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n\t\t  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n\t\t  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n\t\t  float n1111 = dot(g1111, Pf1);\n\t\t  vec4 fade_xyzw = fade(Pf0);\n\t\t  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n\t\t  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n\t\t  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n\t\t  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n\t\t  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n\t\t  return 2.2 * n_xyzw;\n\t\t}\n\t\tfloat map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t\t}\n\t\tfloat parabola( float x, float k ) {\n\t\t  return pow( 4. * x * ( 1. - x ), k );\n\t\t}\n\t\tvoid main()\t{\n\t\t\tfloat dt = parabola(progress,1.);\n\t\t\tfloat border = 1.;\n\t\t\tvec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);\n      \t\tvec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);\n\t\t\tvec4 t1 = texture2D(texture1,newUV1);\n      \t\tvec4 t2 = texture2D(texture2,newUV2);\n      \t\t// Use black background color\n      \t\t// Top right\n      \t\tvec2 tr1 = step(newUV1, vec2(1.0, 1.0));\n      \t\tvec2 tr2 = step(newUV2, vec2(1.0, 1.0));\n      \t\tfloat pct1 = tr1.x * tr1.y;\n      \t\tfloat pct2 = tr2.x * tr2.y;\n      \t\t// Bottom left\n      \t\tvec2 bl1 = step(vec2(0.0, 0.0), newUV1);\n      \t\tvec2 bl2 = step(vec2(0.0, 0.0), newUV2);\n      \t\tpct1 *= bl1.x * bl1.y;\n      \t\tpct2 *= bl2.x * bl2.y;\n      \t\tvec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);\n      \t\tvec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);\n\t\t\tfloat realnoise = 0.5*(cnoise(vec4(newUV1.x*scaleX  + 0.*time/3., newUV1.y*scaleY,0.*time/3.,0.)) +1.);\n\t\t\tfloat w = width*dt;\n\t\t\tfloat maskvalue = smoothstep(1. - w,1.,vUv.x + mix(-w/2., 1. - w/2., progress));\n\t\t\tfloat mask = maskvalue + maskvalue*realnoise;\n\t\t\tfloat final = smoothstep(border,border+0.01,mask);\n\t\t\tgl_FragColor = mix(t1wb,t2wb,final);\n\t\t}\n\t";
            this.blurFrag = "\n\t\t// author: gre\n\t\t// license: MIT\n\t\tuniform float progress;\n\t\tuniform float intensity;\n\t\tuniform float ratio;\n\t\tuniform sampler2D texture1;\n\t\tuniform sampler2D texture2;\n\t\tuniform vec4 resolution1;\n\t\tuniform vec4 resolution2;\n\t\tvarying vec2 vUv;\n\t\tconst int passes = 6;\n\n\t\tvoid main() {\n\t\t\tvec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);\n\t\t\tvec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);\n\n\t\t\tvec4 t1 = vec4(0.0);\n\t\t\tvec4 t2 = vec4(0.0);\n\t\t\tfloat disp = intensity/100.0*(0.5-distance(0.5, progress));\n\t\t\tfor (int xi=0; xi<passes; xi++)\n\t\t\t{\n\t\t\t\tfloat x = float(xi) / float(passes) - 0.5;\n\t\t\t\tfor (int yi=0; yi<passes; yi++)\n\t\t\t\t{\n\t\t\t\t\tfloat y = float(yi) / float(passes) - 0.5;\n\t\t\t\t\tvec2 v = vec2(x,y);\n\t\t\t\t\tfloat d = disp;\n\t\t\t\t\tt1 += texture2D(texture1,newUV1 + d*v);\n\t\t\t\t\tt2 += texture2D(texture2,newUV2 + d*v);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt1 /= float(passes*passes);\n\t\t\tt2 /= float(passes*passes);\n\n\t\t\t// Use black background color\n\t\t\t// Top right\n\t\t\tvec2 tr1 = step(newUV1, vec2(1.0, 1.0));\n\t\t\tvec2 tr2 = step(newUV2, vec2(1.0, 1.0));\n\t\t\tfloat pct1 = tr1.x * tr1.y;\n\t\t\tfloat pct2 = tr2.x * tr2.y;\n\t\t\t// Bottom left\n\t\t\tvec2 bl1 = step(vec2(0.0, 0.0), newUV1);\n\t\t\tvec2 bl2 = step(vec2(0.0, 0.0), newUV2);\n\t\t\tpct1 *= bl1.x * bl1.y;\n\t\t\tpct2 *= bl2.x * bl2.y;\n\t\t\tvec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);\n\t\t\tvec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);\n\t\t\tgl_FragColor = mix(t1wb, t2wb, progress);\n\t\t}\n\t";
        }
        return ImageTransitionShaders;
    }());

    var ImageTransitionComponent = /** @class */ (function () {
        function ImageTransitionComponent(ngZone) {
            this.ngZone = ngZone;
            this.imageUrls = new Array();
            this.transitionDuration = 1000;
            this.animationEnabled = true;
            this.startIndex = 0;
            this.imageIndexChange = new core.EventEmitter();
            this.pAutoPlay = false;
            this.pAutoPlayInterval = 5000;
            this.pImageSize = 'cover';
            this.pTransitionType = 'split';
            this.pIntensity = 40.0;
            this.pScaleX = 50.0;
            this.pScaleY = 50.0;
            this.pWidth = 0.5;
            this.renderer = new three.WebGLRenderer({ antialias: true, alpha: true });
            this.scene = new three.Scene();
            this.textures = new Array();
            this.nextImageIndex = 0;
            this.tranistionOngoing = false;
            this.shaders = new ImageTransitionShaders();
            this.autoPlay$ = new rxjs.Observable();
            this.autoPlaySubscription = new rxjs.Subscription();
        }
        Object.defineProperty(ImageTransitionComponent.prototype, "imageSize", {
            get: function () { return this.pImageSize; },
            set: function (imageSize) {
                this.pImageSize = imageSize;
                if (this.mesh != null) {
                    this.resize();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "autoPlay", {
            get: function () { return this.pAutoPlay; },
            set: function (autoplay) {
                this.pAutoPlay = autoplay;
                if (this.mesh != null) {
                    if (this.pAutoPlay === true) {
                        this.setAutoPlayInterval();
                    }
                    else {
                        this.stopAutoPlayInterval();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "autoPlayInterval", {
            get: function () { return this.pAutoPlayInterval; },
            set: function (autoPlayInterval) {
                this.pAutoPlayInterval = autoPlayInterval;
                if (this.mesh != null) {
                    if (this.pAutoPlay === true) {
                        this.stopAutoPlayInterval();
                        this.setAutoPlayInterval();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "transitionType", {
            get: function () { return this.pTransitionType; },
            set: function (transitionType) {
                this.pTransitionType = transitionType;
                if (this.material != null) {
                    this.setShaderProperties();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "sizeX", {
            get: function () { return this.pScaleX; },
            set: function (sizeX) {
                this.pScaleX = sizeX;
                if (this.material != null) {
                    this.setShaderProperties();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "sizeY", {
            get: function () { return this.pScaleY; },
            set: function (sizeY) {
                this.pScaleY = sizeY;
                if (this.material != null) {
                    this.setShaderProperties();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "width", {
            get: function () { return this.pWidth; },
            set: function (width) {
                this.pWidth = width;
                if (this.material != null) {
                    this.setShaderProperties();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageTransitionComponent.prototype, "intensity", {
            get: function () { return this.intensity; },
            set: function (intensity) {
                this.pIntensity = intensity;
                if (this.material != null) {
                    this.setShaderProperties();
                }
            },
            enumerable: false,
            configurable: true
        });
        ImageTransitionComponent.prototype.ngAfterViewInit = function () {
            // Init camera
            this.camera = new three.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.001, 1000);
            this.camera.position.set(0, 0, 2);
            // Create scene
            this.scene = new three.Scene();
            // Init Mesh
            if (this.imageUrls.length < 2) {
                throw new Error('At least two images are required');
            }
            this.initMesh();
            // Init renderer
            var canvasWidth = this.threejsContainer.nativeElement.clientWidth;
            var canvasHeight = this.threejsContainer.nativeElement.clientHeight;
            this.renderer.setSize(canvasWidth, canvasHeight);
            this.threejsContainer.nativeElement.appendChild(this.renderer.domElement);
            // Init autoPlay Observable
            if (this.pAutoPlay === true) {
                this.setAutoPlayInterval();
            }
            this.animate();
        };
        ImageTransitionComponent.prototype.ngOnDestroy = function () {
            // Cancel Animation
            cancelAnimationFrame(this.animationFrameId);
            // Stop autoplay animation
            this.stopAutoPlayInterval();
            // Remove threejs container from DOM
            this.threejsContainer.nativeElement.removeChild(this.renderer.domElement);
            // Dispose textures
            this.textures.forEach(function (t) {
                t.dispose();
            });
            // Dispose material
            if (this.material) {
                this.material.dispose();
            }
            // Clear scene
            if (this.scene) {
                this.scene.clear();
            }
            // Dispose renderer
            if (this.renderer) {
                this.renderer.dispose();
            }
        };
        /**
         * Initializes the mesh
         */
        ImageTransitionComponent.prototype.initMesh = function () {
            var _this = this;
            // Create geometry
            var geometry = new three.PlaneBufferGeometry(1, 1, 2, 2);
            var promises = new Array();
            // Load pev, current and next textures
            this.textures = new Array(this.imageUrls.length);
            var prevImg = this.startIndex === 0 ? (this.imageUrls.length - 1) : (this.startIndex - 1);
            var nextImg = this.startIndex === (this.imageUrls.length - 1) ? 0 : (this.startIndex + 1);
            var _loop_1 = function (idx) {
                if (idx === this_1.startIndex || idx === nextImg || idx === prevImg) {
                    promises.push(new Promise(function (resolve) {
                        _this.textures[idx] = (new three.TextureLoader()).load(_this.imageUrls[idx], resolve);
                    }));
                }
            };
            var this_1 = this;
            for (var idx = 0; idx < this.imageUrls.length; idx++) {
                _loop_1(idx);
            }
            this.nextImageIndex = this.startIndex;
            // Emit event to set current image index
            this.imageIndexChange.emit(this.nextImageIndex);
            Promise.all(promises).then(function () {
                _this.material = new three.ShaderMaterial({
                    side: three.DoubleSide,
                    uniforms: {
                        time: { value: 0 },
                        progress: { value: 0 },
                        border: { value: 0 },
                        intensity: { value: 50.0 },
                        scaleX: { value: 40.0 },
                        scaleY: { value: 40.0 },
                        transition: { value: 40.0 },
                        swipe: { value: 0 },
                        width: { value: 0.5 },
                        radius: { value: 0 },
                        texture1: { value: _this.textures[_this.startIndex] },
                        texture2: { value: _this.textures[nextImg] },
                        resolution1: { value: new three.Vector4() },
                        resolution2: { value: new three.Vector4() }
                    },
                    // wireframe: true,
                    vertexShader: _this.shaders.vertex
                });
                _this.setShaderProperties();
                _this.mesh = new three.Mesh(geometry, _this.material);
                _this.scene.add(_this.mesh);
                _this.resize();
            });
        };
        /**
         * Sets the autoPlay interval
         */
        ImageTransitionComponent.prototype.setAutoPlayInterval = function () {
            var _this = this;
            this.autoPlay$ = rxjs.interval(this.pAutoPlayInterval);
            this.autoPlaySubscription = this.autoPlay$.subscribe({
                next: function () { _this.prepAndLoadNextImg(false, true); }
            });
        };
        /**
         * Resets the autoPlay interval
         */
        ImageTransitionComponent.prototype.resetAutoPlayInterval = function () {
            var _this = this;
            this.autoPlaySubscription.unsubscribe();
            this.autoPlaySubscription = this.autoPlay$.subscribe({
                next: function () { _this.prepAndLoadNextImg(false, true); }
            });
        };
        /**
         * Stops the autoPlay interval
         */
        ImageTransitionComponent.prototype.stopAutoPlayInterval = function () {
            this.autoPlaySubscription.unsubscribe();
        };
        /**
         * Sets the shader properties depending on the transition type
         */
        ImageTransitionComponent.prototype.setShaderProperties = function () {
            switch (this.transitionType) {
                case 'split':
                    this.material.uniforms.intensity.value = this.pIntensity;
                    this.material.fragmentShader = this.shaders.splitTransitionFrag;
                    break;
                case 'fade':
                    this.material.fragmentShader = this.shaders.fadeFrag;
                    break;
                case 'noise':
                    this.material.uniforms.scaleX.value = this.pScaleX;
                    this.material.uniforms.scaleY.value = this.pScaleY;
                    this.material.uniforms.width.value = this.pWidth;
                    this.material.fragmentShader = this.shaders.noiseFrag;
                    break;
                case 'blur':
                    this.material.uniforms.intensity.value = this.pIntensity;
                    this.material.fragmentShader = this.shaders.blurFrag;
                    break;
                default:
                    break;
            }
            this.material.needsUpdate = true;
        };
        /**
         * Animation
         */
        ImageTransitionComponent.prototype.animate = function () {
            var _this = this;
            if (this.animationEnabled === true) {
                this.renderer.render(this.scene, this.camera);
            }
            this.ngZone.runOutsideAngular(function () {
                _this.animationFrameId = window.requestAnimationFrame(function () { return _this.animate(); });
            });
        };
        /**
         * Resizes the canvas and updates the texture resulution information of the images
         */
        ImageTransitionComponent.prototype.resize = function () {
            // Get the with and height of the container
            var containerWidth = this.threejsContainer.nativeElement.offsetWidth;
            var containerHeight = this.threejsContainer.nativeElement.offsetHeight;
            // return the function, if eihter with or heigth is undefined
            if (!containerHeight || !containerHeight) {
                return;
            }
            this.renderer.setSize(containerWidth, containerHeight);
            this.camera.aspect = containerWidth / containerHeight;
            this.updateTextureResolution(this.nextImageIndex, 1);
            var dist = this.camera.position.z;
            var height = 1;
            this.camera.fov = 2 * (180 / Math.PI) * Math.atan(height / (2 * dist));
            this.mesh.scale.x = this.camera.aspect;
            this.mesh.scale.y = 1;
            this.camera.updateProjectionMatrix();
        };
        /**
         * Updates the resulution of the texture for the shader depending on the image size type
         * @param textureNumber Number of the texture
         */
        ImageTransitionComponent.prototype.updateTextureResolution = function (textureNumber, targetGlslTexture) {
            var texture = this.textures[textureNumber];
            var containerWidth = this.threejsContainer.nativeElement.offsetWidth;
            var containerHeight = this.threejsContainer.nativeElement.offsetHeight;
            // Adapt the size of the image
            var imageAspect = texture.image.height / texture.image.width;
            var containerAspect = containerHeight / containerWidth;
            var a1;
            var a2;
            if (this.pImageSize === 'cover') {
                if (containerAspect > imageAspect) {
                    a1 = (containerWidth / containerHeight) * imageAspect;
                    a2 = 1;
                }
                else {
                    a1 = 1;
                    a2 = (containerHeight / containerWidth) / imageAspect;
                }
            }
            else if (this.pImageSize === 'contain') {
                if (containerAspect < imageAspect) {
                    a1 = (containerWidth / containerHeight) * imageAspect;
                    a2 = 1;
                }
                else {
                    a1 = 1;
                    a2 = (containerHeight / containerWidth) / imageAspect;
                }
            }
            if (targetGlslTexture === 1) {
                this.material.uniforms.resolution1.value.x = containerWidth;
                this.material.uniforms.resolution1.value.y = containerHeight;
                this.material.uniforms.resolution1.value.z = a1;
                this.material.uniforms.resolution1.value.w = a2;
            }
            else if (targetGlslTexture === 2) {
                this.material.uniforms.resolution2.value.x = containerWidth;
                this.material.uniforms.resolution2.value.y = containerHeight;
                this.material.uniforms.resolution2.value.z = a1;
                this.material.uniforms.resolution2.value.w = a2;
            }
        };
        /**
         * Starts the transition effect to the next image
         * @param posDirection indicator, if the next or previous image should be loaded
         */
        ImageTransitionComponent.prototype.transitionToNextTexture = function (backw) {
            var _this = this;
            if (backw === void 0) { backw = false; }
            // Set the flag to indicate that the transition animation is ongoing
            this.tranistionOngoing = true;
            // EventEmitter
            this.imageIndexChange.emit(this.nextImageIndex);
            this.ngZone.runOutsideAngular(function () {
                if (backw === true) {
                    _this.material.uniforms.texture2.value = _this.material.uniforms.texture1.value;
                    _this.material.uniforms.resolution2.value.x = _this.material.uniforms.resolution1.value.x;
                    _this.material.uniforms.resolution2.value.y = _this.material.uniforms.resolution1.value.y;
                    _this.material.uniforms.resolution2.value.z = _this.material.uniforms.resolution1.value.z;
                    _this.material.uniforms.resolution2.value.w = _this.material.uniforms.resolution1.value.w;
                    _this.material.uniforms.progress.value = 1;
                    // Set the next image to texture1 and update the resolution
                    _this.material.uniforms.texture1.value = _this.textures[_this.nextImageIndex];
                    _this.updateTextureResolution(_this.nextImageIndex, 1);
                    // Start the tween for doing the transition
                    RxjsTween.createTween(RxjsTween.linear, 1, 0, _this.transitionDuration).subscribe({
                        next: function (val) {
                            _this.material.uniforms.progress.value = val;
                        },
                        complete: function () {
                            // Set the transition flag to false to indicate that the transition animation is finished
                            _this.tranistionOngoing = false;
                            // Reset progress to 1, thus the texture from texture 2 needs to be set to texture 1
                            _this.material.uniforms.texture2.value = _this.textures[_this.nextImageIndex];
                            _this.updateTextureResolution(_this.nextImageIndex, 2);
                            _this.material.uniforms.progress.value = 0;
                        }
                    });
                }
                else {
                    // Set the next image to texture2 and update the resolution
                    _this.material.uniforms.texture2.value = _this.textures[_this.nextImageIndex];
                    _this.updateTextureResolution(_this.nextImageIndex, 2);
                    // Start the tween for doing the transition
                    RxjsTween.createTween(RxjsTween.linear, 0, 1, _this.transitionDuration).subscribe({
                        next: function (val) {
                            _this.material.uniforms.progress.value = val;
                        },
                        complete: function () {
                            // Set the transition flag to false to indicate that the transition animation is finished
                            _this.tranistionOngoing = false;
                            // Reset progress to 0, thus the texture from texture 2 needs to be set to texture 1
                            _this.material.uniforms.texture1.value = _this.textures[_this.nextImageIndex];
                            _this.updateTextureResolution(_this.nextImageIndex, 1);
                            _this.material.uniforms.progress.value = 0;
                        }
                    });
                }
            });
        };
        ImageTransitionComponent.prototype.prepAndLoadNextImg = function (prev, autoPlayTriggered) {
            if (this.tranistionOngoing) {
                return;
            }
            if (this.pAutoPlay === true && autoPlayTriggered === false) {
                this.resetAutoPlayInterval();
            }
            if (prev === false) {
                // Set the next index
                this.nextImageIndex = (this.nextImageIndex < this.imageUrls.length - 1) ? this.nextImageIndex + 1 : 0;
                // Check if another texture needs to be loaded
                var nextButOne = this.nextImageIndex + 1 > this.imageUrls.length - 1 ? 0 : this.nextImageIndex + 1;
                if (this.textures[nextButOne] === undefined) {
                    this.textures[nextButOne] = (new three.TextureLoader).load(this.imageUrls[nextButOne]);
                }
            }
            else {
                // Update the number of the current shown image
                this.nextImageIndex = (this.nextImageIndex > 0) ? this.nextImageIndex - 1 : this.imageUrls.length - 1;
                // Check if another texture needs to be loaded
                var nextButOne = this.nextImageIndex - 1 < 0 ? this.imageUrls.length - 1 : this.nextImageIndex - 1;
                if (this.textures[nextButOne] === undefined) {
                    this.textures[nextButOne] = (new three.TextureLoader).load(this.imageUrls[nextButOne]);
                }
            }
            this.transitionToNextTexture();
        };
        //#region public methods
        ImageTransitionComponent.prototype.next = function () {
            this.prepAndLoadNextImg(false, false);
        };
        ImageTransitionComponent.prototype.prev = function () {
            this.prepAndLoadNextImg(true, false);
        };
        return ImageTransitionComponent;
    }());
    ImageTransitionComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'lib-image-transition',
                    template: "<div #threejsContainer class=\"threejs-container\"></div>",
                    styles: [".threejs-container{width:100%;height:100%}"]
                },] }
    ];
    ImageTransitionComponent.ctorParameters = function () { return [
        { type: core.NgZone }
    ]; };
    ImageTransitionComponent.propDecorators = {
        imageUrls: [{ type: core.Input }],
        imageSize: [{ type: core.Input }],
        autoPlay: [{ type: core.Input }],
        autoPlayInterval: [{ type: core.Input }],
        transitionDuration: [{ type: core.Input }],
        transitionType: [{ type: core.Input }],
        sizeX: [{ type: core.Input }],
        sizeY: [{ type: core.Input }],
        width: [{ type: core.Input }],
        intensity: [{ type: core.Input }],
        animationEnabled: [{ type: core.Input }],
        startIndex: [{ type: core.Input }],
        imageIndexChange: [{ type: core.Output }],
        threejsContainer: [{ type: core.ViewChild, args: ['threejsContainer',] }],
        resize: [{ type: core.HostListener, args: ['window:resize',] }]
    };

    var ImageTransitionModule = /** @class */ (function () {
        function ImageTransitionModule() {
        }
        return ImageTransitionModule;
    }());
    ImageTransitionModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [ImageTransitionComponent],
                    imports: [
                        common.CommonModule
                    ],
                    exports: [ImageTransitionComponent]
                },] }
    ];

    var LightboxOverlayComponent = /** @class */ (function () {
        function LightboxOverlayComponent(changeRef) {
            this.changeRef = changeRef;
            this.imageUrls = new Array();
            this.forceFullscreen = false;
            this.forceShowNavButtons = false;
            this.imageSize = 'cover';
            this.autoPlay = false;
            this.autoPlayInterval = 5000;
            this.transitionDuration = 1000;
            this.transitionType = 'split';
            this.sizeX = 50.0;
            this.sizeY = 50.0;
            this.width = 0.5;
            this.intensity = 40.0;
            this.startIndex = 0;
            this.currentImageIndex = 1;
            this.swipeCoord = new Array();
            this.swipeTime = 0;
        }
        LightboxOverlayComponent.prototype.ngOnInit = function () {
        };
        LightboxOverlayComponent.prototype.keyEvent = function (event) {
            if (event.key === 'ArrowRight') {
                this.imageTransition.next();
            }
            if (event.key === 'ArrowLeft') {
                this.imageTransition.prev();
            }
            if (event.key === 'Escape') {
                this.close();
            }
        };
        /**
         * Close the lightbox
         */
        LightboxOverlayComponent.prototype.close = function () {
            var _a;
            (_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.detach();
        };
        /**
         * method to set the index counter
         * @param index index of the image
         */
        LightboxOverlayComponent.prototype.imageIndexChange = function (index) {
            this.currentImageIndex = index + 1;
            this.changeRef.detectChanges();
        };
        /**
         * Listen to touche events for gestures (mobile)
         * @param e touch event
         * @param when indicator if 'start' or 'end'
         */
        LightboxOverlayComponent.prototype.swipe = function (e, when) {
            var coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
            var time = new Date().getTime();
            if (when === 'start') {
                this.swipeCoord = coord;
                this.swipeTime = time;
            }
            else if (when === 'end') {
                var direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
                var duration = time - this.swipeTime;
                if (duration < 1000 && Math.abs(direction[0]) > 30 // Long enough
                    && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
                    var swipe = direction[0] < 0 ? 'next' : 'previous';
                    if (swipe === 'next') {
                        this.imageTransition.next();
                    }
                    else if (swipe === 'previous') {
                        this.imageTransition.prev();
                    }
                }
            }
        };
        return LightboxOverlayComponent;
    }());
    LightboxOverlayComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'lib-lightbox-overlay',
                    template: "<div [ngClass]=\"{'full-container': forceFullscreen === true, 'auto-container': forceFullscreen === false }\">\n    <div class=\"index-indicator\">\n        <span>{{ currentImageIndex }}</span>\n        <span>/</span>\n        <span>{{ imageUrls.length }}</span>\n    </div>\n    <svg class=\"ligthbox-button close-button\" (click)=\"close()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n    </svg>\n\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \n        class=\"ligthbox-button prev-button\" (click)=\"imageTransition.prev()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\" />\n    </svg>\n\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \n        class=\"ligthbox-button next-button\" (click)=\"imageTransition.next()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" />\n    </svg>\n    <lib-image-transition #imageTransition [imageUrls]=\"imageUrls\" [startIndex]=\"startIndex\" (imageIndexChange)=\"imageIndexChange($event)\"\n        [imageSize]=\"imageSize\" [autoPlay]=\"autoPlay\" [autoPlayInterval]=\"autoPlayInterval\" [transitionDuration]=\"transitionDuration\"\n        [transitionType]=\"transitionType\" [sizeX]=\"sizeX\" [sizeY]=\"sizeY\" [width]=\"width\" [intensity]=\"intensity\"\n        (touchstart)=\"swipe($event, 'start')\" (touchend)=\"swipe($event, 'end')\">\n    </lib-image-transition>\n</div>",
                    styles: [".auto-container{width:1100px;height:800px;max-width:90vw;max-height:90vh}.auto-container,.full-container{position:relative;background-color:#000;box-shadow:0 0 15px 10px rgba(0,0,0,.5)}.full-container{width:100vw;height:100vh;max-width:100vw;max-height:100vh}.index-indicator{color:#fff;border-radius:0 0 5px 0;padding:8px}.index-indicator,.ligthbox-button{position:absolute;z-index:1;background-color:rgba(0,0,0,.4)}.ligthbox-button{cursor:pointer;width:36px;height:36px}.ligthbox-button:hover{fill:hsla(0,0%,100%,.5)}.close-button{top:0;right:0;border-radius:0 0 0 5px}.prev-button{top:calc(50% - 18px);left:0;border-radius:0 5px 5px 0}.next-button{top:calc(50% - 18px);right:0;border-radius:5px 0 0 5px}@media (max-width:600px){.auto-container{width:100vw;height:100vh;max-width:100vw;max-height:100vh}.auto-visibility{visibility:collapse}}lib-image-transition{touch-action:none}"]
                },] }
    ];
    LightboxOverlayComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef }
    ]; };
    LightboxOverlayComponent.propDecorators = {
        imageTransition: [{ type: core.ViewChild, args: [ImageTransitionComponent,] }],
        keyEvent: [{ type: core.HostListener, args: ['window:keyup', ['$event'],] }]
    };

    var LightboxComponent = /** @class */ (function () {
        function LightboxComponent(overlay) {
            this.overlay = overlay;
            this.imageUrls = new Array();
            this.forceFullscreen = false;
            this.forceShowNavButtons = false;
            this.imageSize = 'cover';
            this.autoPlay = false;
            this.autoPlayInterval = 5000;
            this.transitionDuration = 1000;
            this.transitionType = 'split';
            this.sizeX = 50.0;
            this.sizeY = 50.0;
            this.width = 0.5;
            this.intensity = 40.0;
        }
        LightboxComponent.prototype.ngOnInit = function () {
        };
        LightboxComponent.prototype.open = function (index) {
            var _this = this;
            if (index === void 0) { index = 0; }
            // Define settings of the overlay
            this.overlayRef = this.overlay.create({
                hasBackdrop: true,
                positionStrategy: this.overlay.position().global().centerHorizontally().centerVertically(),
                scrollStrategy: this.overlay.scrollStrategies.block()
            });
            // Listen to backdrop event for detaching the overlay
            this.overlayRef.backdropClick().subscribe({
                next: function () { var _a; (_a = _this.overlayRef) === null || _a === void 0 ? void 0 : _a.detach(); }
            });
            // Attach the LightboxOverlayComponent to the overlayRef instance
            var lightboxOverlayRef = this.overlayRef.attach(new portal.ComponentPortal(LightboxOverlayComponent));
            // Pass data to the LightboxOverlayComponent
            lightboxOverlayRef.instance.overlayRef = this.overlayRef;
            lightboxOverlayRef.instance.imageUrls = this.imageUrls;
            lightboxOverlayRef.instance.forceFullscreen = this.forceFullscreen;
            lightboxOverlayRef.instance.forceShowNavButtons = this.forceShowNavButtons;
            lightboxOverlayRef.instance.imageSize = this.imageSize;
            lightboxOverlayRef.instance.autoPlay = this.autoPlay;
            lightboxOverlayRef.instance.autoPlayInterval = this.autoPlayInterval;
            lightboxOverlayRef.instance.transitionDuration = this.transitionDuration;
            lightboxOverlayRef.instance.transitionType = this.transitionType;
            lightboxOverlayRef.instance.sizeX = this.sizeX;
            lightboxOverlayRef.instance.sizeY = this.sizeY;
            lightboxOverlayRef.instance.width = this.width;
            lightboxOverlayRef.instance.intensity = this.intensity;
            lightboxOverlayRef.instance.startIndex = index;
        };
        LightboxComponent.prototype.close = function () {
            var _a;
            (_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.detach();
        };
        return LightboxComponent;
    }());
    LightboxComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'lib-lightbox',
                    template: ''
                },] }
    ];
    LightboxComponent.ctorParameters = function () { return [
        { type: overlay.Overlay }
    ]; };
    LightboxComponent.propDecorators = {
        imageUrls: [{ type: core.Input }],
        forceFullscreen: [{ type: core.Input }],
        forceShowNavButtons: [{ type: core.Input }],
        imageSize: [{ type: core.Input }],
        autoPlay: [{ type: core.Input }],
        autoPlayInterval: [{ type: core.Input }],
        transitionDuration: [{ type: core.Input }],
        transitionType: [{ type: core.Input }],
        sizeX: [{ type: core.Input }],
        sizeY: [{ type: core.Input }],
        width: [{ type: core.Input }],
        intensity: [{ type: core.Input }]
    };

    var LightboxModule = /** @class */ (function () {
        function LightboxModule() {
        }
        return LightboxModule;
    }());
    LightboxModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [LightboxComponent, LightboxOverlayComponent],
                    imports: [
                        common.CommonModule,
                        ImageTransitionModule,
                        overlay.OverlayModule
                    ],
                    exports: [LightboxComponent],
                    entryComponents: [LightboxOverlayComponent]
                },] }
    ];

    var ObjectControls = /** @class */ (function () {
        function ObjectControls(rendererDom, object, touchArea) {
            var _this = this;
            // ============= Private Properties =============
            this.isUserInteracting = false;
            this.restoringAnimationOngoing = false;
            this.restoringOriginPosTimeout = 0;
            this.userInteracted = false;
            this.userInteractedSubject = new rxjs.Subject();
            // ============= Public Properties =============
            this.rotationSpeed = 1;
            this.verticalRotation = true;
            this.horizontalRotation = true;
            this.autoRotationY = false;
            this.autoRotationX = false;
            this.autoRotationZ = false;
            this.restoreOriginPosition = false;
            this.autoRotationSpeed = 0.002;
            this.userInteracted$ = this.userInteractedSubject.asObservable();
            this.controlsEnabled = true;
            /******************  MOUSE interaction functions - desktop  *****/
            /**
             * Prepares everything, when the mouse is clicked
             * @param e mouse event
             */
            this.mouseDown = function (e) {
                // Ignore mouse down interaction, if the controls are not enabled
                // Ignore mouse down interaction, if the restoration animation is ongoing
                if (_this.controlsEnabled === false || _this.restoringAnimationOngoing === true)
                    return;
                // Reset restoration animation timout
                window.clearTimeout(_this.restoringOriginPosTimeout);
                _this.isUserInteracting = true;
                _this.startDraggingPosition = new three.Vector2(0, 0);
                _this.startDraggingPosition.set(e.offsetX, e.offsetY);
                _this.touchArea.addEventListener('pointermove', _this.mouseMove, false);
                _this.touchArea.addEventListener('pointerup', _this.mouseUp, false);
            };
            /**
             * Calculates the x and y rotation of the object depending on the mouse movement
             * @param e MouseEvent
             */
            this.mouseMove = function (e) {
                // Ignore mouse movement interaction, if the controls are not enabled
                // Ignore mouse movement interaction, if the restoration animation is ongoing
                if (_this.controlsEnabled === false || _this.restoringAnimationOngoing)
                    return;
                if (_this.isUserInteracting) {
                    if (_this.userInteracted == false) {
                        _this.userInteracted = true;
                        _this.userInteractedSubject.next(_this.userInteracted);
                    }
                    var deltaMove = new three.Vector2(e.offsetX - _this.startDraggingPosition.x, e.offsetY - _this.startDraggingPosition.y);
                    _this.startDraggingPosition.set(e.offsetX, e.offsetY);
                    var rotationX = _this.verticalRotation == true ? (deltaMove.x * Math.PI / 180 * _this.rotationSpeed) : 0;
                    var rotationY = _this.horizontalRotation == true ? (deltaMove.y * Math.PI / 180 * _this.rotationSpeed) : 0;
                    var deltaRotationQuaternion = new three.Quaternion().setFromEuler(new three.Euler(rotationY, rotationX, 0, 'XYZ'));
                    _this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, _this.obj.quaternion);
                    //console.log(`rotX: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.x))}, rotY: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.y))}, rotZ: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.z))}`);
                }
            };
            this.mouseUp = function () {
                // Ignore mouse movement interaction, if the controls are not enabled
                // Ignore mouse up interaction, if the restoration animation is ongoing
                if (_this.controlsEnabled === false || _this.restoringAnimationOngoing)
                    return;
                _this.resetMousePosition();
                _this.isUserInteracting = false;
                if (_this.restoreOriginPosition)
                    _this.restoreOriginalPosition();
                _this.touchArea.removeEventListener('mousemove', _this.mouseMove, false);
                _this.touchArea.removeEventListener('mouseup', _this.mouseUp, false);
            };
            /****************** TOUCH interaction functions - mobile  *****/
            this.onTouchStart = function (e) {
                // Ignore mouse movement interaction, if the controls are not enabled
                // Ignore touch start interaction, if the restoration animation is ongoing
                if (_this.controlsEnabled === false || _this.restoringAnimationOngoing)
                    return;
                // Reset restoration animation timout
                window.clearTimeout(_this.restoringOriginPosTimeout);
                //e.preventDefault();
                _this.isUserInteracting = true;
                _this.restoringAnimationOngoing = false;
                _this.startDraggingPosition.set(e.touches[0].pageX, e.touches[0].pageY);
            };
            this.onTouchMove = function (e) {
                // Ignore mouse movement interaction, if the controls are not enabled
                // Ignore mouse move interaction, if the restoration animation is ongoing
                if (_this.controlsEnabled === false || _this.restoringAnimationOngoing)
                    return;
                //e.preventDefault();
                if (_this.isUserInteracting && !_this.restoringAnimationOngoing) {
                    if (_this.userInteracted == false) {
                        _this.userInteracted = true;
                        _this.userInteractedSubject.next(_this.userInteracted);
                    }
                    var deltaMove = new three.Vector2(e.touches[0].pageX - _this.startDraggingPosition.x, e.touches[0].pageY - _this.startDraggingPosition.y);
                    _this.startDraggingPosition.set(e.touches[0].pageX, e.touches[0].pageY);
                    var rotationX = _this.verticalRotation == true ? (deltaMove.x * Math.PI / 180 * _this.rotationSpeed) : 0;
                    var rotationY = _this.horizontalRotation == true ? (deltaMove.y * Math.PI / 180 * _this.rotationSpeed) : 0;
                    var deltaRotationQuaternion = new three.Quaternion().setFromEuler(new three.Euler(rotationY, rotationX, 0, 'XYZ'));
                    _this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, _this.obj.quaternion);
                }
            };
            this.onTouchEnd = function (e) {
                // Ignore mouse movement interaction, if the controls are not enabled
                // Ignore mouse up interaction, if the restoration animation is ongoing
                if (_this.controlsEnabled === false || _this.restoringAnimationOngoing)
                    return;
                //e.preventDefault();
                _this.isUserInteracting = false;
                _this.resetMousePosition();
                if (_this.restoreOriginPosition)
                    _this.restoreOriginalPosition();
            };
            this.rendererDom = rendererDom;
            this.obj = object;
            this.touchArea = touchArea != null ? touchArea : this.rendererDom;
            this.startDraggingPosition = new three.Vector2(0, 0);
            this.addEventlisteners();
        }
        // ============= Public Methods =============
        /**
         * Method, which needs to be called, in case autorotation is used
         */
        ObjectControls.prototype.update = function () {
            if (this.isUserInteracting || this.restoringAnimationOngoing || this.userInteracted)
                return;
            var rotationY = this.autoRotationY == true ? this.autoRotationSpeed : 0;
            var rotationX = this.autoRotationX == true ? this.autoRotationSpeed : 0;
            var rorationZ = this.autoRotationZ == true ? this.autoRotationSpeed : 0;
            var deltaRotationQuaternion = new three.Quaternion().setFromEuler(new three.Euler(rotationX, rotationY, rorationZ, 'XYZ'));
            this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
        };
        /**
         * Removes the event listners
         */
        ObjectControls.prototype.removeEventlisteners = function () {
            // desktop events
            this.touchArea.removeEventListener('mousedown', this.mouseDown, false);
            this.touchArea.removeEventListener('mousemove', this.mouseMove, false);
            this.touchArea.removeEventListener('mouseup', this.mouseUp, false);
            // mobile events
            this.touchArea.removeEventListener('touchstart', this.onTouchStart, false);
            this.touchArea.removeEventListener('touchmove', this.onTouchMove, false);
            this.touchArea.removeEventListener('touchend', this.onTouchEnd, false);
        };
        ObjectControls.prototype.resetUserInteractionFlag = function () {
            this.userInteracted = false,
                this.userInteractedSubject.next(this.userInteracted);
        };
        // ============= Private Methods =============
        /**
         * Adds the event listeners
         */
        ObjectControls.prototype.addEventlisteners = function () {
            // desktop events
            this.touchArea.addEventListener('mousedown', this.mouseDown, false);
            // mobile events
            this.touchArea.addEventListener('touchend', this.onTouchEnd, false);
            this.touchArea.addEventListener('touchstart', this.onTouchStart, false);
            this.touchArea.addEventListener('touchmove', this.onTouchMove, false);
        };
        /**
         * Reset the mouse position to x=0 and y=0
         */
        ObjectControls.prototype.resetMousePosition = function () {
            this.startDraggingPosition.set(0, 0);
        };
        /**
         * Rotates the object to the position 0,0,0 after a some timeout
         */
        ObjectControls.prototype.restoreOriginalPosition = function () {
            var _this = this;
            this.restoringOriginPosTimeout = window.setTimeout(function () {
                var objSet = new three.Object3D();
                objSet.position.set(0, 0, 0);
                objSet.rotation.set(0, 0, 0);
                RxjsTween.createTween(RxjsTween.linear, [_this.obj.position.x, _this.obj.position.y, _this.obj.position.z], [objSet.position.x, objSet.position.y, objSet.position.z], 1000).subscribe({
                    next: function (tweenVal) {
                        if (_this.restoringAnimationOngoing == false)
                            _this.restoringAnimationOngoing = true;
                        _this.obj.rotation.set(tweenVal[0], tweenVal[1], tweenVal[2]);
                    },
                    complete: function () {
                        _this.restoringAnimationOngoing = false;
                        _this.resetUserInteractionFlag();
                    }
                });
            }, 5000);
        };
        return ObjectControls;
    }());

    var CarouselItem = /** @class */ (function () {
        function CarouselItem(el) {
            this.el = el;
            this.htmlElement = this.el.nativeElement;
        }
        return CarouselItem;
    }());
    CarouselItem.decorators = [
        { type: core.Directive, args: [{
                    selector: "acuw-carousel-item",
                    host: {
                        'class': 'acuw-carousel-item',
                    }
                },] }
    ];
    CarouselItem.ctorParameters = function () { return [
        { type: core.ElementRef }
    ]; };
    var CarouselComponent = /** @class */ (function () {
        function CarouselComponent(ngZone, animationBuilder) {
            this.ngZone = ngZone;
            this.animationBuilder = animationBuilder;
            this.showDots = true;
            this.dotColor = '#fff';
            this.activeDotColor = '#3f51b5';
            this.dotAnimationCircleColor = '#fff';
            this.activeCarouselElement = 0;
            this.activeCarouselElementChange = new core.EventEmitter();
            this.initAnimation = true;
            this.radius = 200;
            this.yPosition = 0;
            this.cameraFov = 65;
            this.cameraDistance = 600;
            this.autoPlay = false;
            this.autoPlayInterval = 5000;
            this.rotationDuration = 500;
            this.css3dRenderer = new CSS3DRenderer.CSS3DRenderer();
            this.scene = new three.Scene();
            this.carouselGroup = new three.Group();
            this.carouselObjSubsciptions = new Array();
            this.rotationSubscription = new rxjs.Subscription();
            this.animation = true;
            this.userMove = false;
        }
        CarouselComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // Init camera
            this.camera = new three.PerspectiveCamera(this.cameraFov, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.set(0.0, 0.0, this.cameraDistance);
            // Get the with and heigth of the threejs renderer
            var divWidth = this.threejsContainer.nativeElement.clientWidth;
            var divHeight = this.threejsContainer.nativeElement.clientHeight;
            // Create CSS3D Renderer
            this.css3dRenderer = new CSS3DRenderer.CSS3DRenderer();
            this.css3dRenderer.setSize(divWidth, divHeight);
            this.css3dRenderer.domElement.style.position = 'absolute';
            this.css3dRenderer.domElement.style.top = '0';
            this.threejsContainer.nativeElement.appendChild(this.css3dRenderer.domElement);
            // Init carousel elements
            this.initCarouselObjects();
            // Object-Controls
            this.objectControls = new ObjectControls(this.css3dRenderer.domElement, this.carouselGroup, this.threejsContainer.nativeElement);
            this.objectControls.userInteracted$.subscribe({
                next: function (val) {
                    _this.userMove = val;
                    // Cancel the rotation, if running
                    _this.rotationSubscription.unsubscribe();
                }
            });
            // Initialize the animation of the inidcation dots
            if (this.autoPlay) {
                this.startDotAnimation(this.activeCarouselElement);
            }
            // Animate
            this.animate();
        };
        CarouselComponent.prototype.ngOnChanges = function (changes) {
            var change = changes['activeCarouselElement'];
            if (change && !change.firstChange && this.carouselGroup) {
                //console.log(`activeCarouselElement change | previousValue=${change.previousValue} | newValue=${change.currentValue} |
                //activeCarouselElement=${this.activeCarouselElement}`);
                if (change.currentValue !== this.activeCarouselElement) {
                    //console.log('rotate to ' + change.currentValue);
                    this.rotateTo(change.currentValue);
                }
            }
            change = changes['radius'];
            if (change && !change.firstChange && this.carouselGroup) {
                this.updateRadius();
            }
            change = changes['cameraFov'];
            if (change && !change.firstChange && this.camera) {
                this.camera.fov = this.cameraFov;
                this.camera.updateProjectionMatrix();
            }
            change = changes['cameraDistance'];
            if (change && !change.firstChange && this.camera) {
                this.camera.position.set(0, 0, this.cameraDistance);
                this.camera.updateProjectionMatrix();
            }
            change = changes['autoPlay'];
            if (change && this.carouselGroup) {
                if (change.currentValue === true) {
                    this.startDotAnimation(this.activeCarouselElement);
                }
                else {
                    this.resetDotAnimation();
                }
            }
        };
        CarouselComponent.prototype.ngOnDestroy = function () {
            // Cancel Animation
            cancelAnimationFrame(this.animationFrameId);
            // Unsubscribe Subscriptions
            this.rotationSubscription.unsubscribe();
            // Remove threejs container from DOM
            this.threejsContainer.nativeElement.removeChild(this.css3dRenderer.domElement);
            // Clear scene
            this.scene.clear();
        };
        /**
         * Resizes the canvas and updates the texture resulution information of the images
         */
        CarouselComponent.prototype.resize = function () {
            // Get width and heigh of the threejs dom element after window resize
            var divWidth = this.threejsContainer.nativeElement.clientWidth;
            var divHeight = this.threejsContainer.nativeElement.clientHeight;
            // Define aspect ratio
            this.camera.aspect = divWidth / divHeight;
            this.camera.updateProjectionMatrix();
            //this.renderer.setSize(divWidth, divHeight);
            this.css3dRenderer.setSize(divWidth, divHeight);
        };
        /**
         * Animation
         */
        CarouselComponent.prototype.animate = function () {
            var _this = this;
            if (this.animation == true) {
                this.css3dRenderer.render(this.scene, this.camera);
            }
            this.ngZone.runOutsideAngular(function () {
                _this.animationFrameId = window.requestAnimationFrame(function () { return _this.animate(); });
            });
        };
        /**
         * starts the animation of the indication dots
         * @param index index number for which dot the animation should be started
         * @returns
         */
        CarouselComponent.prototype.startDotAnimation = function (index) {
            var _this = this;
            if (this.dotAnimationPlayer || !this.dots) {
                // Animation is already ongoing
                return;
            }
            // Define the animation
            var autoPlayAnimation = this.animationBuilder.build([
                animations.style({ strokeDasharray: '0,250.2', visibility: 'visible' }),
                animations.animate(this.autoPlayInterval, animations.style({ strokeDasharray: '250.2,250.2' }))
            ]);
            // Get the element for, which the animation should be applied
            var path = this.dots.nativeElement.children[index].getElementsByTagName('path')[0];
            this.dotAnimationPlayer = autoPlayAnimation.create(path);
            // Start the animation
            this.dotAnimationPlayer.play();
            // Switch to the next carousel, as soon as the animation is finished
            this.dotAnimationPlayer.onDone(function () {
                _this.dotAnimationPlayer = null;
                _this.next();
            });
        };
        /**
         * Resets the dot animation
         */
        CarouselComponent.prototype.resetDotAnimation = function () {
            if (this.dotAnimationPlayer && this.dotAnimationPlayer.hasStarted()) {
                this.dotAnimationPlayer.reset();
                this.dotAnimationPlayer = null;
            }
        };
        /**
         * Initialize the carousel objects
         */
        CarouselComponent.prototype.initCarouselObjects = function (animation) {
            var _this = this;
            if (animation === void 0) { animation = true; }
            var _a;
            this.carouselElements = new Array();
            for (var idx = 0; idx < this.carouselItemTemplates.length; idx++) {
                var copiedElement = ((_a = this.carouselItemTemplates.get(idx)) === null || _a === void 0 ? void 0 : _a.htmlElement);
                if (copiedElement) {
                    var object = new CSS3DRenderer.CSS3DObject(copiedElement);
                    object.element.style.pointerEvents = 'none';
                    // Add element to global variable
                    this.carouselElements.push(object);
                    // Create subscription for tween animation
                    this.carouselObjSubsciptions.push(new rxjs.Subscription());
                }
            }
            // Clear the carousel group
            this.carouselGroup.clear();
            var yOrientation = -((this.activeCarouselElement) * Math.PI * 2 / this.carouselElements.length);
            this.carouselGroup.rotation.set(0, yOrientation, 0);
            var index = 0;
            var elementsCnt = this.carouselElements.length;
            this.carouselElements.forEach(function (obj) {
                // Unsubscribe previously subscription
                _this.carouselObjSubsciptions[index].unsubscribe();
                // Define final position
                var tweenObj = new three.Object3D();
                var theta = index * 2 * (Math.PI / elementsCnt);
                tweenObj.position.setFromCylindricalCoords(_this.radius, theta, _this.yPosition);
                var vector = new three.Vector3(tweenObj.position.x * 2, tweenObj.position.y, tweenObj.position.z * 2);
                tweenObj.lookAt(vector);
                // Set roattion
                obj.rotation.x = tweenObj.rotation.x;
                obj.rotation.y = tweenObj.rotation.y;
                obj.rotation.z = tweenObj.rotation.z;
                if (_this.initAnimation === true && animation === true) {
                    // Set random position
                    obj.position.x = Math.random() * 2000 - 1000;
                    obj.position.y = Math.random() * 500;
                    obj.position.z = Math.random() * 500;
                    // Add the objects to the portfolio group
                    _this.carouselGroup.add(obj);
                    // Tween to final position
                    _this.ngZone.runOutsideAngular(function () {
                        _this.carouselObjSubsciptions[index] = RxjsTween.createTween(RxjsTween.easeInOutQuad, [obj.position.x, obj.position.y, obj.position.z], [tweenObj.position.x, tweenObj.position.y, tweenObj.position.z], 2000).subscribe({
                            next: function (tweenPos) {
                                obj.position.set(tweenPos[0], tweenPos[1], tweenPos[2]);
                            }
                        });
                    });
                }
                else {
                    obj.position.x = tweenObj.position.x;
                    obj.position.y = tweenObj.position.y;
                    obj.position.z = tweenObj.position.z;
                    // Add the objects to the portfolio group
                    _this.carouselGroup.add(obj);
                }
                index = index + 1;
            });
            //add the group to the scene
            this.scene.add(this.carouselGroup);
        };
        /**
         * Rotate to next carousel item
         */
        CarouselComponent.prototype.next = function () {
            var nextElement = this.activeCarouselElement >= this.carouselElements.length - 1 ? 0 : this.activeCarouselElement + 1;
            this.resetDotAnimation();
            this.rotateTo(nextElement);
        };
        /**
         * Rotate to previous carousel item
         */
        CarouselComponent.prototype.previous = function () {
            var nextElement = this.activeCarouselElement == 0 ? this.carouselElements.length - 1 : this.activeCarouselElement - 1;
            this.resetDotAnimation();
            this.rotateTo(nextElement);
        };
        /**
         * Rotates to a sepcific carousel item
         * @param targetIndex index of the carousel item
         */
        CarouselComponent.prototype.rotateTo = function (targetIndex) {
            var _this = this;
            if (targetIndex > this.carouselElements.length - 1) {
                console.error('target index is greater than available carousel items');
                return;
            }
            if (targetIndex > this.activeCarouselElement) {
                // In case the current elment is the first again, reset the orientation
                if (this.activeCarouselElement == 0 && (this.carouselGroup.rotation.y != 0
                    && this.carouselGroup.rotation.x == 0 && this.carouselGroup.rotation.z == 0)) {
                    this.carouselGroup.rotation.set(0, 0, 0);
                }
            }
            else if (targetIndex == this.carouselElements.length - 1) {
                // Set position of the first element to y = -2*PI
                if (this.activeCarouselElement == 0 && (this.carouselGroup.rotation.y == 0
                    && this.carouselGroup.rotation.x == 0 && this.carouselGroup.rotation.z == 0)) {
                    this.carouselGroup.rotation.set(0, -2 * Math.PI, 0);
                }
            }
            var startQuaternion = this.carouselGroup.quaternion.clone();
            // Calculate the orientation of the target item
            var yOrientation = -((targetIndex) * Math.PI * 2 / this.carouselElements.length);
            var targetQuaternion = new three.Quaternion().setFromEuler(new three.Euler(0, yOrientation, 0, 'XYZ'));
            this.rotationSubscription.unsubscribe();
            // Run rotation animation outsie zgZone
            this.ngZone.runOutsideAngular(function () {
                _this.rotationSubscription = RxjsTween.createTween(RxjsTween.easeInOutQuad, 0, 1, _this.rotationDuration).subscribe({
                    next: function (x) {
                        three.Quaternion.slerp(startQuaternion, targetQuaternion, _this.carouselGroup.quaternion, x);
                    },
                    complete: function () {
                        three.Quaternion.slerp(startQuaternion, targetQuaternion, _this.carouselGroup.quaternion, 1);
                        _this.ngZone.run(function () {
                            _this.activeCarouselElement = targetIndex;
                            _this.activeCarouselElementChange.emit(_this.activeCarouselElement);
                            _this.objectControls.resetUserInteractionFlag();
                            if (_this.autoPlay) {
                                _this.startDotAnimation(_this.activeCarouselElement);
                            }
                        });
                    }
                });
            });
        };
        /**
         * Updates and reinits the carousel items
         */
        CarouselComponent.prototype.updateCarouselItems = function () {
            this.initCarouselObjects(false);
        };
        /**
         * Updates the radius of the carousel items
         */
        CarouselComponent.prototype.updateRadius = function () {
            for (var idx = 0; idx < this.carouselGroup.children.length; idx++) {
                var theta = idx * 2 * (Math.PI / this.carouselGroup.children.length);
                this.carouselGroup.children[idx].position.setFromCylindricalCoords(this.radius, theta, this.yPosition);
            }
        };
        return CarouselComponent;
    }());
    CarouselComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'acuw-carousel',
                    template: "\n    <div class=\"carousel-container\">\n      <div #threejsContainer class=\"threejs-container\"></div>\n      <!-- dots -->\n      <div #indicationDots class=\"dots\">\n      <svg *ngFor=\"let carouselTemplate of carouselItemTemplates; index as i\" viewBox=\"0 0 100 100\">\n          <circle cx=\"50\" cy=\"50\" r=\"45\" [ngStyle]=\"{'fill': activeCarouselElement===i ? activeDotColor : dotColor}\"/>\n          <path id=\"{{i}}\" fill=\"none\" stroke-linecap=\"round\" stroke-width=\"20\" \n          [ngStyle]=\"{'stroke': dotAnimationCircleColor, 'visibility': activeCarouselElement===i && autoPlay ? 'visible' : 'hidden'}\"\n                d=\"M50 10 a 40 40 0 0 1 0 80 a 40 40 0 0 1 0 -80\"/>\n        </svg>\n      </div>\n    </div>\n    \n  ",
                    animations: [
                        animations.trigger('dotsAnimation', [
                            animations.transition(':enter', [
                                animations.query('svg', [
                                    animations.style({ opacity: 0, transform: 'translateY(200%)' }),
                                    animations.stagger(100, [
                                        animations.animate('300ms ease-in', animations.style({ opacity: 1, transform: 'none' }))
                                    ])
                                ], { optional: true })
                            ]),
                            animations.transition(':leave', [
                                animations.query('svg', [
                                    animations.stagger(100, [
                                        animations.animate('300ms ease-in', animations.style({ opacity: 0, transform: 'translateY(200%)' }))
                                    ])
                                ], { optional: true })
                            ])
                        ]),
                        animations.trigger('autoPlayAnimation', [
                            animations.state('false', animations.style({ strokeDasharray: '0,250.2' })),
                            animations.state('true', animations.style({ strokeDasharray: '250.2,250.2' })),
                            animations.transition('false => true', animations.animate(5000))
                        ])
                    ],
                    styles: [".carousel-container,.threejs-container{position:relative;width:100%;height:100%;background-color:inherit}.threejs-container{align-items:center}.dots,.threejs-container{display:flex;justify-content:center}.dots{position:absolute;bottom:0;flex-direction:row;flex-wrap:wrap;width:100%;overflow:hidden}.dots svg{width:28px;height:28px;margin:0 5px 24px}", "\n  "]
                },] }
    ];
    CarouselComponent.ctorParameters = function () { return [
        { type: core.NgZone },
        { type: animations.AnimationBuilder }
    ]; };
    CarouselComponent.propDecorators = {
        showDots: [{ type: core.Input }],
        dotColor: [{ type: core.Input }],
        activeDotColor: [{ type: core.Input }],
        dotAnimationCircleColor: [{ type: core.Input }],
        activeCarouselElement: [{ type: core.Input }],
        activeCarouselElementChange: [{ type: core.Output }],
        initAnimation: [{ type: core.Input }],
        radius: [{ type: core.Input }],
        yPosition: [{ type: core.Input }],
        cameraFov: [{ type: core.Input }],
        cameraDistance: [{ type: core.Input }],
        autoPlay: [{ type: core.Input }],
        autoPlayInterval: [{ type: core.Input }],
        rotationDuration: [{ type: core.Input }],
        threejsContainer: [{ type: core.ViewChild, args: ['threejsContainer',] }],
        dots: [{ type: core.ViewChild, args: ['indicationDots',] }],
        carouselItemTemplates: [{ type: core.ContentChildren, args: [CarouselItem,] }],
        resize: [{ type: core.HostListener, args: ['window:resize',] }]
    };

    var CarouselModule = /** @class */ (function () {
        function CarouselModule() {
        }
        return CarouselModule;
    }());
    CarouselModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [CarouselComponent, CarouselItem],
                    imports: [
                        common.CommonModule
                    ],
                    exports: [CarouselComponent, CarouselItem]
                },] }
    ];

    /*
     * Public API Surface of ngx-acuw
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CarouselComponent = CarouselComponent;
    exports.CarouselItem = CarouselItem;
    exports.CarouselModule = CarouselModule;
    exports.ImageAsParticlesComponent = ImageAsParticlesComponent;
    exports.ImageAsParticlesModule = ImageAsParticlesModule;
    exports.ImageTransitionComponent = ImageTransitionComponent;
    exports.ImageTransitionModule = ImageTransitionModule;
    exports.LightboxComponent = LightboxComponent;
    exports.LightboxModule = LightboxModule;
    exports.a = LightboxOverlayComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-acuw.umd.js.map
