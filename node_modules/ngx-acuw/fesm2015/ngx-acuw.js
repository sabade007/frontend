import { Component, NgZone, Input, ViewChild, HostListener, NgModule, EventEmitter, Output, ChangeDetectorRef, Directive, ElementRef, ContentChildren } from '@angular/core';
import { Texture, WebGLRenderer, Scene, Clock, Vector2, Raycaster, PerspectiveCamera, TextureLoader, LinearFilter, RGBFormat, RawShaderMaterial, InstancedBufferGeometry, BufferAttribute, InstancedBufferAttribute, Mesh, Object3D, PlaneGeometry, MeshBasicMaterial, PlaneBufferGeometry, ShaderMaterial, DoubleSide, Vector4, Quaternion, Euler, Group, Vector3 } from 'three';
import { Observable, interval, Subscription, Subject } from 'rxjs';
import { trigger, transition, style, animate, query, stagger, state, AnimationBuilder } from '@angular/animations';
import { CommonModule } from '@angular/common';
import { Overlay, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { CSS3DRenderer, CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer';

class TouchTexture {
    constructor() {
        this.size = 64;
        this.maxAge = 120;
        this.radius = 0.15;
        this.trail = new Array();
        this.initTexture();
    }
    /**
     * Initializes the texture for the touch area
     */
    initTexture() {
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.canvas.height = this.size;
        this.ctx = this.canvas.getContext('2d');
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.texture = new Texture(this.canvas);
        this.canvas.id = 'touchTexture';
        this.canvas.style.width = this.canvas.style.height = `${this.canvas.width}px`;
    }
    /**
     * Updates the trail
     */
    update() {
        this.clear();
        // age points
        this.trail.forEach((point, i) => {
            point.age++;
            // remove old
            if (point.age > this.maxAge) {
                this.trail.splice(i, 1);
            }
        });
        this.trail.forEach((point, i) => {
            this.drawTouch(point);
        });
        this.texture.needsUpdate = true;
    }
    clear() {
        this.ctx.fillStyle = 'black';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    addTouch(px, py) {
        let force = 0;
        const last = this.trail[this.trail.length - 1];
        if (last) {
            const dx = last.x - px;
            const dy = last.y - py;
            const dd = dx * dx + dy * dy;
            force = Math.min(dd * 10000, 1);
        }
        this.trail.push({ x: px, y: py, age: 0, force });
    }
    drawTouch(point) {
        const pos = {
            x: point.x * this.size,
            y: (1 - point.y) * this.size
        };
        let intensity = 1;
        if (point.age < this.maxAge * 0.3) {
            intensity = this.easeOutSine(point.age / (this.maxAge * 0.3), 0, 1, 1);
        }
        else {
            intensity = this.easeOutSine(1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7), 0, 1, 1);
        }
        intensity *= point.force;
        const radius = this.size * this.radius * intensity;
        const grd = this.ctx.createRadialGradient(pos.x, pos.y, radius * 0.25, pos.x, pos.y, radius);
        grd.addColorStop(0, `rgba(255, 255, 255, 0.2)`);
        grd.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
        this.ctx.beginPath();
        this.ctx.fillStyle = grd;
        this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        this.ctx.fill();
    }
    easeOutSine(t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }
}

class Shaders {
    constructor() {
        this.particleVertex = `
    // @author brunoimbrizi / http://brunoimbrizi.com

    precision highp float;
    #define GLSLIFY 1

    attribute float pindex;
    attribute vec3 position;
    attribute vec3 offset;
    attribute vec2 uv;
    attribute float angle;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    uniform float uTime;
    uniform float uRandom;
    uniform float uDepth;
    uniform float uSize;
    uniform vec2 uTextureSize;
    uniform sampler2D uTexture;
    uniform sampler2D uTouch;

    varying vec2 vPUv;
    varying vec2 vUv;

    //
    // Description : Array and textureless GLSL 2D simplex noise function.
    //      Author : Ian McEwan, Ashima Arts.
    //  Maintainer : ijm
    //     Lastmod : 20110822 (ijm)
    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
    //               Distributed under the MIT License. See LICENSE file.
    //               https://github.com/ashima/webgl-noise
    //

    vec3 mod289_1_0(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec2 mod289_1_0(vec2 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec3 permute_1_1(vec3 x) {
      return mod289_1_0(((x*34.0)+1.0)*x);
    }

    float snoise_1_2(vec2 v)
      {
      const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                          0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                         -0.577350269189626,  // -1.0 + 2.0 * C.x
                          0.024390243902439); // 1.0 / 41.0
    // First corner
      vec2 i  = floor(v + dot(v, C.yy) );
      vec2 x0 = v -   i + dot(i, C.xx);

    // Other corners
      vec2 i1;
      //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
      //i1.y = 1.0 - i1.x;
      i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      // x0 = x0 - 0.0 + 0.0 * C.xx ;
      // x1 = x0 - i1 + 1.0 * C.xx ;
      // x2 = x0 - 1.0 + 2.0 * C.xx ;
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;

     // Permutations
      i = mod289_1_0(i); // Avoid truncation effects in permutation
      vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));

      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m ;
      m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
      m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
      vec3 g;
      g.x  = a0.x  * x0.x  + h.x  * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    float random(float n) {
      return fract(sin(n) * 43758.5453123);
    }

    void main() {
      vUv = uv;

      // particle uv
      vec2 puv = offset.xy / uTextureSize;
      vPUv = puv;

      // pixel color
      vec4 colA = texture2D(uTexture, puv);
      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;

      // displacement
      vec3 displaced = offset;
      // randomise
      displaced.xy += vec2(random(pindex) - 0.5, random(offset.x + pindex) - 0.5) * uRandom;
      float rndz = (random(pindex) + snoise_1_2(vec2(pindex * 0.1, uTime * 0.1)));
      displaced.z += rndz * (random(pindex) * 2.0 * uDepth);
      // center
      displaced.xy -= uTextureSize * 0.5;

      // touch
      float t = texture2D(uTouch, puv).r;
      displaced.z += t * 20.0 * rndz;
      displaced.x += cos(angle) * t * 20.0 * rndz;
      displaced.y += sin(angle) * t * 20.0 * rndz;

      // particle size
      float psize = (snoise_1_2(vec2(uTime, pindex) * 0.5) + 2.0);
      psize *= max(grey, 0.2);
      psize *= uSize;

      // final position
      vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);
      mvPosition.xyz += position * psize;
      vec4 finalPosition = projectionMatrix * mvPosition;

      gl_Position = finalPosition;
    }
    `;
        this.particleFragment = `
    // @author brunoimbrizi / http://brunoimbrizi.com

    precision highp float;
    #define GLSLIFY 1

    uniform sampler2D uTexture;

    varying vec2 vPUv;
    varying vec2 vUv;

    void main() {
      vec4 color = vec4(0.0);
      vec2 uv = vUv;
      vec2 puv = vPUv;

      // pixel color
      vec4 colA = texture2D(uTexture, puv);

      // greyscale
      float grey = colA.r * 0.21 + colA.g * 0.71 + colA.b * 0.07;
      //vec4 colB = vec4(grey, grey, grey, 1.0);
      vec4 colB = vec4(colA.r, colA.g, colA.b, 1.0);

      // circle
      float border = 0.3;
      float radius = 0.5;
      float dist = radius - distance(uv, vec2(0.5));
      float t = smoothstep(0.0, border, dist);

      // final color
      color = colB;
      color.a = t;

      gl_FragColor = color;
    }
    `;
    }
}

var RxjsTween;
(function (RxjsTween) {
    function createTween(easingFunction, b, c, d, s) {
        return new Observable((observer) => {
            let startTime;
            const sample = (time) => {
                startTime = startTime || time;
                const t = time - startTime;
                if (t < d) {
                    if (Array.isArray(b) && Array.isArray(c)) {
                        const tweenVals = new Array();
                        for (let idx = 0; idx < b.length; idx++) {
                            tweenVals.push(easingFunction(t, b[idx], c[idx], d, s));
                        }
                        observer.next(tweenVals);
                    }
                    else {
                        observer.next(easingFunction(t, b, c, d, s));
                    }
                    // Request the animation frame again
                    requestAnimationFrame(sample);
                }
                else {
                    // End value reached
                    if (Array.isArray(b) && Array.isArray(c)) {
                        const tweenVals = new Array();
                        for (let idx = 0; idx < b.length; idx++) {
                            tweenVals.push(c[idx]);
                        }
                        // Emitt end value of arry
                        observer.next(tweenVals);
                    }
                    else {
                        // Emitt end value
                        observer.next(c);
                    }
                    // Complete the observable
                    observer.complete();
                }
            };
            // Initially request the animation frame
            requestAnimationFrame(sample);
        });
    }
    RxjsTween.createTween = createTween;
    function linear(t, b, pc, d) {
        const c = pc - b;
        return c * t / d + b;
    }
    RxjsTween.linear = linear;
    function easeInOutQuad(t, b, pc, d) {
        const c = pc - b;
        if ((t /= d / 2) < 1) {
            return c / 2 * t * t + b;
        }
        else {
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        }
    }
    RxjsTween.easeInOutQuad = easeInOutQuad;
})(RxjsTween || (RxjsTween = {}));

class ImageAsParticlesComponent {
    constructor(ngZone) {
        this.ngZone = ngZone;
        // Declare variables
        this.renderer = new WebGLRenderer({ antialias: true, alpha: true });
        this.scene = new Scene();
        this.clock = new Clock(true);
        this.texture = new Texture();
        this.width = 0;
        this.height = 0;
        this.touch = new TouchTexture();
        this.mouse = new Vector2();
        this.raycaster = new Raycaster();
        this.pImageUrl = '';
        this.pImageChanging = false;
        this.gestureInfo$ = interval(2000);
        this.gestureInfoSubscription = new Subscription();
        this.showTouchGestureInfo = false;
        this.justifyContent = 'center';
        this.alignItems = 'center';
        this.backgroundColor = '#000000';
        this.imageWidth = '100%';
        this.imageHeight = '100%';
        this.animationEnabled = true;
    }
    // Inputs
    set imageUrl(imageUrl) {
        this.pImageUrl = imageUrl;
        if (this.pImageChanging === true) {
            return;
        }
        if (this.mesh != null) {
            this.pImageChanging = true;
            this.triggerImageChange();
        }
    }
    get imageUrl() { return this.pImageUrl; }
    set horizontalAlignment(horizontalAlignment) {
        switch (horizontalAlignment) {
            case 'start':
                this.justifyContent = 'flex-start';
                break;
            case 'center':
                this.justifyContent = 'center';
                break;
            case 'end':
                this.justifyContent = 'flex-end';
                break;
            default:
                this.justifyContent = 'center';
                break;
        }
    }
    get horizontalAlignment() { return this.justifyContent; }
    set verticalAlignment(verticalAlignment) {
        switch (verticalAlignment) {
            case 'top':
                this.alignItems = 'flex-start';
                break;
            case 'center':
                this.alignItems = 'center';
                break;
            case 'bottom':
                this.alignItems = 'flex-end';
                break;
            default:
                this.alignItems = 'center';
                break;
        }
    }
    get verticalAlignment() { return this.alignItems; }
    ngAfterViewInit() {
        if (this.pImageUrl === '') {
            return;
        }
        const canvasWidth = this.canvasRef.nativeElement.clientWidth;
        const canvasHeight = this.canvasRef.nativeElement.clientHeight;
        // Set camera
        this.camera = new PerspectiveCamera(50, canvasWidth / canvasHeight, 1, 10000);
        this.camera.position.z = 300;
        // Init particles
        this.initParticles(this.pImageUrl);
        // Init renderer
        this.renderer.setSize(canvasWidth - 1, canvasHeight);
        this.canvasRef.nativeElement.appendChild(this.renderer.domElement);
        // Start animation
        this.animate();
    }
    ngOnDestroy() {
        this.scene.clear();
        this.renderer.clear();
        this.texture.dispose();
        this.renderer.dispose();
    }
    /**
     * Creates the particles depending on the image and initializes the touch canvas
     * @param url url of the image
     */
    initParticles(url) {
        const loader = new TextureLoader();
        loader.load(url, (texture) => {
            this.texture = texture;
            this.texture.minFilter = LinearFilter;
            this.texture.magFilter = LinearFilter;
            this.texture.format = RGBFormat;
            this.width = texture.image.width;
            this.height = texture.image.height;
            this.initPoints(true);
            this.initHitArea();
            this.initTouch();
            this.resize();
            this.show();
        });
    }
    /**
     * Initializes the points
     * @param discard discard pixels darker than threshold #22
     */
    initPoints(discard) {
        const numPoints = this.width * this.height;
        let numVisible = numPoints;
        let threshold = 0;
        let originalColors = new Float32Array();
        if (discard) {
            // discard pixels darker than threshold #22
            numVisible = 0;
            threshold = 34;
            const img = this.texture.image;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = this.width;
            canvas.height = this.height;
            if (ctx != null) {
                ctx.scale(1, -1);
                ctx.drawImage(img, 0, 0, this.width, this.height * -1);
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                originalColors = Float32Array.from(imgData.data);
                for (let i = 0; i < numPoints; i++) {
                    if (originalColors[i * 4 + 0] > threshold) {
                        numVisible++;
                    }
                }
            }
        }
        const uniforms = {
            uTime: { value: 0 },
            uRandom: { value: 1.0 },
            uDepth: { value: 2.0 },
            uSize: { value: 0.0 },
            uTextureSize: { value: new Vector2(this.width, this.height) },
            uTexture: { value: this.texture },
            uTouch: { value: null },
        };
        const shaders = new Shaders();
        const material = new RawShaderMaterial({
            uniforms,
            vertexShader: shaders.particleVertex,
            fragmentShader: shaders.particleFragment,
            depthTest: false,
            transparent: true,
            // blending: THREE.AdditiveBlending
        });
        const geometry = new InstancedBufferGeometry();
        // positions
        const positions = new BufferAttribute(new Float32Array(4 * 3), 3);
        positions.setXYZ(0, -0.5, 0.5, 0.0);
        positions.setXYZ(1, 0.5, 0.5, 0.0);
        positions.setXYZ(2, -0.5, -0.5, 0.0);
        positions.setXYZ(3, 0.5, -0.5, 0.0);
        geometry.setAttribute('position', positions);
        // uvs
        const uvs = new BufferAttribute(new Float32Array(4 * 2), 2);
        uvs.setXY(0, 0.0, 0.0);
        uvs.setXY(1, 1.0, 0.0);
        uvs.setXY(2, 0.0, 1.0);
        uvs.setXY(3, 1.0, 1.0);
        geometry.setAttribute('uv', uvs);
        // index
        geometry.setIndex(new BufferAttribute(new Uint16Array([0, 2, 1, 2, 3, 1]), 1));
        const indices = new Uint16Array(numVisible);
        const offsets = new Float32Array(numVisible * 3);
        const angles = new Float32Array(numVisible);
        for (let i = 0, j = 0; i < numPoints; i++) {
            if (discard && originalColors[i * 4 + 0] <= threshold) {
                continue;
            }
            offsets[j * 3 + 0] = i % this.width;
            offsets[j * 3 + 1] = Math.floor(i / this.width);
            indices[j] = i;
            angles[j] = Math.random() * Math.PI;
            j++;
        }
        geometry.setAttribute('pindex', new InstancedBufferAttribute(indices, 1, false));
        geometry.setAttribute('offset', new InstancedBufferAttribute(offsets, 3, false));
        geometry.setAttribute('angle', new InstancedBufferAttribute(angles, 1, false));
        this.mesh = new Mesh(geometry, material);
        const object3d = new Object3D();
        object3d.add(this.mesh);
        this.scene.add(object3d);
    }
    /**
     * Initializes the touch area
     */
    initTouch() {
        this.mesh.material.uniforms.uTouch.value = this.touch.texture;
    }
    /**
     * Initializes the hit area
     */
    initHitArea() {
        const geometry = new PlaneGeometry(this.width, this.height, 1, 1);
        const material = new MeshBasicMaterial({ color: 0xFFFFFF, wireframe: true, depthTest: false });
        material.visible = false;
        this.hitArea = new Mesh(geometry, material);
        this.mesh.add(this.hitArea);
    }
    /**
     * animation for showing the particles
     * @param time time of animation in ms
     */
    show(time = 1000) {
        // Tween in
        this.ngZone.runOutsideAngular(() => {
            RxjsTween.createTween(RxjsTween.easeInOutQuad, [0.5, 0.0, 70.0], [1.5, 2.0, 4.0], time).subscribe(val => {
                this.mesh.material.uniforms.uSize.value = val[0];
                this.mesh.material.uniforms.uRandom.value = val[1];
                this.mesh.material.uniforms.uDepth.value = val[2];
            }, () => { }, () => {
                this.pImageChanging = false;
            });
        });
    }
    /**
     * animation for tween out the particles and destroy everything
     * @param time time of animation in ms
     */
    triggerImageChange(time = 1000) {
        const uSizeStart = this.mesh.material.uniforms.uSize.value;
        const uRandomStart = this.mesh.material.uniforms.uRandom.value;
        const uDepth = this.mesh.material.uniforms.uDepth.value;
        this.ngZone.runOutsideAngular(() => {
            // Tween out
            RxjsTween.createTween(RxjsTween.easeInOutQuad, [uSizeStart, uRandomStart, uDepth], [0.0, 5.0, -20.0], time).subscribe(val => {
                this.mesh.material.uniforms.uSize.value = val[0];
                this.mesh.material.uniforms.uRandom.value = val[1];
                this.mesh.material.uniforms.uDepth.value = val[2];
            }, () => { }, () => {
                if (this.mesh != null) {
                    if (this.mesh.parent != null) {
                        this.mesh.parent.remove(this.mesh);
                    }
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
                if (this.hitArea != null) {
                    if (this.hitArea.parent != null) {
                        this.hitArea.parent.remove(this.hitArea);
                    }
                    this.hitArea.geometry.dispose();
                    this.hitArea.material.dispose();
                }
                this.initParticles(this.pImageUrl);
                this.pImageChanging = false;
            });
        });
    }
    /**
     * Method for triggering the animation
     */
    animate() {
        this.ngZone.runOutsideAngular(() => {
            window.requestAnimationFrame(() => this.animate());
            if (this.animationEnabled === true) {
                const delta = this.clock.getDelta();
                if (this.mesh != null) {
                    if (this.touch) {
                        this.touch.update();
                    }
                    this.mesh.material.uniforms.uTime.value += delta;
                }
                this.renderer.render(this.scene, this.camera);
            }
        });
    }
    /**
     * Handle mouse move event
     * @param event mouse event
     */
    onMouseMove(event) {
        // getBoundingClientRect retruns the distance in pixels of the top left corner of the element
        // to the top left corner of the viewport
        const domRect = this.canvasRef.nativeElement.getBoundingClientRect();
        // get the offset distance between the canvas, which contains the particles, to the outer container element
        const canvasEl = this.canvasRef.nativeElement.children[0];
        // Calculate the relative mouse position
        this.mouse.x = (event.clientX - domRect.left - canvasEl.offsetLeft) / canvasEl.clientWidth * 2 - 1;
        this.mouse.y = -(event.clientY - domRect.top - canvasEl.offsetTop) / canvasEl.clientHeight * 2 + 1;
        // console.info('raw: x= ' + event.clientX + ' , y= ' + event.clientY);
        // console.info('normalized: x= ' + this.mouse.x + ' , y= ' + this.mouse.y);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        if (this.hitArea === undefined) {
            return;
        }
        const intersects = this.raycaster.intersectObject(this.hitArea);
        if (intersects !== undefined && intersects.length > 0 && this.touch && intersects[0].uv !== undefined) {
            this.touch.addTouch(intersects[0].uv.x, intersects[0].uv.y);
        }
    }
    /**
     * Handle touch move envent
     * @param event mouse event
     */
    onTouchMove(event) {
        if (event.touches.length < 2) {
            this.showTouchGestureInfo = true;
            this.gestureInfoSubscription.unsubscribe();
            this.gestureInfoSubscription = this.gestureInfo$.subscribe({
                next: () => {
                    this.showTouchGestureInfo = false;
                    this.gestureInfoSubscription.unsubscribe();
                }
            });
            return;
        }
        event.preventDefault();
        // getBoundingClientRect retruns the distance in pixels of the top left corner of the element
        // to the top left corner of the viewport
        const domRect = this.canvasRef.nativeElement.getBoundingClientRect();
        // get the offset distance between the canvas, which contains the particles, to the outer container element
        const canvasEl = this.canvasRef.nativeElement.children[0];
        // Calculate the relative mouse position
        this.mouse.x = (event.touches[0].clientX - domRect.left - canvasEl.offsetLeft) / canvasEl.clientWidth * 2 - 1;
        this.mouse.y = -(event.touches[0].clientY - domRect.top - canvasEl.offsetTop) / canvasEl.clientHeight * 2 + 1;
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObject(this.hitArea);
        if (intersects !== undefined && intersects.length > 0 && this.touch && intersects[0].uv !== undefined) {
            this.touch.addTouch(intersects[0].uv.x, intersects[0].uv.y);
        }
    }
    resize() {
        if (this.height !== undefined) {
            this.camera.aspect = this.canvasRef.nativeElement.clientWidth / this.canvasRef.nativeElement.clientHeight;
            this.camera.updateProjectionMatrix();
            const fovHeight = 2 * Math.tan(this.camera.fov * Math.PI / 180 / 2) * this.camera.position.z;
            const scale = fovHeight / this.height;
            this.mesh.scale.set(scale, scale, 1);
            // this.hitArea.scale.set(scale, scale, 1);
            if (this.renderer !== undefined) {
                const width = this.imageWidth == null ? this.canvasRef.nativeElement.clientWidth :
                    this.distanceAsNumber(this.imageWidth, this.canvasRef.nativeElement.clientWidth);
                const height = this.imageHeight == null ? this.canvasRef.nativeElement.clientHeight :
                    this.distanceAsNumber(this.imageHeight, this.canvasRef.nativeElement.clientHeight);
                this.renderer.setSize(width, height);
            }
        }
    }
    distanceAsNumber(distance, parentDistance) {
        let returnVal = 0;
        if (distance.includes('px')) {
            returnVal = Number.parseInt(distance.replace('px', ''), 10);
        }
        else if (distance.includes('%')) {
            returnVal = Number.parseInt(distance.replace('%', ''), 10) / 100 * parentDistance;
        }
        else {
            returnVal = Number.parseInt(distance, 10);
        }
        return returnVal;
    }
}
ImageAsParticlesComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-image-as-particles',
                template: `
    <div #container class="threejs-container" [style.background-color]="backgroundColor"
                      [style.justify-content]="justifyContent"
                      [style.align-items]="alignItems"
                      (mousemove)="onMouseMove($event)" (touchmove)="onTouchMove($event)"></div>
    <div *ngIf="showTouchGestureInfo==true" class="touch-gesture-info" [@showHideGestureInformation]>
      <div>
        <span>Use two fingers for touch animation</span>
        <svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24" fill="white" width="18px" height="18px">
          <g><rect fill="none" height="24" width="24" x="0"/></g><g><g><g>
            <path d="M9,11.24V7.5C9,6.12,10.12,5,11.5,5S14,6.12,14,7.5v3.74c1.21-0.81,2-2.18,2-3.74C16,5.01,13.99,3,11.5,3S7,5.01,7,7.5 C7,9.06,7.79,10.43,9,11.24z M18.84,15.87l-4.54-2.26c-0.17-0.07-0.35-0.11-0.54-0.11H13v-6C13,6.67,12.33,6,11.5,6 S10,6.67,10,7.5v10.74c-3.6-0.76-3.54-0.75-3.67-0.75c-0.31,0-0.59,0.13-0.79,0.33l-0.79,0.8l4.94,4.94 C9.96,23.83,10.34,24,10.75,24h6.79c0.75,0,1.33-0.55,1.44-1.28l0.75-5.27c0.01-0.07,0.02-0.14,0.02-0.2 C19.75,16.63,19.37,16.09,18.84,15.87z"/></g></g></g>
          </svg>
      </div>
    </div>
  `,
                animations: [
                    trigger('showHideGestureInformation', [
                        transition(':enter', [
                            style({ opacity: '0' }),
                            animate('300ms ease-in', style({ opacity: '1' }))
                        ]),
                        transition(':leave', [
                            style({ opacity: '1' }),
                            animate('300ms ease-in', style({ opacity: '0' }))
                        ])
                    ])
                ],
                styles: [`
    .threejs-container{
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      background-color: #222222;
    }

    .touch-gesture-info{
      position: absolute;
      width: 100%;
      display: flex;
      flex-direction: row;
      justify-content: center;
      top: 20px;
      color: white;
    }

    .touch-gesture-info div{
      background-color: rgba(0,0,0,0.3);
      display: flex;
      flex-direction: row;
      padding: 6px 10px 6px 10px;
      border-radius: 5px;
    }
  `]
            },] }
];
ImageAsParticlesComponent.ctorParameters = () => [
    { type: NgZone }
];
ImageAsParticlesComponent.propDecorators = {
    imageUrl: [{ type: Input }],
    backgroundColor: [{ type: Input }],
    imageWidth: [{ type: Input }],
    imageHeight: [{ type: Input }],
    horizontalAlignment: [{ type: Input }],
    verticalAlignment: [{ type: Input }],
    animationEnabled: [{ type: Input }],
    canvasRef: [{ type: ViewChild, args: ['container',] }],
    resize: [{ type: HostListener, args: ['window:resize',] }]
};

class ImageAsParticlesModule {
}
ImageAsParticlesModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ImageAsParticlesComponent],
                imports: [
                    CommonModule
                ],
                exports: [ImageAsParticlesComponent]
            },] }
];

class ImageTransitionShaders {
    constructor() {
        this.vertex = `varying vec2 vUv;void main() {vUv = uv;gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}`;
        this.splitTransitionFrag = `
            uniform float progress;
            uniform float intensity;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform vec4 resolution1;
            uniform vec4 resolution2;
            varying vec2 vUv;
            mat2 rotate(float a) {
              float s = sin(a);
              float c = cos(a);
              return mat2(c, -s, s, c);
            }
            void main()	{
              vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
              vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
              vec2 uvDivided1 = fract(newUV1*vec2(intensity,1.));
              vec2 uvDivided2 = fract(newUV2*vec2(intensity,1.));
              vec2 uvDisplaced1 = newUV1 + rotate(3.1415926/4.)*uvDivided1*progress*0.1;
              vec2 uvDisplaced2 = newUV2 + rotate(3.1415926/4.)*uvDivided2*(1. - progress)*0.1;
              vec4 t1 = texture2D(texture1,uvDisplaced1);
              vec4 t2 = texture2D(texture2,uvDisplaced2);
              // Use black background color
              // Top right
              vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
              vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
              float pct1 = tr1.x * tr1.y;
              float pct2 = tr2.x * tr2.y;
              // Bottom left
              vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
              vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
              pct1 *= bl1.x * bl1.y;
              pct2 *= bl2.x * bl2.y;
              vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
              vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
              gl_FragColor = mix(t1wb, t2wb, progress);
            }
    `;
        this.fadeFrag = `
            uniform float progress;
            uniform sampler2D texture1;
            uniform sampler2D texture2;
            uniform vec4 resolution1;
            uniform vec4 resolution2;
            varying vec2 vUv;
            mat2 rotate(float a) {
              float s = sin(a);
              float c = cos(a);
              return mat2(c, -s, s, c);
            }
            void main()	{
              vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
              vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
              vec2 uvDisplaced1 = newUV1 + vec2(1.0,0)*progress*0.1;
              vec2 uvDisplaced2 = newUV2 + vec2(1.0,0)*(1. - progress)*0.1;
              vec4 t1 = texture2D(texture1,uvDisplaced1);
              vec4 t2 = texture2D(texture2,uvDisplaced2);
              // Use black background color
              // Top right
              vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
              vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
              float pct1 = tr1.x * tr1.y;
              float pct2 = tr2.x * tr2.y;
              // Bottom left
              vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
              vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
              pct1 *= bl1.x * bl1.y;
              pct2 *= bl2.x * bl2.y;
              vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
              vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
              gl_FragColor = mix(t1wb, t2wb, progress);
            }
    `;
        this.noiseFrag = `
		uniform float time;
		uniform float progress;
		uniform float width;
		uniform float scaleX;
		uniform float scaleY;
		uniform sampler2D texture1;
		uniform sampler2D texture2;
		uniform sampler2D displacement;
		uniform vec4 resolution1;
		uniform vec4 resolution2;
		varying vec2 vUv;
		varying vec4 vPosition;
		//	Classic Perlin 3D Noise
		//	by Stefan Gustavson
		//
		vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
		vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
		vec4 fade(vec4 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
		float cnoise(vec4 P){
		  ;
		  vec4 Pi0 = floor(P); // Integer part for indexing
		  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec4 Pf0 = fract(P); // Fractional part for interpolation
		  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = vec4(Pi0.zzzz);
		  vec4 iz1 = vec4(Pi1.zzzz);
		  vec4 iw0 = vec4(Pi0.wwww);
		  vec4 iw1 = vec4(Pi1.wwww);
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 ixy00 = permute(ixy0 + iw0);
		  vec4 ixy01 = permute(ixy0 + iw1);
		  vec4 ixy10 = permute(ixy1 + iw0);
		  vec4 ixy11 = permute(ixy1 + iw1);
		  vec4 gx00 = ixy00 / 7.0;
		  vec4 gy00 = floor(gx00) / 7.0;
		  vec4 gz00 = floor(gy00) / 6.0;
		  gx00 = fract(gx00) - 0.5;
		  gy00 = fract(gy00) - 0.5;
		  gz00 = fract(gz00) - 0.5;
		  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
		  vec4 sw00 = step(gw00, vec4(0.0));
		  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
		  gy00 -= sw00 * (step(0.0, gy00) - 0.5);
		  vec4 gx01 = ixy01 / 7.0;
		  vec4 gy01 = floor(gx01) / 7.0;
		  vec4 gz01 = floor(gy01) / 6.0;
		  gx01 = fract(gx01) - 0.5;
		  gy01 = fract(gy01) - 0.5;
		  gz01 = fract(gz01) - 0.5;
		  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
		  vec4 sw01 = step(gw01, vec4(0.0));
		  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
		  gy01 -= sw01 * (step(0.0, gy01) - 0.5);
		  vec4 gx10 = ixy10 / 7.0;
		  vec4 gy10 = floor(gx10) / 7.0;
		  vec4 gz10 = floor(gy10) / 6.0;
		  gx10 = fract(gx10) - 0.5;
		  gy10 = fract(gy10) - 0.5;
		  gz10 = fract(gz10) - 0.5;
		  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
		  vec4 sw10 = step(gw10, vec4(0.0));
		  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
		  gy10 -= sw10 * (step(0.0, gy10) - 0.5);
		  vec4 gx11 = ixy11 / 7.0;
		  vec4 gy11 = floor(gx11) / 7.0;
		  vec4 gz11 = floor(gy11) / 6.0;
		  gx11 = fract(gx11) - 0.5;
		  gy11 = fract(gy11) - 0.5;
		  gz11 = fract(gz11) - 0.5;
		  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
		  vec4 sw11 = step(gw11, vec4(0.0));
		  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
		  gy11 -= sw11 * (step(0.0, gy11) - 0.5);
		  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
		  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
		  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
		  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
		  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
		  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
		  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
		  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
		  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
		  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
		  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
		  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
		  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
		  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
		  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
		  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
		  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
		  g0000 *= norm00.x;
		  g0100 *= norm00.y;
		  g1000 *= norm00.z;
		  g1100 *= norm00.w;
		  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
		  g0001 *= norm01.x;
		  g0101 *= norm01.y;
		  g1001 *= norm01.z;
		  g1101 *= norm01.w;
		  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
		  g0010 *= norm10.x;
		  g0110 *= norm10.y;
		  g1010 *= norm10.z;
		  g1110 *= norm10.w;
		  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
		  g0011 *= norm11.x;
		  g0111 *= norm11.y;
		  g1011 *= norm11.z;
		  g1111 *= norm11.w;
		  float n0000 = dot(g0000, Pf0);
		  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
		  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
		  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
		  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
		  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
		  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
		  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
		  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
		  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
		  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
		  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
		  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
		  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
		  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
		  float n1111 = dot(g1111, Pf1);
		  vec4 fade_xyzw = fade(Pf0);
		  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
		  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
		  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
		  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
		  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
		  return 2.2 * n_xyzw;
		}
		float map(float value, float min1, float max1, float min2, float max2) {
		  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
		}
		float parabola( float x, float k ) {
		  return pow( 4. * x * ( 1. - x ), k );
		}
		void main()	{
			float dt = parabola(progress,1.);
			float border = 1.;
			vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
      		vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);
			vec4 t1 = texture2D(texture1,newUV1);
      		vec4 t2 = texture2D(texture2,newUV2);
      		// Use black background color
      		// Top right
      		vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
      		vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
      		float pct1 = tr1.x * tr1.y;
      		float pct2 = tr2.x * tr2.y;
      		// Bottom left
      		vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
      		vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
      		pct1 *= bl1.x * bl1.y;
      		pct2 *= bl2.x * bl2.y;
      		vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
      		vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
			float realnoise = 0.5*(cnoise(vec4(newUV1.x*scaleX  + 0.*time/3., newUV1.y*scaleY,0.*time/3.,0.)) +1.);
			float w = width*dt;
			float maskvalue = smoothstep(1. - w,1.,vUv.x + mix(-w/2., 1. - w/2., progress));
			float mask = maskvalue + maskvalue*realnoise;
			float final = smoothstep(border,border+0.01,mask);
			gl_FragColor = mix(t1wb,t2wb,final);
		}
	`;
        this.blurFrag = `
		// author: gre
		// license: MIT
		uniform float progress;
		uniform float intensity;
		uniform float ratio;
		uniform sampler2D texture1;
		uniform sampler2D texture2;
		uniform vec4 resolution1;
		uniform vec4 resolution2;
		varying vec2 vUv;
		const int passes = 6;

		void main() {
			vec2 newUV1 = (vUv - vec2(0.5,0.5))*resolution1.zw + vec2(0.5,0.5);
			vec2 newUV2 = (vUv - vec2(0.5,0.5))*resolution2.zw + vec2(0.5,0.5);

			vec4 t1 = vec4(0.0);
			vec4 t2 = vec4(0.0);
			float disp = intensity/100.0*(0.5-distance(0.5, progress));
			for (int xi=0; xi<passes; xi++)
			{
				float x = float(xi) / float(passes) - 0.5;
				for (int yi=0; yi<passes; yi++)
				{
					float y = float(yi) / float(passes) - 0.5;
					vec2 v = vec2(x,y);
					float d = disp;
					t1 += texture2D(texture1,newUV1 + d*v);
					t2 += texture2D(texture2,newUV2 + d*v);
				}
			}

			t1 /= float(passes*passes);
			t2 /= float(passes*passes);

			// Use black background color
			// Top right
			vec2 tr1 = step(newUV1, vec2(1.0, 1.0));
			vec2 tr2 = step(newUV2, vec2(1.0, 1.0));
			float pct1 = tr1.x * tr1.y;
			float pct2 = tr2.x * tr2.y;
			// Bottom left
			vec2 bl1 = step(vec2(0.0, 0.0), newUV1);
			vec2 bl2 = step(vec2(0.0, 0.0), newUV2);
			pct1 *= bl1.x * bl1.y;
			pct2 *= bl2.x * bl2.y;
			vec4 t1wb = t1 * vec4(pct1,pct1,pct1,1.0);
			vec4 t2wb = t2 * vec4(pct2,pct2,pct2,1.0);
			gl_FragColor = mix(t1wb, t2wb, progress);
		}
	`;
    }
}

class ImageTransitionComponent {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.imageUrls = new Array();
        this.transitionDuration = 1000;
        this.animationEnabled = true;
        this.startIndex = 0;
        this.imageIndexChange = new EventEmitter();
        this.pAutoPlay = false;
        this.pAutoPlayInterval = 5000;
        this.pImageSize = 'cover';
        this.pTransitionType = 'split';
        this.pIntensity = 40.0;
        this.pScaleX = 50.0;
        this.pScaleY = 50.0;
        this.pWidth = 0.5;
        this.renderer = new WebGLRenderer({ antialias: true, alpha: true });
        this.scene = new Scene();
        this.textures = new Array();
        this.nextImageIndex = 0;
        this.tranistionOngoing = false;
        this.shaders = new ImageTransitionShaders();
        this.autoPlay$ = new Observable();
        this.autoPlaySubscription = new Subscription();
    }
    get imageSize() { return this.pImageSize; }
    set imageSize(imageSize) {
        this.pImageSize = imageSize;
        if (this.mesh != null) {
            this.resize();
        }
    }
    get autoPlay() { return this.pAutoPlay; }
    set autoPlay(autoplay) {
        this.pAutoPlay = autoplay;
        if (this.mesh != null) {
            if (this.pAutoPlay === true) {
                this.setAutoPlayInterval();
            }
            else {
                this.stopAutoPlayInterval();
            }
        }
    }
    get autoPlayInterval() { return this.pAutoPlayInterval; }
    set autoPlayInterval(autoPlayInterval) {
        this.pAutoPlayInterval = autoPlayInterval;
        if (this.mesh != null) {
            if (this.pAutoPlay === true) {
                this.stopAutoPlayInterval();
                this.setAutoPlayInterval();
            }
        }
    }
    get transitionType() { return this.pTransitionType; }
    set transitionType(transitionType) {
        this.pTransitionType = transitionType;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get sizeX() { return this.pScaleX; }
    set sizeX(sizeX) {
        this.pScaleX = sizeX;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get sizeY() { return this.pScaleY; }
    set sizeY(sizeY) {
        this.pScaleY = sizeY;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get width() { return this.pWidth; }
    set width(width) {
        this.pWidth = width;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    get intensity() { return this.intensity; }
    set intensity(intensity) {
        this.pIntensity = intensity;
        if (this.material != null) {
            this.setShaderProperties();
        }
    }
    ngAfterViewInit() {
        // Init camera
        this.camera = new PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.001, 1000);
        this.camera.position.set(0, 0, 2);
        // Create scene
        this.scene = new Scene();
        // Init Mesh
        if (this.imageUrls.length < 2) {
            throw new Error('At least two images are required');
        }
        this.initMesh();
        // Init renderer
        const canvasWidth = this.threejsContainer.nativeElement.clientWidth;
        const canvasHeight = this.threejsContainer.nativeElement.clientHeight;
        this.renderer.setSize(canvasWidth, canvasHeight);
        this.threejsContainer.nativeElement.appendChild(this.renderer.domElement);
        // Init autoPlay Observable
        if (this.pAutoPlay === true) {
            this.setAutoPlayInterval();
        }
        this.animate();
    }
    ngOnDestroy() {
        // Cancel Animation
        cancelAnimationFrame(this.animationFrameId);
        // Stop autoplay animation
        this.stopAutoPlayInterval();
        // Remove threejs container from DOM
        this.threejsContainer.nativeElement.removeChild(this.renderer.domElement);
        // Dispose textures
        this.textures.forEach(t => {
            t.dispose();
        });
        // Dispose material
        if (this.material) {
            this.material.dispose();
        }
        // Clear scene
        if (this.scene) {
            this.scene.clear();
        }
        // Dispose renderer
        if (this.renderer) {
            this.renderer.dispose();
        }
    }
    /**
     * Initializes the mesh
     */
    initMesh() {
        // Create geometry
        const geometry = new PlaneBufferGeometry(1, 1, 2, 2);
        const promises = new Array();
        // Load pev, current and next textures
        this.textures = new Array(this.imageUrls.length);
        const prevImg = this.startIndex === 0 ? (this.imageUrls.length - 1) : (this.startIndex - 1);
        const nextImg = this.startIndex === (this.imageUrls.length - 1) ? 0 : (this.startIndex + 1);
        for (let idx = 0; idx < this.imageUrls.length; idx++) {
            if (idx === this.startIndex || idx === nextImg || idx === prevImg) {
                promises.push(new Promise(resolve => {
                    this.textures[idx] = (new TextureLoader()).load(this.imageUrls[idx], resolve);
                }));
            }
        }
        this.nextImageIndex = this.startIndex;
        // Emit event to set current image index
        this.imageIndexChange.emit(this.nextImageIndex);
        Promise.all(promises).then(() => {
            this.material = new ShaderMaterial({
                side: DoubleSide,
                uniforms: {
                    time: { value: 0 },
                    progress: { value: 0 },
                    border: { value: 0 },
                    intensity: { value: 50.0 },
                    scaleX: { value: 40.0 },
                    scaleY: { value: 40.0 },
                    transition: { value: 40.0 },
                    swipe: { value: 0 },
                    width: { value: 0.5 },
                    radius: { value: 0 },
                    texture1: { value: this.textures[this.startIndex] },
                    texture2: { value: this.textures[nextImg] },
                    resolution1: { value: new Vector4() },
                    resolution2: { value: new Vector4() }
                },
                // wireframe: true,
                vertexShader: this.shaders.vertex
            });
            this.setShaderProperties();
            this.mesh = new Mesh(geometry, this.material);
            this.scene.add(this.mesh);
            this.resize();
        });
    }
    /**
     * Sets the autoPlay interval
     */
    setAutoPlayInterval() {
        this.autoPlay$ = interval(this.pAutoPlayInterval);
        this.autoPlaySubscription = this.autoPlay$.subscribe({
            next: () => { this.prepAndLoadNextImg(false, true); }
        });
    }
    /**
     * Resets the autoPlay interval
     */
    resetAutoPlayInterval() {
        this.autoPlaySubscription.unsubscribe();
        this.autoPlaySubscription = this.autoPlay$.subscribe({
            next: () => { this.prepAndLoadNextImg(false, true); }
        });
    }
    /**
     * Stops the autoPlay interval
     */
    stopAutoPlayInterval() {
        this.autoPlaySubscription.unsubscribe();
    }
    /**
     * Sets the shader properties depending on the transition type
     */
    setShaderProperties() {
        switch (this.transitionType) {
            case 'split':
                this.material.uniforms.intensity.value = this.pIntensity;
                this.material.fragmentShader = this.shaders.splitTransitionFrag;
                break;
            case 'fade':
                this.material.fragmentShader = this.shaders.fadeFrag;
                break;
            case 'noise':
                this.material.uniforms.scaleX.value = this.pScaleX;
                this.material.uniforms.scaleY.value = this.pScaleY;
                this.material.uniforms.width.value = this.pWidth;
                this.material.fragmentShader = this.shaders.noiseFrag;
                break;
            case 'blur':
                this.material.uniforms.intensity.value = this.pIntensity;
                this.material.fragmentShader = this.shaders.blurFrag;
                break;
            default:
                break;
        }
        this.material.needsUpdate = true;
    }
    /**
     * Animation
     */
    animate() {
        if (this.animationEnabled === true) {
            this.renderer.render(this.scene, this.camera);
        }
        this.ngZone.runOutsideAngular(() => {
            this.animationFrameId = window.requestAnimationFrame(() => this.animate());
        });
    }
    /**
     * Resizes the canvas and updates the texture resulution information of the images
     */
    resize() {
        // Get the with and height of the container
        const containerWidth = this.threejsContainer.nativeElement.offsetWidth;
        const containerHeight = this.threejsContainer.nativeElement.offsetHeight;
        // return the function, if eihter with or heigth is undefined
        if (!containerHeight || !containerHeight) {
            return;
        }
        this.renderer.setSize(containerWidth, containerHeight);
        this.camera.aspect = containerWidth / containerHeight;
        this.updateTextureResolution(this.nextImageIndex, 1);
        const dist = this.camera.position.z;
        const height = 1;
        this.camera.fov = 2 * (180 / Math.PI) * Math.atan(height / (2 * dist));
        this.mesh.scale.x = this.camera.aspect;
        this.mesh.scale.y = 1;
        this.camera.updateProjectionMatrix();
    }
    /**
     * Updates the resulution of the texture for the shader depending on the image size type
     * @param textureNumber Number of the texture
     */
    updateTextureResolution(textureNumber, targetGlslTexture) {
        const texture = this.textures[textureNumber];
        const containerWidth = this.threejsContainer.nativeElement.offsetWidth;
        const containerHeight = this.threejsContainer.nativeElement.offsetHeight;
        // Adapt the size of the image
        const imageAspect = texture.image.height / texture.image.width;
        const containerAspect = containerHeight / containerWidth;
        let a1;
        let a2;
        if (this.pImageSize === 'cover') {
            if (containerAspect > imageAspect) {
                a1 = (containerWidth / containerHeight) * imageAspect;
                a2 = 1;
            }
            else {
                a1 = 1;
                a2 = (containerHeight / containerWidth) / imageAspect;
            }
        }
        else if (this.pImageSize === 'contain') {
            if (containerAspect < imageAspect) {
                a1 = (containerWidth / containerHeight) * imageAspect;
                a2 = 1;
            }
            else {
                a1 = 1;
                a2 = (containerHeight / containerWidth) / imageAspect;
            }
        }
        if (targetGlslTexture === 1) {
            this.material.uniforms.resolution1.value.x = containerWidth;
            this.material.uniforms.resolution1.value.y = containerHeight;
            this.material.uniforms.resolution1.value.z = a1;
            this.material.uniforms.resolution1.value.w = a2;
        }
        else if (targetGlslTexture === 2) {
            this.material.uniforms.resolution2.value.x = containerWidth;
            this.material.uniforms.resolution2.value.y = containerHeight;
            this.material.uniforms.resolution2.value.z = a1;
            this.material.uniforms.resolution2.value.w = a2;
        }
    }
    /**
     * Starts the transition effect to the next image
     * @param posDirection indicator, if the next or previous image should be loaded
     */
    transitionToNextTexture(backw = false) {
        // Set the flag to indicate that the transition animation is ongoing
        this.tranistionOngoing = true;
        // EventEmitter
        this.imageIndexChange.emit(this.nextImageIndex);
        this.ngZone.runOutsideAngular(() => {
            if (backw === true) {
                this.material.uniforms.texture2.value = this.material.uniforms.texture1.value;
                this.material.uniforms.resolution2.value.x = this.material.uniforms.resolution1.value.x;
                this.material.uniforms.resolution2.value.y = this.material.uniforms.resolution1.value.y;
                this.material.uniforms.resolution2.value.z = this.material.uniforms.resolution1.value.z;
                this.material.uniforms.resolution2.value.w = this.material.uniforms.resolution1.value.w;
                this.material.uniforms.progress.value = 1;
                // Set the next image to texture1 and update the resolution
                this.material.uniforms.texture1.value = this.textures[this.nextImageIndex];
                this.updateTextureResolution(this.nextImageIndex, 1);
                // Start the tween for doing the transition
                RxjsTween.createTween(RxjsTween.linear, 1, 0, this.transitionDuration).subscribe({
                    next: val => {
                        this.material.uniforms.progress.value = val;
                    },
                    complete: () => {
                        // Set the transition flag to false to indicate that the transition animation is finished
                        this.tranistionOngoing = false;
                        // Reset progress to 1, thus the texture from texture 2 needs to be set to texture 1
                        this.material.uniforms.texture2.value = this.textures[this.nextImageIndex];
                        this.updateTextureResolution(this.nextImageIndex, 2);
                        this.material.uniforms.progress.value = 0;
                    }
                });
            }
            else {
                // Set the next image to texture2 and update the resolution
                this.material.uniforms.texture2.value = this.textures[this.nextImageIndex];
                this.updateTextureResolution(this.nextImageIndex, 2);
                // Start the tween for doing the transition
                RxjsTween.createTween(RxjsTween.linear, 0, 1, this.transitionDuration).subscribe({
                    next: val => {
                        this.material.uniforms.progress.value = val;
                    },
                    complete: () => {
                        // Set the transition flag to false to indicate that the transition animation is finished
                        this.tranistionOngoing = false;
                        // Reset progress to 0, thus the texture from texture 2 needs to be set to texture 1
                        this.material.uniforms.texture1.value = this.textures[this.nextImageIndex];
                        this.updateTextureResolution(this.nextImageIndex, 1);
                        this.material.uniforms.progress.value = 0;
                    }
                });
            }
        });
    }
    prepAndLoadNextImg(prev, autoPlayTriggered) {
        if (this.tranistionOngoing) {
            return;
        }
        if (this.pAutoPlay === true && autoPlayTriggered === false) {
            this.resetAutoPlayInterval();
        }
        if (prev === false) {
            // Set the next index
            this.nextImageIndex = (this.nextImageIndex < this.imageUrls.length - 1) ? this.nextImageIndex + 1 : 0;
            // Check if another texture needs to be loaded
            const nextButOne = this.nextImageIndex + 1 > this.imageUrls.length - 1 ? 0 : this.nextImageIndex + 1;
            if (this.textures[nextButOne] === undefined) {
                this.textures[nextButOne] = (new TextureLoader).load(this.imageUrls[nextButOne]);
            }
        }
        else {
            // Update the number of the current shown image
            this.nextImageIndex = (this.nextImageIndex > 0) ? this.nextImageIndex - 1 : this.imageUrls.length - 1;
            // Check if another texture needs to be loaded
            const nextButOne = this.nextImageIndex - 1 < 0 ? this.imageUrls.length - 1 : this.nextImageIndex - 1;
            if (this.textures[nextButOne] === undefined) {
                this.textures[nextButOne] = (new TextureLoader).load(this.imageUrls[nextButOne]);
            }
        }
        this.transitionToNextTexture();
    }
    //#region public methods
    next() {
        this.prepAndLoadNextImg(false, false);
    }
    prev() {
        this.prepAndLoadNextImg(true, false);
    }
}
ImageTransitionComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-image-transition',
                template: "<div #threejsContainer class=\"threejs-container\"></div>",
                styles: [".threejs-container{width:100%;height:100%}"]
            },] }
];
ImageTransitionComponent.ctorParameters = () => [
    { type: NgZone }
];
ImageTransitionComponent.propDecorators = {
    imageUrls: [{ type: Input }],
    imageSize: [{ type: Input }],
    autoPlay: [{ type: Input }],
    autoPlayInterval: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    transitionType: [{ type: Input }],
    sizeX: [{ type: Input }],
    sizeY: [{ type: Input }],
    width: [{ type: Input }],
    intensity: [{ type: Input }],
    animationEnabled: [{ type: Input }],
    startIndex: [{ type: Input }],
    imageIndexChange: [{ type: Output }],
    threejsContainer: [{ type: ViewChild, args: ['threejsContainer',] }],
    resize: [{ type: HostListener, args: ['window:resize',] }]
};

class ImageTransitionModule {
}
ImageTransitionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ImageTransitionComponent],
                imports: [
                    CommonModule
                ],
                exports: [ImageTransitionComponent]
            },] }
];

class LightboxOverlayComponent {
    constructor(changeRef) {
        this.changeRef = changeRef;
        this.imageUrls = new Array();
        this.forceFullscreen = false;
        this.forceShowNavButtons = false;
        this.imageSize = 'cover';
        this.autoPlay = false;
        this.autoPlayInterval = 5000;
        this.transitionDuration = 1000;
        this.transitionType = 'split';
        this.sizeX = 50.0;
        this.sizeY = 50.0;
        this.width = 0.5;
        this.intensity = 40.0;
        this.startIndex = 0;
        this.currentImageIndex = 1;
        this.swipeCoord = new Array();
        this.swipeTime = 0;
    }
    ngOnInit() {
    }
    keyEvent(event) {
        if (event.key === 'ArrowRight') {
            this.imageTransition.next();
        }
        if (event.key === 'ArrowLeft') {
            this.imageTransition.prev();
        }
        if (event.key === 'Escape') {
            this.close();
        }
    }
    /**
     * Close the lightbox
     */
    close() {
        var _a;
        (_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.detach();
    }
    /**
     * method to set the index counter
     * @param index index of the image
     */
    imageIndexChange(index) {
        this.currentImageIndex = index + 1;
        this.changeRef.detectChanges();
    }
    /**
     * Listen to touche events for gestures (mobile)
     * @param e touch event
     * @param when indicator if 'start' or 'end'
     */
    swipe(e, when) {
        const coord = [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        const time = new Date().getTime();
        if (when === 'start') {
            this.swipeCoord = coord;
            this.swipeTime = time;
        }
        else if (when === 'end') {
            const direction = [coord[0] - this.swipeCoord[0], coord[1] - this.swipeCoord[1]];
            const duration = time - this.swipeTime;
            if (duration < 1000 && Math.abs(direction[0]) > 30 // Long enough
                && Math.abs(direction[0]) > Math.abs(direction[1] * 3)) { // Horizontal enough
                const swipe = direction[0] < 0 ? 'next' : 'previous';
                if (swipe === 'next') {
                    this.imageTransition.next();
                }
                else if (swipe === 'previous') {
                    this.imageTransition.prev();
                }
            }
        }
    }
}
LightboxOverlayComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-lightbox-overlay',
                template: "<div [ngClass]=\"{'full-container': forceFullscreen === true, 'auto-container': forceFullscreen === false }\">\n    <div class=\"index-indicator\">\n        <span>{{ currentImageIndex }}</span>\n        <span>/</span>\n        <span>{{ imageUrls.length }}</span>\n    </div>\n    <svg class=\"ligthbox-button close-button\" (click)=\"close()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" />\n    </svg>\n\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \n        class=\"ligthbox-button prev-button\" (click)=\"imageTransition.prev()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\" />\n    </svg>\n\n    <svg [ngClass]=\"{'auto-visibility': forceShowNavButtons === false}\" \n        class=\"ligthbox-button next-button\" (click)=\"imageTransition.next()\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"white\">\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\" />\n    </svg>\n    <lib-image-transition #imageTransition [imageUrls]=\"imageUrls\" [startIndex]=\"startIndex\" (imageIndexChange)=\"imageIndexChange($event)\"\n        [imageSize]=\"imageSize\" [autoPlay]=\"autoPlay\" [autoPlayInterval]=\"autoPlayInterval\" [transitionDuration]=\"transitionDuration\"\n        [transitionType]=\"transitionType\" [sizeX]=\"sizeX\" [sizeY]=\"sizeY\" [width]=\"width\" [intensity]=\"intensity\"\n        (touchstart)=\"swipe($event, 'start')\" (touchend)=\"swipe($event, 'end')\">\n    </lib-image-transition>\n</div>",
                styles: [".auto-container{width:1100px;height:800px;max-width:90vw;max-height:90vh}.auto-container,.full-container{position:relative;background-color:#000;box-shadow:0 0 15px 10px rgba(0,0,0,.5)}.full-container{width:100vw;height:100vh;max-width:100vw;max-height:100vh}.index-indicator{color:#fff;border-radius:0 0 5px 0;padding:8px}.index-indicator,.ligthbox-button{position:absolute;z-index:1;background-color:rgba(0,0,0,.4)}.ligthbox-button{cursor:pointer;width:36px;height:36px}.ligthbox-button:hover{fill:hsla(0,0%,100%,.5)}.close-button{top:0;right:0;border-radius:0 0 0 5px}.prev-button{top:calc(50% - 18px);left:0;border-radius:0 5px 5px 0}.next-button{top:calc(50% - 18px);right:0;border-radius:5px 0 0 5px}@media (max-width:600px){.auto-container{width:100vw;height:100vh;max-width:100vw;max-height:100vh}.auto-visibility{visibility:collapse}}lib-image-transition{touch-action:none}"]
            },] }
];
LightboxOverlayComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
LightboxOverlayComponent.propDecorators = {
    imageTransition: [{ type: ViewChild, args: [ImageTransitionComponent,] }],
    keyEvent: [{ type: HostListener, args: ['window:keyup', ['$event'],] }]
};

class LightboxComponent {
    constructor(overlay) {
        this.overlay = overlay;
        this.imageUrls = new Array();
        this.forceFullscreen = false;
        this.forceShowNavButtons = false;
        this.imageSize = 'cover';
        this.autoPlay = false;
        this.autoPlayInterval = 5000;
        this.transitionDuration = 1000;
        this.transitionType = 'split';
        this.sizeX = 50.0;
        this.sizeY = 50.0;
        this.width = 0.5;
        this.intensity = 40.0;
    }
    ngOnInit() {
    }
    open(index = 0) {
        // Define settings of the overlay
        this.overlayRef = this.overlay.create({
            hasBackdrop: true,
            positionStrategy: this.overlay.position().global().centerHorizontally().centerVertically(),
            scrollStrategy: this.overlay.scrollStrategies.block()
        });
        // Listen to backdrop event for detaching the overlay
        this.overlayRef.backdropClick().subscribe({
            next: () => { var _a; (_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.detach(); }
        });
        // Attach the LightboxOverlayComponent to the overlayRef instance
        const lightboxOverlayRef = this.overlayRef.attach(new ComponentPortal(LightboxOverlayComponent));
        // Pass data to the LightboxOverlayComponent
        lightboxOverlayRef.instance.overlayRef = this.overlayRef;
        lightboxOverlayRef.instance.imageUrls = this.imageUrls;
        lightboxOverlayRef.instance.forceFullscreen = this.forceFullscreen;
        lightboxOverlayRef.instance.forceShowNavButtons = this.forceShowNavButtons;
        lightboxOverlayRef.instance.imageSize = this.imageSize;
        lightboxOverlayRef.instance.autoPlay = this.autoPlay;
        lightboxOverlayRef.instance.autoPlayInterval = this.autoPlayInterval;
        lightboxOverlayRef.instance.transitionDuration = this.transitionDuration;
        lightboxOverlayRef.instance.transitionType = this.transitionType;
        lightboxOverlayRef.instance.sizeX = this.sizeX;
        lightboxOverlayRef.instance.sizeY = this.sizeY;
        lightboxOverlayRef.instance.width = this.width;
        lightboxOverlayRef.instance.intensity = this.intensity;
        lightboxOverlayRef.instance.startIndex = index;
    }
    close() {
        var _a;
        (_a = this.overlayRef) === null || _a === void 0 ? void 0 : _a.detach();
    }
}
LightboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-lightbox',
                template: ''
            },] }
];
LightboxComponent.ctorParameters = () => [
    { type: Overlay }
];
LightboxComponent.propDecorators = {
    imageUrls: [{ type: Input }],
    forceFullscreen: [{ type: Input }],
    forceShowNavButtons: [{ type: Input }],
    imageSize: [{ type: Input }],
    autoPlay: [{ type: Input }],
    autoPlayInterval: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    transitionType: [{ type: Input }],
    sizeX: [{ type: Input }],
    sizeY: [{ type: Input }],
    width: [{ type: Input }],
    intensity: [{ type: Input }]
};

class LightboxModule {
}
LightboxModule.decorators = [
    { type: NgModule, args: [{
                declarations: [LightboxComponent, LightboxOverlayComponent],
                imports: [
                    CommonModule,
                    ImageTransitionModule,
                    OverlayModule
                ],
                exports: [LightboxComponent],
                entryComponents: [LightboxOverlayComponent]
            },] }
];

class ObjectControls {
    constructor(rendererDom, object, touchArea) {
        // ============= Private Properties =============
        this.isUserInteracting = false;
        this.restoringAnimationOngoing = false;
        this.restoringOriginPosTimeout = 0;
        this.userInteracted = false;
        this.userInteractedSubject = new Subject();
        // ============= Public Properties =============
        this.rotationSpeed = 1;
        this.verticalRotation = true;
        this.horizontalRotation = true;
        this.autoRotationY = false;
        this.autoRotationX = false;
        this.autoRotationZ = false;
        this.restoreOriginPosition = false;
        this.autoRotationSpeed = 0.002;
        this.userInteracted$ = this.userInteractedSubject.asObservable();
        this.controlsEnabled = true;
        /******************  MOUSE interaction functions - desktop  *****/
        /**
         * Prepares everything, when the mouse is clicked
         * @param e mouse event
         */
        this.mouseDown = (e) => {
            // Ignore mouse down interaction, if the controls are not enabled
            // Ignore mouse down interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing === true)
                return;
            // Reset restoration animation timout
            window.clearTimeout(this.restoringOriginPosTimeout);
            this.isUserInteracting = true;
            this.startDraggingPosition = new Vector2(0, 0);
            this.startDraggingPosition.set(e.offsetX, e.offsetY);
            this.touchArea.addEventListener('pointermove', this.mouseMove, false);
            this.touchArea.addEventListener('pointerup', this.mouseUp, false);
        };
        /**
         * Calculates the x and y rotation of the object depending on the mouse movement
         * @param e MouseEvent
         */
        this.mouseMove = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse movement interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            if (this.isUserInteracting) {
                if (this.userInteracted == false) {
                    this.userInteracted = true;
                    this.userInteractedSubject.next(this.userInteracted);
                }
                const deltaMove = new Vector2(e.offsetX - this.startDraggingPosition.x, e.offsetY - this.startDraggingPosition.y);
                this.startDraggingPosition.set(e.offsetX, e.offsetY);
                const rotationX = this.verticalRotation == true ? (deltaMove.x * Math.PI / 180 * this.rotationSpeed) : 0;
                const rotationY = this.horizontalRotation == true ? (deltaMove.y * Math.PI / 180 * this.rotationSpeed) : 0;
                var deltaRotationQuaternion = new Quaternion().setFromEuler(new Euler(rotationY, rotationX, 0, 'XYZ'));
                this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
                //console.log(`rotX: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.x))}, rotY: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.y))}, rotZ: ${Math.round(THREE.MathUtils.radToDeg(this.obj.rotation.z))}`);
            }
        };
        this.mouseUp = () => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse up interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            this.resetMousePosition();
            this.isUserInteracting = false;
            if (this.restoreOriginPosition)
                this.restoreOriginalPosition();
            this.touchArea.removeEventListener('mousemove', this.mouseMove, false);
            this.touchArea.removeEventListener('mouseup', this.mouseUp, false);
        };
        /****************** TOUCH interaction functions - mobile  *****/
        this.onTouchStart = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore touch start interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            // Reset restoration animation timout
            window.clearTimeout(this.restoringOriginPosTimeout);
            //e.preventDefault();
            this.isUserInteracting = true;
            this.restoringAnimationOngoing = false;
            this.startDraggingPosition.set(e.touches[0].pageX, e.touches[0].pageY);
        };
        this.onTouchMove = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse move interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            //e.preventDefault();
            if (this.isUserInteracting && !this.restoringAnimationOngoing) {
                if (this.userInteracted == false) {
                    this.userInteracted = true;
                    this.userInteractedSubject.next(this.userInteracted);
                }
                const deltaMove = new Vector2(e.touches[0].pageX - this.startDraggingPosition.x, e.touches[0].pageY - this.startDraggingPosition.y);
                this.startDraggingPosition.set(e.touches[0].pageX, e.touches[0].pageY);
                const rotationX = this.verticalRotation == true ? (deltaMove.x * Math.PI / 180 * this.rotationSpeed) : 0;
                const rotationY = this.horizontalRotation == true ? (deltaMove.y * Math.PI / 180 * this.rotationSpeed) : 0;
                var deltaRotationQuaternion = new Quaternion().setFromEuler(new Euler(rotationY, rotationX, 0, 'XYZ'));
                this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
            }
        };
        this.onTouchEnd = (e) => {
            // Ignore mouse movement interaction, if the controls are not enabled
            // Ignore mouse up interaction, if the restoration animation is ongoing
            if (this.controlsEnabled === false || this.restoringAnimationOngoing)
                return;
            //e.preventDefault();
            this.isUserInteracting = false;
            this.resetMousePosition();
            if (this.restoreOriginPosition)
                this.restoreOriginalPosition();
        };
        this.rendererDom = rendererDom;
        this.obj = object;
        this.touchArea = touchArea != null ? touchArea : this.rendererDom;
        this.startDraggingPosition = new Vector2(0, 0);
        this.addEventlisteners();
    }
    // ============= Public Methods =============
    /**
     * Method, which needs to be called, in case autorotation is used
     */
    update() {
        if (this.isUserInteracting || this.restoringAnimationOngoing || this.userInteracted)
            return;
        var rotationY = this.autoRotationY == true ? this.autoRotationSpeed : 0;
        var rotationX = this.autoRotationX == true ? this.autoRotationSpeed : 0;
        var rorationZ = this.autoRotationZ == true ? this.autoRotationSpeed : 0;
        var deltaRotationQuaternion = new Quaternion().setFromEuler(new Euler(rotationX, rotationY, rorationZ, 'XYZ'));
        this.obj.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.obj.quaternion);
    }
    /**
     * Removes the event listners
     */
    removeEventlisteners() {
        // desktop events
        this.touchArea.removeEventListener('mousedown', this.mouseDown, false);
        this.touchArea.removeEventListener('mousemove', this.mouseMove, false);
        this.touchArea.removeEventListener('mouseup', this.mouseUp, false);
        // mobile events
        this.touchArea.removeEventListener('touchstart', this.onTouchStart, false);
        this.touchArea.removeEventListener('touchmove', this.onTouchMove, false);
        this.touchArea.removeEventListener('touchend', this.onTouchEnd, false);
    }
    resetUserInteractionFlag() {
        this.userInteracted = false,
            this.userInteractedSubject.next(this.userInteracted);
    }
    // ============= Private Methods =============
    /**
     * Adds the event listeners
     */
    addEventlisteners() {
        // desktop events
        this.touchArea.addEventListener('mousedown', this.mouseDown, false);
        // mobile events
        this.touchArea.addEventListener('touchend', this.onTouchEnd, false);
        this.touchArea.addEventListener('touchstart', this.onTouchStart, false);
        this.touchArea.addEventListener('touchmove', this.onTouchMove, false);
    }
    /**
     * Reset the mouse position to x=0 and y=0
     */
    resetMousePosition() {
        this.startDraggingPosition.set(0, 0);
    }
    /**
     * Rotates the object to the position 0,0,0 after a some timeout
     */
    restoreOriginalPosition() {
        this.restoringOriginPosTimeout = window.setTimeout(() => {
            var objSet = new Object3D();
            objSet.position.set(0, 0, 0);
            objSet.rotation.set(0, 0, 0);
            RxjsTween.createTween(RxjsTween.linear, [this.obj.position.x, this.obj.position.y, this.obj.position.z], [objSet.position.x, objSet.position.y, objSet.position.z], 1000).subscribe({
                next: tweenVal => {
                    if (this.restoringAnimationOngoing == false)
                        this.restoringAnimationOngoing = true;
                    this.obj.rotation.set(tweenVal[0], tweenVal[1], tweenVal[2]);
                },
                complete: () => {
                    this.restoringAnimationOngoing = false;
                    this.resetUserInteractionFlag();
                }
            });
        }, 5000);
    }
}

class CarouselItem {
    constructor(el) {
        this.el = el;
        this.htmlElement = this.el.nativeElement;
    }
}
CarouselItem.decorators = [
    { type: Directive, args: [{
                selector: `acuw-carousel-item`,
                host: {
                    'class': 'acuw-carousel-item',
                }
            },] }
];
CarouselItem.ctorParameters = () => [
    { type: ElementRef }
];
class CarouselComponent {
    constructor(ngZone, animationBuilder) {
        this.ngZone = ngZone;
        this.animationBuilder = animationBuilder;
        this.showDots = true;
        this.dotColor = '#fff';
        this.activeDotColor = '#3f51b5';
        this.dotAnimationCircleColor = '#fff';
        this.activeCarouselElement = 0;
        this.activeCarouselElementChange = new EventEmitter();
        this.initAnimation = true;
        this.radius = 200;
        this.yPosition = 0;
        this.cameraFov = 65;
        this.cameraDistance = 600;
        this.autoPlay = false;
        this.autoPlayInterval = 5000;
        this.rotationDuration = 500;
        this.css3dRenderer = new CSS3DRenderer();
        this.scene = new Scene();
        this.carouselGroup = new Group();
        this.carouselObjSubsciptions = new Array();
        this.rotationSubscription = new Subscription();
        this.animation = true;
        this.userMove = false;
    }
    ngAfterViewInit() {
        // Init camera
        this.camera = new PerspectiveCamera(this.cameraFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0.0, 0.0, this.cameraDistance);
        // Get the with and heigth of the threejs renderer
        const divWidth = this.threejsContainer.nativeElement.clientWidth;
        const divHeight = this.threejsContainer.nativeElement.clientHeight;
        // Create CSS3D Renderer
        this.css3dRenderer = new CSS3DRenderer();
        this.css3dRenderer.setSize(divWidth, divHeight);
        this.css3dRenderer.domElement.style.position = 'absolute';
        this.css3dRenderer.domElement.style.top = '0';
        this.threejsContainer.nativeElement.appendChild(this.css3dRenderer.domElement);
        // Init carousel elements
        this.initCarouselObjects();
        // Object-Controls
        this.objectControls = new ObjectControls(this.css3dRenderer.domElement, this.carouselGroup, this.threejsContainer.nativeElement);
        this.objectControls.userInteracted$.subscribe({
            next: val => {
                this.userMove = val;
                // Cancel the rotation, if running
                this.rotationSubscription.unsubscribe();
            }
        });
        // Initialize the animation of the inidcation dots
        if (this.autoPlay) {
            this.startDotAnimation(this.activeCarouselElement);
        }
        // Animate
        this.animate();
    }
    ngOnChanges(changes) {
        let change = changes['activeCarouselElement'];
        if (change && !change.firstChange && this.carouselGroup) {
            //console.log(`activeCarouselElement change | previousValue=${change.previousValue} | newValue=${change.currentValue} |
            //activeCarouselElement=${this.activeCarouselElement}`);
            if (change.currentValue !== this.activeCarouselElement) {
                //console.log('rotate to ' + change.currentValue);
                this.rotateTo(change.currentValue);
            }
        }
        change = changes['radius'];
        if (change && !change.firstChange && this.carouselGroup) {
            this.updateRadius();
        }
        change = changes['cameraFov'];
        if (change && !change.firstChange && this.camera) {
            this.camera.fov = this.cameraFov;
            this.camera.updateProjectionMatrix();
        }
        change = changes['cameraDistance'];
        if (change && !change.firstChange && this.camera) {
            this.camera.position.set(0, 0, this.cameraDistance);
            this.camera.updateProjectionMatrix();
        }
        change = changes['autoPlay'];
        if (change && this.carouselGroup) {
            if (change.currentValue === true) {
                this.startDotAnimation(this.activeCarouselElement);
            }
            else {
                this.resetDotAnimation();
            }
        }
    }
    ngOnDestroy() {
        // Cancel Animation
        cancelAnimationFrame(this.animationFrameId);
        // Unsubscribe Subscriptions
        this.rotationSubscription.unsubscribe();
        // Remove threejs container from DOM
        this.threejsContainer.nativeElement.removeChild(this.css3dRenderer.domElement);
        // Clear scene
        this.scene.clear();
    }
    /**
     * Resizes the canvas and updates the texture resulution information of the images
     */
    resize() {
        // Get width and heigh of the threejs dom element after window resize
        const divWidth = this.threejsContainer.nativeElement.clientWidth;
        const divHeight = this.threejsContainer.nativeElement.clientHeight;
        // Define aspect ratio
        this.camera.aspect = divWidth / divHeight;
        this.camera.updateProjectionMatrix();
        //this.renderer.setSize(divWidth, divHeight);
        this.css3dRenderer.setSize(divWidth, divHeight);
    }
    /**
     * Animation
     */
    animate() {
        if (this.animation == true) {
            this.css3dRenderer.render(this.scene, this.camera);
        }
        this.ngZone.runOutsideAngular(() => {
            this.animationFrameId = window.requestAnimationFrame(() => this.animate());
        });
    }
    /**
     * starts the animation of the indication dots
     * @param index index number for which dot the animation should be started
     * @returns
     */
    startDotAnimation(index) {
        if (this.dotAnimationPlayer || !this.dots) {
            // Animation is already ongoing
            return;
        }
        // Define the animation
        const autoPlayAnimation = this.animationBuilder.build([
            style({ strokeDasharray: '0,250.2', visibility: 'visible' }),
            animate(this.autoPlayInterval, style({ strokeDasharray: '250.2,250.2' }))
        ]);
        // Get the element for, which the animation should be applied
        const path = this.dots.nativeElement.children[index].getElementsByTagName('path')[0];
        this.dotAnimationPlayer = autoPlayAnimation.create(path);
        // Start the animation
        this.dotAnimationPlayer.play();
        // Switch to the next carousel, as soon as the animation is finished
        this.dotAnimationPlayer.onDone(() => {
            this.dotAnimationPlayer = null;
            this.next();
        });
    }
    /**
     * Resets the dot animation
     */
    resetDotAnimation() {
        if (this.dotAnimationPlayer && this.dotAnimationPlayer.hasStarted()) {
            this.dotAnimationPlayer.reset();
            this.dotAnimationPlayer = null;
        }
    }
    /**
     * Initialize the carousel objects
     */
    initCarouselObjects(animation = true) {
        var _a;
        this.carouselElements = new Array();
        for (let idx = 0; idx < this.carouselItemTemplates.length; idx++) {
            let copiedElement = ((_a = this.carouselItemTemplates.get(idx)) === null || _a === void 0 ? void 0 : _a.htmlElement);
            if (copiedElement) {
                var object = new CSS3DObject(copiedElement);
                object.element.style.pointerEvents = 'none';
                // Add element to global variable
                this.carouselElements.push(object);
                // Create subscription for tween animation
                this.carouselObjSubsciptions.push(new Subscription());
            }
        }
        // Clear the carousel group
        this.carouselGroup.clear();
        var yOrientation = -((this.activeCarouselElement) * Math.PI * 2 / this.carouselElements.length);
        this.carouselGroup.rotation.set(0, yOrientation, 0);
        var index = 0;
        const elementsCnt = this.carouselElements.length;
        this.carouselElements.forEach(obj => {
            // Unsubscribe previously subscription
            this.carouselObjSubsciptions[index].unsubscribe();
            // Define final position
            let tweenObj = new Object3D();
            let theta = index * 2 * (Math.PI / elementsCnt);
            tweenObj.position.setFromCylindricalCoords(this.radius, theta, this.yPosition);
            let vector = new Vector3(tweenObj.position.x * 2, tweenObj.position.y, tweenObj.position.z * 2);
            tweenObj.lookAt(vector);
            // Set roattion
            obj.rotation.x = tweenObj.rotation.x;
            obj.rotation.y = tweenObj.rotation.y;
            obj.rotation.z = tweenObj.rotation.z;
            if (this.initAnimation === true && animation === true) {
                // Set random position
                obj.position.x = Math.random() * 2000 - 1000;
                obj.position.y = Math.random() * 500;
                obj.position.z = Math.random() * 500;
                // Add the objects to the portfolio group
                this.carouselGroup.add(obj);
                // Tween to final position
                this.ngZone.runOutsideAngular(() => {
                    this.carouselObjSubsciptions[index] = RxjsTween.createTween(RxjsTween.easeInOutQuad, [obj.position.x, obj.position.y, obj.position.z], [tweenObj.position.x, tweenObj.position.y, tweenObj.position.z], 2000).subscribe({
                        next: tweenPos => {
                            obj.position.set(tweenPos[0], tweenPos[1], tweenPos[2]);
                        }
                    });
                });
            }
            else {
                obj.position.x = tweenObj.position.x;
                obj.position.y = tweenObj.position.y;
                obj.position.z = tweenObj.position.z;
                // Add the objects to the portfolio group
                this.carouselGroup.add(obj);
            }
            index = index + 1;
        });
        //add the group to the scene
        this.scene.add(this.carouselGroup);
    }
    /**
     * Rotate to next carousel item
     */
    next() {
        let nextElement = this.activeCarouselElement >= this.carouselElements.length - 1 ? 0 : this.activeCarouselElement + 1;
        this.resetDotAnimation();
        this.rotateTo(nextElement);
    }
    /**
     * Rotate to previous carousel item
     */
    previous() {
        let nextElement = this.activeCarouselElement == 0 ? this.carouselElements.length - 1 : this.activeCarouselElement - 1;
        this.resetDotAnimation();
        this.rotateTo(nextElement);
    }
    /**
     * Rotates to a sepcific carousel item
     * @param targetIndex index of the carousel item
     */
    rotateTo(targetIndex) {
        if (targetIndex > this.carouselElements.length - 1) {
            console.error('target index is greater than available carousel items');
            return;
        }
        if (targetIndex > this.activeCarouselElement) {
            // In case the current elment is the first again, reset the orientation
            if (this.activeCarouselElement == 0 && (this.carouselGroup.rotation.y != 0
                && this.carouselGroup.rotation.x == 0 && this.carouselGroup.rotation.z == 0)) {
                this.carouselGroup.rotation.set(0, 0, 0);
            }
        }
        else if (targetIndex == this.carouselElements.length - 1) {
            // Set position of the first element to y = -2*PI
            if (this.activeCarouselElement == 0 && (this.carouselGroup.rotation.y == 0
                && this.carouselGroup.rotation.x == 0 && this.carouselGroup.rotation.z == 0)) {
                this.carouselGroup.rotation.set(0, -2 * Math.PI, 0);
            }
        }
        const startQuaternion = this.carouselGroup.quaternion.clone();
        // Calculate the orientation of the target item
        const yOrientation = -((targetIndex) * Math.PI * 2 / this.carouselElements.length);
        let targetQuaternion = new Quaternion().setFromEuler(new Euler(0, yOrientation, 0, 'XYZ'));
        this.rotationSubscription.unsubscribe();
        // Run rotation animation outsie zgZone
        this.ngZone.runOutsideAngular(() => {
            this.rotationSubscription = RxjsTween.createTween(RxjsTween.easeInOutQuad, 0, 1, this.rotationDuration).subscribe({
                next: x => {
                    Quaternion.slerp(startQuaternion, targetQuaternion, this.carouselGroup.quaternion, x);
                },
                complete: () => {
                    Quaternion.slerp(startQuaternion, targetQuaternion, this.carouselGroup.quaternion, 1);
                    this.ngZone.run(() => {
                        this.activeCarouselElement = targetIndex;
                        this.activeCarouselElementChange.emit(this.activeCarouselElement);
                        this.objectControls.resetUserInteractionFlag();
                        if (this.autoPlay) {
                            this.startDotAnimation(this.activeCarouselElement);
                        }
                    });
                }
            });
        });
    }
    /**
     * Updates and reinits the carousel items
     */
    updateCarouselItems() {
        this.initCarouselObjects(false);
    }
    /**
     * Updates the radius of the carousel items
     */
    updateRadius() {
        for (let idx = 0; idx < this.carouselGroup.children.length; idx++) {
            let theta = idx * 2 * (Math.PI / this.carouselGroup.children.length);
            this.carouselGroup.children[idx].position.setFromCylindricalCoords(this.radius, theta, this.yPosition);
        }
    }
}
CarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'acuw-carousel',
                template: `
    <div class="carousel-container">
      <div #threejsContainer class="threejs-container"></div>
      <!-- dots -->
      <div #indicationDots class="dots">
      <svg *ngFor="let carouselTemplate of carouselItemTemplates; index as i" viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="45" [ngStyle]="{'fill': activeCarouselElement===i ? activeDotColor : dotColor}"/>
          <path id="{{i}}" fill="none" stroke-linecap="round" stroke-width="20" 
          [ngStyle]="{'stroke': dotAnimationCircleColor, 'visibility': activeCarouselElement===i && autoPlay ? 'visible' : 'hidden'}"
                d="M50 10 a 40 40 0 0 1 0 80 a 40 40 0 0 1 0 -80"/>
        </svg>
      </div>
    </div>
    
  `,
                animations: [
                    trigger('dotsAnimation', [
                        transition(':enter', [
                            query('svg', [
                                style({ opacity: 0, transform: 'translateY(200%)' }),
                                stagger(100, [
                                    animate('300ms ease-in', style({ opacity: 1, transform: 'none' }))
                                ])
                            ], { optional: true })
                        ]),
                        transition(':leave', [
                            query('svg', [
                                stagger(100, [
                                    animate('300ms ease-in', style({ opacity: 0, transform: 'translateY(200%)' }))
                                ])
                            ], { optional: true })
                        ])
                    ]),
                    trigger('autoPlayAnimation', [
                        state('false', style({ strokeDasharray: '0,250.2' })),
                        state('true', style({ strokeDasharray: '250.2,250.2' })),
                        transition('false => true', animate(5000))
                    ])
                ],
                styles: [".carousel-container,.threejs-container{position:relative;width:100%;height:100%;background-color:inherit}.threejs-container{align-items:center}.dots,.threejs-container{display:flex;justify-content:center}.dots{position:absolute;bottom:0;flex-direction:row;flex-wrap:wrap;width:100%;overflow:hidden}.dots svg{width:28px;height:28px;margin:0 5px 24px}", `
  `]
            },] }
];
CarouselComponent.ctorParameters = () => [
    { type: NgZone },
    { type: AnimationBuilder }
];
CarouselComponent.propDecorators = {
    showDots: [{ type: Input }],
    dotColor: [{ type: Input }],
    activeDotColor: [{ type: Input }],
    dotAnimationCircleColor: [{ type: Input }],
    activeCarouselElement: [{ type: Input }],
    activeCarouselElementChange: [{ type: Output }],
    initAnimation: [{ type: Input }],
    radius: [{ type: Input }],
    yPosition: [{ type: Input }],
    cameraFov: [{ type: Input }],
    cameraDistance: [{ type: Input }],
    autoPlay: [{ type: Input }],
    autoPlayInterval: [{ type: Input }],
    rotationDuration: [{ type: Input }],
    threejsContainer: [{ type: ViewChild, args: ['threejsContainer',] }],
    dots: [{ type: ViewChild, args: ['indicationDots',] }],
    carouselItemTemplates: [{ type: ContentChildren, args: [CarouselItem,] }],
    resize: [{ type: HostListener, args: ['window:resize',] }]
};

class CarouselModule {
}
CarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CarouselComponent, CarouselItem],
                imports: [
                    CommonModule
                ],
                exports: [CarouselComponent, CarouselItem]
            },] }
];

/*
 * Public API Surface of ngx-acuw
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CarouselComponent, CarouselItem, CarouselModule, ImageAsParticlesComponent, ImageAsParticlesModule, ImageTransitionComponent, ImageTransitionModule, LightboxComponent, LightboxModule, LightboxOverlayComponent as ɵa };
//# sourceMappingURL=ngx-acuw.js.map
