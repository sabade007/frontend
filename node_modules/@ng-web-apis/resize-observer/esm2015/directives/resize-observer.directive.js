/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Attribute, Directive, ElementRef, Inject, Output } from '@angular/core';
import { Observable } from 'rxjs';
import { ResizeObserverService } from '../services/resize-observer.service';
import { RESIZE_OPTION_BOX, RESIZE_OPTION_BOX_DEFAULT } from '../tokens/resize-option-box';
// TODO switch to Attribute once https://github.com/angular/angular/issues/36479 is fixed
/**
 * @param {?} __0
 * @return {?}
 */
export function boxExtractor({ nativeElement, }) {
    /** @type {?} */
    const attribute = (/** @type {?} */ (nativeElement.getAttribute('waResizeBox')));
    return boxFactory(attribute);
}
/**
 * @param {?} box
 * @return {?}
 */
export function boxFactory(box) {
    return box || RESIZE_OPTION_BOX_DEFAULT;
}
// @dynamic
export class ResizeObserverDirective {
    /**
     * @param {?} entries$
     * @param {?} _box
     */
    constructor(entries$, _box) {
        this.waResizeObserver = entries$;
    }
}
ResizeObserverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[waResizeObserver]',
                providers: [
                    ResizeObserverService,
                    {
                        provide: RESIZE_OPTION_BOX,
                        deps: [ElementRef],
                        useFactory: boxExtractor,
                    },
                ],
            },] }
];
/** @nocollapse */
ResizeObserverDirective.ctorParameters = () => [
    { type: Observable, decorators: [{ type: Inject, args: [ResizeObserverService,] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['waResizeBox',] }] }
];
ResizeObserverDirective.propDecorators = {
    waResizeObserver: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    ResizeObserverDirective.prototype.waResizeObserver;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLW9ic2VydmVyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZy13ZWItYXBpcy9yZXNpemUtb2JzZXJ2ZXIvIiwic291cmNlcyI6WyJkaXJlY3RpdmVzL3Jlc2l6ZS1vYnNlcnZlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDaEMsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0scUNBQXFDLENBQUM7QUFDMUUsT0FBTyxFQUFDLGlCQUFpQixFQUFFLHlCQUF5QixFQUFDLE1BQU0sNkJBQTZCLENBQUM7Ozs7OztBQUd6RixNQUFNLFVBQVUsWUFBWSxDQUFDLEVBQ3pCLGFBQWEsR0FDSzs7VUFDWixTQUFTLEdBQUcsbUJBQUEsYUFBYSxDQUFDLFlBQVksQ0FDeEMsYUFBYSxDQUNoQixFQUFnQztJQUVqQyxPQUFPLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNqQyxDQUFDOzs7OztBQUVELE1BQU0sVUFBVSxVQUFVLENBQ3RCLEdBQXdDO0lBRXhDLE9BQU8sR0FBRyxJQUFJLHlCQUF5QixDQUFDO0FBQzVDLENBQUM7O0FBY0QsTUFBTSxPQUFPLHVCQUF1Qjs7Ozs7SUFJaEMsWUFFSSxRQUEyQyxFQUNqQixJQUFrQztRQUU1RCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDO0lBQ3JDLENBQUM7OztZQXJCSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsU0FBUyxFQUFFO29CQUNQLHFCQUFxQjtvQkFDckI7d0JBQ0ksT0FBTyxFQUFFLGlCQUFpQjt3QkFDMUIsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDO3dCQUNsQixVQUFVLEVBQUUsWUFBWTtxQkFDM0I7aUJBQ0o7YUFDSjs7OztZQWhDTyxVQUFVLHVCQXNDVCxNQUFNLFNBQUMscUJBQXFCOzRDQUU1QixTQUFTLFNBQUMsYUFBYTs7OytCQU4zQixNQUFNOzs7O0lBQVAsbURBQzZEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBdHRyaWJ1dGUsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7UmVzaXplT2JzZXJ2ZXJTZXJ2aWNlfSBmcm9tICcuLi9zZXJ2aWNlcy9yZXNpemUtb2JzZXJ2ZXIuc2VydmljZSc7XG5pbXBvcnQge1JFU0laRV9PUFRJT05fQk9YLCBSRVNJWkVfT1BUSU9OX0JPWF9ERUZBVUxUfSBmcm9tICcuLi90b2tlbnMvcmVzaXplLW9wdGlvbi1ib3gnO1xuXG4vLyBUT0RPIHN3aXRjaCB0byBBdHRyaWJ1dGUgb25jZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zNjQ3OSBpcyBmaXhlZFxuZXhwb3J0IGZ1bmN0aW9uIGJveEV4dHJhY3Rvcih7XG4gICAgbmF0aXZlRWxlbWVudCxcbn06IEVsZW1lbnRSZWY8RWxlbWVudD4pOiBSZXNpemVPYnNlcnZlck9wdGlvbnNbJ2JveCddIHtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuYXRpdmVFbGVtZW50LmdldEF0dHJpYnV0ZShcbiAgICAgICAgJ3dhUmVzaXplQm94JyxcbiAgICApIGFzIFJlc2l6ZU9ic2VydmVyT3B0aW9uc1snYm94J107XG5cbiAgICByZXR1cm4gYm94RmFjdG9yeShhdHRyaWJ1dGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm94RmFjdG9yeShcbiAgICBib3g6IFJlc2l6ZU9ic2VydmVyT3B0aW9uc1snYm94J10gfCBudWxsLFxuKTogUmVzaXplT2JzZXJ2ZXJPcHRpb25zWydib3gnXSB7XG4gICAgcmV0dXJuIGJveCB8fCBSRVNJWkVfT1BUSU9OX0JPWF9ERUZBVUxUO1xufVxuXG4vLyBAZHluYW1pY1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbd2FSZXNpemVPYnNlcnZlcl0nLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBSZXNpemVPYnNlcnZlclNlcnZpY2UsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFJFU0laRV9PUFRJT05fQk9YLFxuICAgICAgICAgICAgZGVwczogW0VsZW1lbnRSZWZdLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogYm94RXh0cmFjdG9yLFxuICAgICAgICB9LFxuICAgIF0sXG59KVxuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmVyRGlyZWN0aXZlIHtcbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSB3YVJlc2l6ZU9ic2VydmVyOiBPYnNlcnZhYmxlPFJlc2l6ZU9ic2VydmVyRW50cnlbXT47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChSZXNpemVPYnNlcnZlclNlcnZpY2UpXG4gICAgICAgIGVudHJpZXMkOiBPYnNlcnZhYmxlPFJlc2l6ZU9ic2VydmVyRW50cnlbXT4sXG4gICAgICAgIEBBdHRyaWJ1dGUoJ3dhUmVzaXplQm94JykgX2JveDogUmVzaXplT2JzZXJ2ZXJPcHRpb25zWydib3gnXSxcbiAgICApIHtcbiAgICAgICAgdGhpcy53YVJlc2l6ZU9ic2VydmVyID0gZW50cmllcyQ7XG4gICAgfVxufVxuIl19