import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';
import { InjectionToken, Attribute, Directive, Inject, Optional, ElementRef, Injectable, NgModule, inject } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_ROOT = new InjectionToken('Root element for IntersectionObserver');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_ROOT_MARGIN_DEFAULT = '0px 0px 0px 0px';
/** @type {?} */
const INTERSECTION_ROOT_MARGIN = new InjectionToken('rootMargin for IntersectionObserver', {
    providedIn: 'root',
    factory: () => INTERSECTION_ROOT_MARGIN_DEFAULT,
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} rootMargin
 * @return {?}
 */
function rootMarginFactory(rootMargin) {
    return rootMargin || INTERSECTION_ROOT_MARGIN_DEFAULT;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_THRESHOLD_DEFAULT = 0;
/** @type {?} */
const INTERSECTION_THRESHOLD = new InjectionToken('threshold for IntersectionObserver', {
    providedIn: 'root',
    factory: () => INTERSECTION_THRESHOLD_DEFAULT,
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} threshold
 * @return {?}
 */
function thresholdFactory(threshold) {
    return threshold
        ? threshold.split(',').map(parseFloat)
        : INTERSECTION_THRESHOLD_DEFAULT;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserverDirective extends IntersectionObserver {
    /**
     * @param {?} root
     * @param {?} rootMargin
     * @param {?} threshold
     */
    constructor(root, rootMargin, threshold) {
        super(entries => {
            this.callbacks.forEach((callback, element) => {
                /** @type {?} */
                const filtered = entries.filter(({ target }) => target === element);
                return filtered.length && callback(filtered, this);
            });
        }, {
            root: root && root.nativeElement,
            rootMargin: rootMarginFactory(rootMargin),
            threshold: thresholdFactory(threshold),
        });
        this.callbacks = new Map();
    }
    /**
     * @param {?} target
     * @param {?=} callback
     * @return {?}
     */
    observe(target, callback = () => { }) {
        super.observe(target);
        this.callbacks.set(target, callback);
    }
    /**
     * @param {?} target
     * @return {?}
     */
    unobserve(target) {
        super.unobserve(target);
        this.callbacks.delete(target);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.disconnect();
    }
}
IntersectionObserverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[waIntersectionObserver]',
                exportAs: 'IntersectionObserver',
            },] }
];
/** @nocollapse */
IntersectionObserverDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INTERSECTION_ROOT,] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['waIntersectionRootMargin',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['waIntersectionThreshold',] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserveeService extends Observable {
    /**
     * @param {?} __0
     * @param {?} observer
     */
    constructor({ nativeElement }, observer) {
        super(subscriber => {
            observer.observe(nativeElement, entries => {
                subscriber.next(entries);
            });
            return () => {
                observer.unobserve(nativeElement);
            };
        });
        return this.pipe(share());
    }
}
IntersectionObserveeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
IntersectionObserveeService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IntersectionObserverDirective, decorators: [{ type: Inject, args: [IntersectionObserverDirective,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
class IntersectionObserveeDirective {
    /**
     * @param {?} waIntersectionObservee
     */
    constructor(waIntersectionObservee) {
        this.waIntersectionObservee = waIntersectionObservee;
    }
}
IntersectionObserveeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[waIntersectionObservee]',
                outputs: ['waIntersectionObservee'],
                providers: [IntersectionObserveeService],
            },] }
];
/** @nocollapse */
IntersectionObserveeDirective.ctorParameters = () => [
    { type: Observable, decorators: [{ type: Inject, args: [IntersectionObserveeService,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionRootDirective {
}
IntersectionRootDirective.decorators = [
    { type: Directive, args: [{
                selector: '[waIntersectionRoot]',
                providers: [
                    {
                        provide: INTERSECTION_ROOT,
                        useExisting: ElementRef,
                    },
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserverModule {
}
IntersectionObserverModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ],
                exports: [
                    IntersectionObserverDirective,
                    IntersectionObserveeDirective,
                    IntersectionRootDirective,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERSECTION_OBSERVER_SUPPORT = new InjectionToken('Intersection Observer API support', {
    providedIn: 'root',
    factory: () => !!inject(WINDOW).IntersectionObserver,
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IntersectionObserverService extends Observable {
    /**
     * @param {?} __0
     * @param {?} support
     * @param {?} rootMargin
     * @param {?} threshold
     * @param {?} root
     */
    constructor({ nativeElement }, support, rootMargin, threshold, root) {
        super(subscriber => {
            if (!support) {
                subscriber.error('IntersectionObserver is not supported in your browser');
                return;
            }
            /** @type {?} */
            const observer = new IntersectionObserver(entries => {
                subscriber.next(entries);
            }, {
                root: root && root.nativeElement,
                rootMargin,
                threshold,
            });
            observer.observe(nativeElement);
            return () => {
                observer.disconnect();
            };
        });
        return this.pipe(share());
    }
}
IntersectionObserverService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
IntersectionObserverService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [INTERSECTION_OBSERVER_SUPPORT,] }] },
    { type: String, decorators: [{ type: Inject, args: [INTERSECTION_ROOT_MARGIN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [INTERSECTION_THRESHOLD,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INTERSECTION_ROOT,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IntersectionObserveeDirective, IntersectionObserverDirective, IntersectionRootDirective, IntersectionObserverModule, IntersectionObserveeService, IntersectionObserverService, INTERSECTION_ROOT, INTERSECTION_ROOT_MARGIN_DEFAULT, INTERSECTION_ROOT_MARGIN, INTERSECTION_THRESHOLD_DEFAULT, INTERSECTION_THRESHOLD, INTERSECTION_OBSERVER_SUPPORT };

//# sourceMappingURL=ng-web-apis-intersection-observer.js.map