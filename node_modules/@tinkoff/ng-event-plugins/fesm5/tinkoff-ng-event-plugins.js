import { EVENT_MANAGER_PLUGINS } from '@angular/platform-browser';
import { __extends, __read } from 'tslib';
import { Injectable, NgZone, NgModule, Inject } from '@angular/core';
import { EMPTY, concat, defer } from 'rxjs';
import { takeWhile } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: utils/dasharize.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} camel
 * @return {?}
 */
function dasharize(camel) {
    return camel.replace(/[a-z][A-Z]/g, (/**
     * @param {?} letterLetter
     * @return {?}
     */
    function (letterLetter) {
        return letterLetter[0] + "-" + letterLetter[1].toLowerCase();
    }));
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/abstract.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
AbstractEventPlugin = /** @class */ (function () {
    function AbstractEventPlugin() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    AbstractEventPlugin.prototype.supports = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return event.includes(this.modifier);
    };
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} _handler
     * @return {?}
     */
    AbstractEventPlugin.prototype.addGlobalEventListener = /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} _handler
     * @return {?}
     */
    function (_element, _event, _handler) {
        throw new Error("Global event targets are not supported by " + this.modifier + " plugin");
    };
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    AbstractEventPlugin.prototype.unwrap = /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        return event
            .split('.')
            .filter((/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return !_this.modifier.includes(v); }))
            .join('.');
    };
    return AbstractEventPlugin;
}());
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AbstractEventPlugin.prototype.modifier;
    /** @type {?} */
    AbstractEventPlugin.prototype.manager;
    /**
     * @abstract
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    AbstractEventPlugin.prototype.addEventListener = function (element, event, handler) { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/bind.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var BindEventPlugin = /** @class */ (function (_super) {
    __extends(BindEventPlugin, _super);
    function BindEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = '$';
        return _this;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    BindEventPlugin.prototype.addEventListener = /**
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    function (element, event) {
        element[event] = element[event] || EMPTY;
        /** @type {?} */
        var method = this.getMethod(element, event);
        /** @type {?} */
        var zone$ = this.manager.getZone().onStable;
        /** @type {?} */
        var sub = concat(zone$.pipe(takeWhile((/**
         * @return {?}
         */
        function () { return element[event] === EMPTY; }))), defer((/**
         * @return {?}
         */
        function () { return element[event]; }))).subscribe(method);
        return (/**
         * @return {?}
         */
        function () { return sub.unsubscribe(); });
    };
    /**
     * @private
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    BindEventPlugin.prototype.getMethod = /**
     * @private
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    function (element, event) {
        var _a = __read(event.split('.'), 4), key = _a[1], value = _a[2], _b = _a[3], unit = _b === void 0 ? '' : _b;
        if (event.endsWith('.attr')) {
            return (/**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                return v === null
                    ? element.removeAttribute(key)
                    : element.setAttribute(key, String(v));
            });
        }
        if (key === 'class') {
            return (/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return element.classList.toggle(value, !!v); });
        }
        if (key === 'style') {
            return (/**
             * @param {?} v
             * @return {?}
             */
            function (v) { return element.style.setProperty(dasharize(value), "" + v + unit); });
        }
        return (/**
         * @param {?} v
         * @return {?}
         */
        function (v) { return (element[key] = v); });
    };
    BindEventPlugin.decorators = [
        { type: Injectable }
    ];
    return BindEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    BindEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/options.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var OptionsEventPlugin = /** @class */ (function (_super) {
    __extends(OptionsEventPlugin, _super);
    function OptionsEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = 'capture.once.passive';
        return _this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    OptionsEventPlugin.prototype.supports = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        return event.includes('.') && !this.unwrap(event).includes('.');
    };
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    OptionsEventPlugin.prototype.addEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        var _this = this;
        element.addEventListener(this.unwrap(event), handler, {
            once: event.includes('.once'),
            passive: event.includes('.passive'),
            capture: event.includes('.capture'),
        });
        return (/**
         * @return {?}
         */
        function () { return element.removeEventListener(_this.unwrap(event), handler); });
    };
    OptionsEventPlugin.decorators = [
        { type: Injectable }
    ];
    return OptionsEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    OptionsEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/prevent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PreventEventPlugin = /** @class */ (function (_super) {
    __extends(PreventEventPlugin, _super);
    function PreventEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = '.prevent';
        return _this;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    PreventEventPlugin.prototype.addEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        /** @type {?} */
        var wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            handler(event);
        });
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    };
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    PreventEventPlugin.prototype.addGlobalEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        /** @type {?} */
        var wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.preventDefault();
            handler(event);
        });
        return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    };
    PreventEventPlugin.decorators = [
        { type: Injectable }
    ];
    return PreventEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    PreventEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/self.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SelfEventPlugin = /** @class */ (function (_super) {
    __extends(SelfEventPlugin, _super);
    function SelfEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = '.self';
        return _this;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    SelfEventPlugin.prototype.addEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        /** @type {?} */
        var wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.target === event.currentTarget) {
                handler(event);
            }
        });
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    };
    SelfEventPlugin.decorators = [
        { type: Injectable }
    ];
    return SelfEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    SelfEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/silent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SilentEventPlugin = /** @class */ (function (_super) {
    __extends(SilentEventPlugin, _super);
    function SilentEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = '.silent';
        return _this;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    SilentEventPlugin.prototype.addEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        var _this = this;
        return this.manager
            .getZone()
            .runOutsideAngular((/**
         * @return {?}
         */
        function () {
            return _this.manager.addEventListener(element, _this.unwrap(event), handler);
        }));
    };
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    SilentEventPlugin.prototype.addGlobalEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        var _this = this;
        return this.manager
            .getZone()
            .runOutsideAngular((/**
         * @return {?}
         */
        function () {
            return _this.manager.addGlobalEventListener(element, _this.unwrap(event), handler);
        }));
    };
    SilentEventPlugin.decorators = [
        { type: Injectable }
    ];
    return SilentEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    SilentEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/stop.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StopEventPlugin = /** @class */ (function (_super) {
    __extends(StopEventPlugin, _super);
    function StopEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = '.stop';
        return _this;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    StopEventPlugin.prototype.addEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        /** @type {?} */
        var wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            handler(event);
        });
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    };
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    StopEventPlugin.prototype.addGlobalEventListener = /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    function (element, event, handler) {
        /** @type {?} */
        var wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            event.stopPropagation();
            handler(event);
        });
        return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    };
    StopEventPlugin.decorators = [
        { type: Injectable }
    ];
    return StopEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    StopEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/zone.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed in Angular 10
 * when libraries are allowed to use Ivy renderer and markDirty becomes stable API
 */
var ZoneEventPlugin = /** @class */ (function (_super) {
    __extends(ZoneEventPlugin, _super);
    function ZoneEventPlugin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.modifier = '.init';
        return _this;
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    ZoneEventPlugin.prototype.addEventListener = /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    function (_element, _event, handler) {
        return this.handle(handler);
    };
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    ZoneEventPlugin.prototype.addGlobalEventListener = /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    function (_element, _event, handler) {
        return this.handle(handler);
    };
    /**
     * @private
     * @param {?} handler
     * @return {?}
     */
    ZoneEventPlugin.prototype.handle = /**
     * @private
     * @param {?} handler
     * @return {?}
     */
    function (handler) {
        /** @type {?} */
        var zone = this.manager.getZone();
        /** @type {?} */
        var subscription = zone.onStable.subscribe((/**
         * @return {?}
         */
        function () {
            subscription.unsubscribe();
            handler(zone);
        }));
        return (/**
         * @return {?}
         */
        function () { });
    };
    ZoneEventPlugin.decorators = [
        { type: Injectable }
    ];
    return ZoneEventPlugin;
}(AbstractEventPlugin));
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ZoneEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: constants/plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NG_EVENT_PLUGINS = [
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: SilentEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: PreventEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: SelfEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: StopEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: ZoneEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: OptionsEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: BindEventPlugin,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * Generated from: decorators/should-call.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed when markDirty becomes stable API
 * @template T
 * @param {?} predicate
 * @return {?}
 */
function shouldCall(predicate) {
    return (/**
     * @param {?} _
     * @param {?} key
     * @param {?} desc
     * @return {?}
     */
    function (_, key, desc) {
        var value = desc.value;
        desc.value = (/**
         * @this {?}
         * @param {...?} args
         * @return {?}
         */
        function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            /** @type {?} */
            var zone = arguments[0];
            if (zone instanceof NgZone) {
                Object.defineProperty(this, key, {
                    value: /**
                     * @this {?}
                     * @param {...?} args
                     * @return {?}
                     */
                    function () {
                        var _this = this;
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        if (predicate.apply(this, args)) {
                            zone.run((/**
                             * @return {?}
                             */
                            function () {
                                value.apply(_this, args);
                            }));
                        }
                    },
                });
            }
            else if (predicate.apply(this, args)) {
                value.apply(this, args);
            }
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: types/predicate.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: utils/as-callable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} a
 * @return {?}
 */
function asCallable(a) {
    return (/** @type {?} */ (a));
}

/**
 * @fileoverview added by tsickle
 * Generated from: module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @dynamic
var EventPluginsModule = /** @class */ (function () {
    function EventPluginsModule(plugins) {
        console.assert(!(plugins[0] instanceof SilentEventPlugin) || EventPluginsModule.initialized, 'EventPluginsModule must come after BrowserModule in imports');
        EventPluginsModule.initialized = true;
    }
    EventPluginsModule.initialized = false;
    EventPluginsModule.decorators = [
        { type: NgModule, args: [{
                    providers: NG_EVENT_PLUGINS,
                },] }
    ];
    /** @nocollapse */
    EventPluginsModule.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS,] }] }
    ]; };
    return EventPluginsModule;
}());
if (false) {
    /** @type {?} */
    EventPluginsModule.initialized;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: tinkoff-ng-event-plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BindEventPlugin, EventPluginsModule, NG_EVENT_PLUGINS, OptionsEventPlugin, PreventEventPlugin, SilentEventPlugin, StopEventPlugin, ZoneEventPlugin, asCallable, shouldCall, AbstractEventPlugin as ɵa, SelfEventPlugin as ɵb };
//# sourceMappingURL=tinkoff-ng-event-plugins.js.map
