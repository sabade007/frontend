(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ngx-quicklink', ['exports', '@angular/core', '@angular/router', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-quicklink'] = {}, global.ng.core, global.ng.router, global.rxjs));
}(this, (function (exports, core, router, rxjs) { 'use strict';

    // Using a global registry so we can keep it populated across lazy-loaded
    // modules with different parent injectors which create instance of the registry.
    var globalRegistry = [];
    var PrefetchRegistry = /** @class */ (function () {
        function PrefetchRegistry(router) {
            this.router = router;
            this.trees = globalRegistry;
        }
        PrefetchRegistry.prototype.add = function (tree) {
            this.trees.push(tree);
        };
        PrefetchRegistry.prototype.shouldPrefetch = function (url) {
            var tree = this.router.parseUrl(url);
            return this.trees.some(containsTree.bind(null, tree));
        };
        return PrefetchRegistry;
    }());
    PrefetchRegistry.decorators = [
        { type: core.Injectable }
    ];
    PrefetchRegistry.ctorParameters = function () { return [
        { type: router.Router }
    ]; };
    function containsQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return (Object.keys(containee).length <= Object.keys(container).length &&
            Object.keys(containee).every(function (key) { return containee[key] === container[key]; }));
    }
    function containsTree(containee, container) {
        return (containsQueryParams(container.queryParams, containee.queryParams) &&
            containsSegmentGroup(container.root, containee.root, containee.root.segments));
    }
    function containsSegmentGroup(container, containee, containeePaths) {
        if (container.segments.length > containeePaths.length) {
            var current = container.segments.slice(0, containeePaths.length);
            if (!equalPath(current, containeePaths))
                return false;
            if (containee.hasChildren())
                return false;
            return true;
        }
        else if (container.segments.length === containeePaths.length) {
            if (!equalPath(container.segments, containeePaths))
                return false;
            if (!containee.hasChildren())
                return true;
            for (var c in containee.children) {
                if (!container.children[c])
                    break;
                if (containsSegmentGroup(container.children[c], containee.children[c], containee.children[c].segments))
                    return true;
            }
            return false;
        }
        else {
            var current = containeePaths.slice(0, container.segments.length);
            var next = containeePaths.slice(container.segments.length);
            if (!equalPath(container.segments, current))
                return false;
            if (!container.children[router.PRIMARY_OUTLET])
                return false;
            return containsSegmentGroup(container.children[router.PRIMARY_OUTLET], containee, next);
        }
    }
    function equalPath(as, bs) {
        if (as.length !== bs.length)
            return false;
        return as.every(function (a, i) { return a.path === bs[i].path || a.path.startsWith(':') || bs[i].path.startsWith(':'); });
    }

    var ɵ0 = function (cb) {
        var start = Date.now();
        return setTimeout(function () {
            cb({
                didTimeout: false,
                timeRemaining: function () {
                    return Math.max(0, 50 - (Date.now() - start));
                }
            });
        }, 1);
    }, ɵ1 = function () { };
    var requestIdleCallback = typeof window !== 'undefined'
        ? window.requestIdleCallback || ɵ0
        : ɵ1;
    var observerSupported = function () { return typeof window !== 'undefined' ? !!window.IntersectionObserver : false; };
    var ɵ2 = observerSupported;
    var LinkHandler = new core.InjectionToken('LinkHandler');
    var ObservableLinkHandler = /** @class */ (function () {
        function ObservableLinkHandler(loader, registry, ngZone) {
            var _this = this;
            this.loader = loader;
            this.registry = registry;
            this.ngZone = ngZone;
            this.elementLink = new Map();
            this.observer = observerSupported()
                ? new IntersectionObserver(function (entries) {
                    entries.forEach(function (entry) {
                        if (entry.isIntersecting) {
                            var link = entry.target;
                            var routerLink = _this.elementLink.get(link);
                            if (!routerLink || !routerLink.urlTree)
                                return;
                            _this.registry.add(routerLink.urlTree);
                            _this.observer.unobserve(link);
                            requestIdleCallback(function () {
                                _this.loader.preload().subscribe(function () { return void 0; });
                            });
                        }
                    });
                })
                : null;
        }
        ObservableLinkHandler.prototype.register = function (el) {
            var _this = this;
            this.elementLink.set(el.element, el);
            this.ngZone.runOutsideAngular(function () {
                _this.observer.observe(el.element);
            });
        };
        // First call to unregister will not hit this.
        ObservableLinkHandler.prototype.unregister = function (el) {
            if (this.elementLink.has(el.element)) {
                this.observer.unobserve(el.element);
                this.elementLink.delete(el.element);
            }
        };
        ObservableLinkHandler.prototype.supported = function () {
            return observerSupported();
        };
        return ObservableLinkHandler;
    }());
    ObservableLinkHandler.decorators = [
        { type: core.Injectable }
    ];
    ObservableLinkHandler.ctorParameters = function () { return [
        { type: router.RouterPreloader },
        { type: PrefetchRegistry },
        { type: core.NgZone }
    ]; };
    var PreloadLinkHandler = /** @class */ (function () {
        function PreloadLinkHandler(loader, registry) {
            this.loader = loader;
            this.registry = registry;
        }
        PreloadLinkHandler.prototype.register = function (el) {
            var _this = this;
            this.registry.add(el.urlTree);
            requestIdleCallback(function () { return _this.loader.preload().subscribe(function () { return void 0; }); });
        };
        PreloadLinkHandler.prototype.unregister = function (_) { };
        PreloadLinkHandler.prototype.supported = function () {
            return true;
        };
        return PreloadLinkHandler;
    }());
    PreloadLinkHandler.decorators = [
        { type: core.Injectable }
    ];
    PreloadLinkHandler.ctorParameters = function () { return [
        { type: router.RouterPreloader },
        { type: PrefetchRegistry }
    ]; };

    var LinkDirective = /** @class */ (function () {
        function LinkDirective(linkHandlers, el, link, linkWithHref) {
            this.linkHandlers = linkHandlers;
            this.el = el;
            this.linkHandler = this.linkHandlers.filter(function (h) { return h.supported(); }).shift();
            this.rl = link || linkWithHref;
            if (this.element && this.element.setAttribute) {
                this.element.setAttribute('ngx-ql', '');
            }
        }
        LinkDirective.prototype.ngOnChanges = function (c) {
            if (c.routerLink) {
                this.linkHandler.unregister(this);
                this.linkHandler.register(this);
            }
        };
        LinkDirective.prototype.ngOnDestroy = function () {
            this.linkHandler.unregister(this);
        };
        Object.defineProperty(LinkDirective.prototype, "element", {
            get: function () {
                return this.el.nativeElement;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LinkDirective.prototype, "urlTree", {
            get: function () {
                return this.rl.urlTree;
            },
            enumerable: false,
            configurable: true
        });
        return LinkDirective;
    }());
    LinkDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[routerLink]'
                },] }
    ];
    LinkDirective.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: core.Inject, args: [LinkHandler,] }] },
        { type: core.ElementRef },
        { type: router.RouterLink, decorators: [{ type: core.Optional }] },
        { type: router.RouterLinkWithHref, decorators: [{ type: core.Optional }] }
    ]; };
    LinkDirective.propDecorators = {
        routerLink: [{ type: core.Input }]
    };

    var QuicklinkStrategy = /** @class */ (function () {
        function QuicklinkStrategy(registry, router) {
            this.registry = registry;
            this.router = router;
            this.loading = new Set();
        }
        QuicklinkStrategy.prototype.preload = function (route, load) {
            if (this.loading.has(route)) {
                // Don't preload the same route twice
                return rxjs.EMPTY;
            }
            var conn = typeof navigator !== 'undefined' ? navigator.connection : undefined;
            if (conn) {
                // Don't preload if the user is on 2G. or if Save-Data is enabled..
                if ((conn.effectiveType || '').includes('2g') || conn.saveData)
                    return rxjs.EMPTY;
            }
            // Prevent from preloading
            if (route.data && route.data.preload === false) {
                return rxjs.EMPTY;
            }
            var fullPath = findPath(this.router.config, route);
            if (this.registry.shouldPrefetch(fullPath)) {
                this.loading.add(route);
                return load();
            }
            return rxjs.EMPTY;
        };
        return QuicklinkStrategy;
    }());
    QuicklinkStrategy.decorators = [
        { type: core.Injectable }
    ];
    QuicklinkStrategy.ctorParameters = function () { return [
        { type: PrefetchRegistry },
        { type: router.Router }
    ]; };
    var findPath = function (config, route) {
        config = config.slice();
        var parent = new Map();
        var visited = new Set();
        var _loop_1 = function () {
            var el = config.shift();
            visited.add(el);
            if (el === route)
                return "break";
            var children = el.children || [];
            var current_1 = el._loadedConfig;
            if (current_1 && current_1.routes) {
                children = children.concat(current_1.routes);
            }
            children.forEach(function (r) {
                if (visited.has(r))
                    return;
                parent.set(r, el);
                config.push(r);
            });
        };
        while (config.length) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        var path = '';
        var current = route;
        while (current) {
            if (isPrimaryRoute(current)) {
                path = "/" + current.path + path;
            }
            else {
                path = "/(" + current.outlet + ":" + current.path + path + ")";
            }
            current = parent.get(current);
        }
        return path.replace(/\/\//, '/');
    };
    var ɵ0$1 = findPath;
    function isPrimaryRoute(route) {
        return route.outlet === router.PRIMARY_OUTLET || !route.outlet;
    }

    var QuicklinkModule = /** @class */ (function () {
        function QuicklinkModule() {
        }
        return QuicklinkModule;
    }());
    QuicklinkModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [LinkDirective],
                    providers: [
                        {
                            provide: LinkHandler,
                            useClass: ObservableLinkHandler,
                            multi: true
                        },
                        {
                            provide: LinkHandler,
                            useClass: PreloadLinkHandler,
                            multi: true
                        },
                        PrefetchRegistry,
                        QuicklinkStrategy
                    ],
                    exports: [LinkDirective]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.QuicklinkModule = QuicklinkModule;
    exports.QuicklinkStrategy = QuicklinkStrategy;
    exports.ɵa = LinkHandler;
    exports.ɵb = ObservableLinkHandler;
    exports.ɵc = PreloadLinkHandler;
    exports.ɵe = PrefetchRegistry;
    exports.ɵɵLinkDirective = LinkDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-quicklink.umd.js.map
