"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sharePackages = exports.getNpmPackageSharedConfig = exports.shareWorkspaceLibraries = void 0;
const devkit_1 = require("@nrwl/devkit");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const fs_1 = require("fs");
const path_1 = require("path");
const webpack_1 = require("webpack");
const utils_1 = require("./utils");
function shareWorkspaceLibraries(libraries, tsConfigPath) {
    var _a, _b;
    if (tsConfigPath === void 0) { tsConfigPath = (_a = process.env.NX_TSCONFIG_PATH) !== null && _a !== void 0 ? _a : (0, typescript_1.getRootTsConfigPath)(); }
    if (!(0, fs_1.existsSync)(tsConfigPath)) {
        throw new Error(`NX MFE: TsConfig Path for workspace libraries does not exist! (${tsConfigPath})`);
    }
    const tsConfig = (0, typescript_1.readTsConfig)(tsConfigPath);
    const tsconfigPathAliases = (_b = tsConfig.options) === null || _b === void 0 ? void 0 : _b.paths;
    if (!tsconfigPathAliases) {
        return {
            getAliases: () => [],
            getLibraries: () => ({}),
            getReplacementPlugin: () => new webpack_1.NormalModuleReplacementPlugin(/./, () => { }),
        };
    }
    const pathMappings = [];
    for (const [key, paths] of Object.entries(tsconfigPathAliases)) {
        if (libraries && libraries.includes(key)) {
            const pathToLib = (0, path_1.normalize)((0, path_1.join)(devkit_1.workspaceRoot, paths[0]));
            pathMappings.push({
                name: key,
                path: pathToLib,
            });
        }
    }
    return {
        getAliases: () => pathMappings.reduce((aliases, library) => (Object.assign(Object.assign({}, aliases), { [library.name]: library.path })), {}),
        getLibraries: (eager) => pathMappings.reduce((libraries, library) => (Object.assign(Object.assign({}, libraries), { [library.name]: { requiredVersion: false, eager } })), {}),
        getReplacementPlugin: () => new webpack_1.NormalModuleReplacementPlugin(/./, (req) => {
            if (!req.request.startsWith('.')) {
                return;
            }
            const from = req.context;
            const to = (0, path_1.normalize)((0, path_1.join)(req.context, req.request));
            for (const library of pathMappings) {
                const libFolder = (0, path_1.normalize)((0, path_1.dirname)(library.path));
                if (!from.startsWith(libFolder) &&
                    to.startsWith(libFolder) &&
                    !library.name.endsWith('/*')) {
                    req.request = library.name;
                }
            }
        }),
    };
}
exports.shareWorkspaceLibraries = shareWorkspaceLibraries;
function getNonNodeModulesSubDirs(directory) {
    return (0, fs_1.readdirSync)(directory)
        .filter((file) => file !== 'node_modules')
        .map((file) => (0, path_1.join)(directory, file))
        .filter((file) => (0, fs_1.lstatSync)(file).isDirectory());
}
function recursivelyCollectSecondaryEntryPointsFromDirectory(pkgName, pkgVersion, pkgRoot, directories, collectedPackages) {
    for (const directory of directories) {
        const packageJsonPath = (0, path_1.join)(directory, 'package.json');
        if ((0, fs_1.existsSync)(packageJsonPath)) {
            const importName = (0, devkit_1.joinPathFragments)(pkgName, (0, path_1.relative)(pkgRoot, directory));
            try {
                // require the secondary entry point to try to rule out sample code
                require.resolve(importName, { paths: [devkit_1.workspaceRoot] });
                const { name } = (0, devkit_1.readJsonFile)(packageJsonPath);
                // further check to make sure what we were able to require is the
                // same as the package name
                if (name === importName) {
                    collectedPackages.push({ name, version: pkgVersion });
                }
            }
            catch (_a) { }
        }
        const subDirs = getNonNodeModulesSubDirs(directory);
        recursivelyCollectSecondaryEntryPointsFromDirectory(pkgName, pkgVersion, pkgRoot, subDirs, collectedPackages);
    }
}
function collectPackageSecondaryEntryPoints(pkgName, pkgVersion, collectedPackages) {
    let pathToPackage;
    try {
        const packageJsonPath = require.resolve(`${pkgName}/package.json`, {
            paths: [devkit_1.workspaceRoot],
        });
        pathToPackage = (0, path_1.dirname)(packageJsonPath);
    }
    catch (_a) {
        // the package.json might not resolve if the package has the "exports"
        // entry and is not exporting the package.json file, fall back to trying
        // to find it from the top-level node_modules
        pathToPackage = (0, path_1.join)(devkit_1.workspaceRoot, 'node_modules', pkgName);
        if (!(0, fs_1.existsSync)((0, path_1.join)(pathToPackage, 'package.json'))) {
            // might not exist if it's nested in another package, just return here
            return;
        }
    }
    const subDirs = getNonNodeModulesSubDirs(pathToPackage);
    recursivelyCollectSecondaryEntryPointsFromDirectory(pkgName, pkgVersion, pathToPackage, subDirs, collectedPackages);
}
function getNpmPackageSharedConfig(pkgName, version) {
    if (!version) {
        devkit_1.logger.warn(`Could not find a version for "${pkgName}" in the root "package.json" ` +
            'when collecting shared packages for the Module Federation setup. ' +
            'The package will not be shared.');
        return undefined;
    }
    return { singleton: true, strictVersion: true, requiredVersion: version };
}
exports.getNpmPackageSharedConfig = getNpmPackageSharedConfig;
function sharePackages(packages) {
    const pkgJson = (0, utils_1.readRootPackageJson)();
    const allPackages = [];
    packages.forEach((pkg) => {
        var _a, _b, _c;
        const pkgVersion = (_b = (_a = pkgJson.dependencies) === null || _a === void 0 ? void 0 : _a[pkg]) !== null && _b !== void 0 ? _b : (_c = pkgJson.devDependencies) === null || _c === void 0 ? void 0 : _c[pkg];
        allPackages.push({ name: pkg, version: pkgVersion });
        collectPackageSecondaryEntryPoints(pkg, pkgVersion, allPackages);
    });
    return allPackages.reduce((shared, pkg) => {
        const config = getNpmPackageSharedConfig(pkg.name, pkg.version);
        if (config) {
            shared[pkg.name] = config;
        }
        return shared;
    }, {});
}
exports.sharePackages = sharePackages;
//# sourceMappingURL=mfe-webpack.js.map