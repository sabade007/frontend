"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.E2eMigrator = void 0;
const tslib_1 = require("tslib");
const cypress_1 = require("@nrwl/cypress");
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const path_1 = require("path");
const project_migrator_1 = require("./project.migrator");
const supportedTargets = {
    e2e: {
        acceptMultipleDefinitions: true,
        builders: [
            '@angular-devkit/build-angular:protractor',
            '@cypress/schematic:cypress',
        ],
    },
};
class E2eMigrator extends project_migrator_1.ProjectMigrator {
    constructor(tree, options, project, lintTargetName, logger) {
        var _a;
        super(tree, options, supportedTargets, project, 'apps', logger);
        this.lintTargetName = lintTargetName;
        this.appConfig = project.config;
        this.appName = this.project.name;
        // TODO(leo): temporary keep restriction to support projects with an "e2e" target,
        // will be lifted soon when the migration is split per-builder and proper support
        // for multiple targets for the same builder is added
        this.targetNames.e2e = ((_a = this.appConfig.targets) === null || _a === void 0 ? void 0 : _a.e2e) ? 'e2e' : undefined;
        this.initialize();
    }
    migrate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.targetNames.e2e) {
                this.logger.info('No e2e project was migrated because there was no "e2e" target declared in the "angular.json".');
                return;
            }
            if (this.isProtractorE2eProject()) {
                yield this.migrateProtractorE2eProject();
            }
            else if (this.isCypressE2eProject()) {
                yield this.migrateCypressE2eProject();
            }
            const tsConfig = (0, devkit_1.joinPathFragments)(this.projectConfig.root, 'tsconfig.json');
            if (!this.tree.exists(tsConfig)) {
                this.logger.warn('A "tsconfig.json" file could not be found for the e2e project. Skipping updating the tsConfig file.');
                return;
            }
            const rootOffset = (0, devkit_1.offsetFromRoot)(this.project.newRoot);
            (0, devkit_1.updateJson)(this.tree, tsConfig, (json) => {
                json.extends = `${rootOffset}${(0, typescript_1.getRootTsConfigPathInTree)(this.tree)}`;
                json.compilerOptions = Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${rootOffset}dist/out-tsc` });
                return json;
            });
        });
    }
    validate() {
        var _a;
        if (!this.targetNames.e2e) {
            return null;
        }
        const e2eTarget = this.projectConfig.targets[this.targetNames.e2e];
        if (!e2eTarget.options) {
            return [
                {
                    message: `The "${this.targetNames.e2e}" target is not specifying any options.`,
                    hint: `Make sure the "${this.appName}.architect.e2e.options" is correctly set ` +
                        `or remove the "${this.appName}.architect.e2e" target if it is not valid.`,
                },
            ];
        }
        if (this.isProtractorE2eProject()) {
            if (!e2eTarget.options.protractorConfig) {
                return [
                    {
                        message: 'The "e2e" target is using the "@angular-devkit/build-angular:protractor" builder but the Protractor config file is not specified.',
                        hint: `Make sure the "${this.appName}.architect.e2e.options.protractorConfig" is correctly set ` +
                            `or remove the "${this.appName}.architect.e2e" target if it is not valid.`,
                    },
                ];
            }
            if (!this.tree.exists(e2eTarget.options.protractorConfig)) {
                return [
                    {
                        message: `The specified Protractor config file "${e2eTarget.options.protractorConfig}" in the "e2e" target could not be found.`,
                        hint: `Make sure the "${this.appName}.architect.e2e.options.protractorConfig" is set to a valid path ` +
                            `or remove the "${this.appName}.architect.e2e" target if it is not valid.`,
                    },
                ];
            }
            return null;
        }
        if (this.isCypressE2eProject()) {
            const configFile = (_a = this.projectConfig.targets[this.targetNames.e2e].options) === null || _a === void 0 ? void 0 : _a.configFile;
            if (configFile === undefined &&
                !this.tree.exists((0, devkit_1.joinPathFragments)(this.project.oldRoot, 'cypress.json'))) {
                return [
                    {
                        message: `The "e2e" target is using the "@cypress/schematic:cypress" builder but the "configFile" option is not specified ` +
                            `and a "cypress.json" file could not be found at the project root.`,
                        hint: `Make sure the "${this.appName}.architect.e2e.options.configFile" option is set to a valid path, ` +
                            `or that a "cypress.json" file exists at the project root, ` +
                            `or remove the "${this.appName}.architect.e2e" target if it is not valid.`,
                    },
                ];
            }
            else if (configFile && !this.tree.exists(configFile)) {
                return [
                    {
                        message: `The specified Cypress config file "${configFile}" in the "e2e" target could not be found.`,
                        hint: `Make sure the "${this.appName}.architect.e2e.options.configFile" option is set to a valid path ` +
                            `or remove the "${this.appName}.architect.e2e" target if it is not valid.`,
                    },
                ];
            }
            if (!this.tree.exists((0, devkit_1.joinPathFragments)(this.project.oldRoot, 'cypress'))) {
                return [
                    {
                        message: `The "e2e" target is using the "@cypress/schematic:cypress" builder but the "cypress" directory could not be found at the project root.`,
                        hint: 'Make sure the "cypress" directory exists in the project root or remove the "e2e" target if it is not valid.',
                    },
                ];
            }
            return null;
        }
        return null;
    }
    initialize() {
        if (!this.targetNames.e2e) {
            return;
        }
        this.isProjectUsingEsLint =
            Boolean(this.lintTargetName) ||
                this.tree.exists((0, devkit_1.joinPathFragments)(this.appConfig.root, '.eslintrc.json'));
        const name = this.project.name.endsWith('-e2e')
            ? this.project.name
            : `${this.project.name}-e2e`;
        const newRoot = (0, devkit_1.joinPathFragments)('apps', name);
        const newSourceRoot = (0, devkit_1.joinPathFragments)('apps', name, 'src');
        if (this.isProtractorE2eProject()) {
            this.project = Object.assign(Object.assign({}, this.project), { name, oldRoot: (0, devkit_1.joinPathFragments)(this.project.oldRoot, 'e2e'), newRoot,
                newSourceRoot });
        }
        else if (this.isCypressE2eProject()) {
            this.project = Object.assign(Object.assign({}, this.project), { name, oldSourceRoot: (0, devkit_1.joinPathFragments)(this.project.oldRoot, 'cypress'), newRoot,
                newSourceRoot });
        }
    }
    migrateProtractorE2eProject() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.moveDir(this.project.oldRoot, this.project.newRoot);
            this.projectConfig = {
                root: this.project.newRoot,
                sourceRoot: this.project.newSourceRoot,
                projectType: 'application',
                targets: {
                    e2e: Object.assign(Object.assign({}, this.projectConfig.targets[this.targetNames.e2e]), { options: Object.assign(Object.assign({}, this.projectConfig.targets[this.targetNames.e2e].options), { protractorConfig: this.convertRootPath(this.projectConfig.targets[this.targetNames.e2e].options
                                .protractorConfig) }) }),
                },
                implicitDependencies: [this.appName],
                tags: [],
            };
            // remove e2e target from the app config
            delete this.appConfig.targets[this.targetNames.e2e];
            (0, devkit_1.updateProjectConfiguration)(this.tree, this.appName, Object.assign({}, this.appConfig));
            // add e2e project config
            (0, devkit_1.addProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig), true);
            if (this.isProjectUsingEsLint) {
                yield (0, linter_1.lintProjectGenerator)(this.tree, {
                    project: this.project.name,
                    linter: linter_1.Linter.EsLint,
                    eslintFilePatterns: [`${this.project.newRoot}/**/*.{js,ts}`],
                    tsConfigPaths: [
                        (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.json'),
                    ],
                    skipFormat: true,
                });
            }
        });
    }
    migrateCypressE2eProject() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const oldCypressConfigFilePath = this.getCypressConfigFile();
            yield (0, cypress_1.cypressProjectGenerator)(this.tree, {
                name: this.project.name,
                project: this.appName,
                linter: this.isProjectUsingEsLint ? linter_1.Linter.EsLint : linter_1.Linter.None,
                standaloneConfig: true,
                skipFormat: true,
            });
            const cypressConfigFilePath = this.updateOrCreateCypressConfigFile(oldCypressConfigFilePath);
            this.updateCypressProjectConfiguration(cypressConfigFilePath);
            // replace the generated tsconfig.json with the project one
            const newTsConfigPath = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.json');
            this.tree.delete(newTsConfigPath);
            this.moveFile((0, devkit_1.joinPathFragments)(this.project.oldSourceRoot, 'tsconfig.json'), newTsConfigPath);
            // replace the generated source with the project source
            (0, devkit_1.visitNotIgnoredFiles)(this.tree, this.project.newSourceRoot, (filePath) => {
                this.tree.delete(filePath);
            });
            this.moveDir(this.project.oldSourceRoot, (0, devkit_1.joinPathFragments)(this.project.newSourceRoot));
        });
    }
    updateOrCreateCypressConfigFile(configFile) {
        let cypressConfigFilePath;
        if (configFile) {
            cypressConfigFilePath = (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(configFile));
            this.updateCypressConfigFilePaths(configFile);
            this.tree.delete(cypressConfigFilePath);
            this.moveFile(configFile, cypressConfigFilePath);
        }
        else {
            cypressConfigFilePath = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'cypress.json');
            (0, devkit_1.writeJson)(this.tree, cypressConfigFilePath, {
                fileServerFolder: '.',
                fixturesFolder: './src/fixtures',
                integrationFolder: './src/integration',
                modifyObstructiveCode: false,
                supportFile: './src/support/index.ts',
                pluginsFile: './src/plugins/index.ts',
                video: true,
                videosFolder: `../../dist/cypress/${this.project.newRoot}/videos`,
                screenshotsFolder: `../../dist/cypress/${this.project.newRoot}/screenshots`,
                chromeWebSecurity: false,
            });
        }
        return cypressConfigFilePath;
    }
    updateCypressProjectConfiguration(cypressConfigPath) {
        /**
         * The `cypressProjectGenerator` function normalizes the project name. The
         * migration keeps the names for existing projects as-is to avoid any
         * confusion. The e2e project is technically new, but it's associated
         * to an existing application, so we keep it familiar.
         */
        const generatedProjectName = (0, devkit_1.names)(this.project.name).fileName;
        if (this.project.name !== generatedProjectName) {
            // If the names are different, we "rename" the newly added project.
            this.projectConfig = (0, devkit_1.readProjectConfiguration)(this.tree, generatedProjectName);
            this.projectConfig.root = this.project.newRoot;
            this.projectConfig.sourceRoot = this.project.newSourceRoot;
            (0, devkit_1.removeProjectConfiguration)(this.tree, generatedProjectName);
            (0, devkit_1.addProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig), true);
        }
        else {
            this.projectConfig = (0, devkit_1.readProjectConfiguration)(this.tree, this.project.name);
        }
        if (this.isProjectUsingEsLint) {
            // the generated cypress project always generates a "lint" target,
            // in case the app was using a different name for it, we use it
            const lintTarget = this.projectConfig.targets.lint;
            if (this.lintTargetName && this.lintTargetName !== 'lint') {
                this.projectConfig.targets[this.lintTargetName] =
                    this.projectConfig.targets.lint;
            }
            lintTarget.options.lintFilePatterns =
                lintTarget.options.lintFilePatterns.map((pattern) => pattern.replace(`apps/${generatedProjectName}`, this.project.newRoot));
        }
        [this.targetNames.e2e, 'cypress-run', 'cypress-open'].forEach((target) => {
            if (this.appConfig.targets[target]) {
                this.projectConfig.targets[target] = this.updateE2eCypressTarget(this.appConfig.targets[target], cypressConfigPath);
            }
        });
        (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
        delete this.appConfig.targets['cypress-run'];
        delete this.appConfig.targets['cypress-open'];
        delete this.appConfig.targets[this.targetNames.e2e];
        (0, devkit_1.updateProjectConfiguration)(this.tree, this.appName, Object.assign({}, this.appConfig));
    }
    updateE2eCypressTarget(existingTarget, cypressConfig) {
        const updatedTarget = Object.assign(Object.assign({}, existingTarget), { executor: '@nrwl/cypress:cypress', options: Object.assign(Object.assign({}, existingTarget.options), { cypressConfig }) });
        delete updatedTarget.options.configFile;
        if (updatedTarget.options.tsConfig) {
            updatedTarget.options.tsConfig = (0, devkit_1.joinPathFragments)(this.project.newRoot, 'tsconfig.json');
        }
        else {
            delete updatedTarget.options.tsConfig;
        }
        return updatedTarget;
    }
    updateCypressConfigFilePaths(configFilePath) {
        const srcFoldersAndFiles = [
            'integrationFolder',
            'supportFile',
            'pluginsFile',
            'fixturesFolder',
        ];
        const distFolders = ['videosFolder', 'screenshotsFolder'];
        const stringOrArrayGlobs = ['ignoreTestFiles', 'testFiles'];
        const cypressConfig = (0, devkit_1.readJson)(this.tree, configFilePath);
        cypressConfig.fileServerFolder = '.';
        srcFoldersAndFiles.forEach((folderOrFile) => {
            if (cypressConfig[folderOrFile]) {
                cypressConfig[folderOrFile] = `./src/${(0, path_1.relative)(this.project.oldSourceRoot, cypressConfig[folderOrFile])}`;
            }
        });
        distFolders.forEach((folder) => {
            if (cypressConfig[folder]) {
                cypressConfig[folder] = `../../dist/cypress/${this.project.newRoot}/${(0, path_1.relative)(this.project.oldSourceRoot, cypressConfig[folder])}`;
            }
        });
        stringOrArrayGlobs.forEach((stringOrArrayGlob) => {
            if (!cypressConfig[stringOrArrayGlob]) {
                return;
            }
            if (Array.isArray(cypressConfig[stringOrArrayGlob])) {
                cypressConfig[stringOrArrayGlob] = cypressConfig[stringOrArrayGlob].map((glob) => this.replaceCypressGlobConfig(glob));
            }
            else {
                cypressConfig[stringOrArrayGlob] = this.replaceCypressGlobConfig(cypressConfig[stringOrArrayGlob]);
            }
        });
        (0, devkit_1.writeJson)(this.tree, configFilePath, cypressConfig);
    }
    replaceCypressGlobConfig(globPattern) {
        return globPattern.replace(new RegExp(`^(\\.\\/|\\/)?${this.project.oldSourceRoot}\\/`), './src/');
    }
    getCypressConfigFile() {
        let cypressConfig = (0, devkit_1.joinPathFragments)(this.project.oldRoot, 'cypress.json');
        const configFileOption = this.projectConfig.targets.e2e.options.configFile;
        if (configFileOption === false) {
            cypressConfig = undefined;
        }
        else if (typeof configFileOption === 'string') {
            cypressConfig = (0, path_1.basename)(configFileOption);
        }
        return cypressConfig;
    }
    isCypressE2eProject() {
        return (this.projectConfig.targets[this.targetNames.e2e].executor ===
            '@cypress/schematic:cypress');
    }
    isProtractorE2eProject() {
        return (this.projectConfig.targets[this.targetNames.e2e].executor ===
            '@angular-devkit/build-angular:protractor');
    }
}
exports.E2eMigrator = E2eMigrator;
//# sourceMappingURL=e2e.migrator.js.map