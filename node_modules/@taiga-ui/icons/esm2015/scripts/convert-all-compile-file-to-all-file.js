import { __awaiter } from "tslib";
import { rollup } from 'rollup';
import typescript from 'rollup-plugin-typescript2';
import { rollupSvgo } from './rollup-svgo';
const banner = `
/**
 * @description:
 * DO NOT CHANGE THIS FILE. AUTOGENERATED
 */
`;
export function convertAllCompileFileToAllFile(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, prt2Options } = config;
        const inputOptions = {
            input: from,
            output: { preferConst: true },
            plugins: [
                typescript(prt2Options !== null && prt2Options !== void 0 ? prt2Options : {
                    cacheRoot: `node_modules/.cache/.rpt2_cache`,
                }),
                rollupSvgo({
                    include: `**/*.svg`,
                    options: {
                        plugins: [
                            {
                                name: `preset-default`,
                                params: {
                                    overrides: {
                                        removeViewBox: false,
                                        collapseGroups: false,
                                        cleanupIDs: false,
                                        removeUnknownsAndDefaults: false,
                                    },
                                },
                            },
                        ],
                    },
                }),
            ],
        };
        const bundle = yield rollup(inputOptions);
        yield bundle.write({
            banner,
            file: to,
            format: `es`,
            preferConst: true,
        });
        /**
         * @note:
         * The rollup bundle must be closed once `write` is finished to let plugins clean up their external
         * processes or services via the `closeBundle` hook, otherwise it can lead to memory leaks.
         */
        yield bundle.close();
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC1hbGwtY29tcGlsZS1maWxlLXRvLWFsbC1maWxlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2ljb25zL3NjcmlwdHMvIiwic291cmNlcyI6WyJjb252ZXJ0LWFsbC1jb21waWxlLWZpbGUtdG8tYWxsLWZpbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBUyxNQUFNLEVBQWdCLE1BQU0sUUFBUSxDQUFDO0FBQ3JELE9BQU8sVUFBeUIsTUFBTSwyQkFBMkIsQ0FBQztBQUVsRSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRXpDLE1BQU0sTUFBTSxHQUFHOzs7OztDQUtkLENBQUM7QUFRRixNQUFNLFVBQWdCLDhCQUE4QixDQUFDLE1BQWU7O1FBQ2hFLE1BQU0sRUFBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBQyxHQUFHLE1BQU0sQ0FBQztRQUV2QyxNQUFNLFlBQVksR0FBa0I7WUFDaEMsS0FBSyxFQUFFLElBQUk7WUFDWCxNQUFNLEVBQUUsRUFBQyxXQUFXLEVBQUUsSUFBSSxFQUFDO1lBQzNCLE9BQU8sRUFBRTtnQkFDTCxVQUFVLENBQ04sV0FBVyxhQUFYLFdBQVcsY0FBWCxXQUFXLEdBQUk7b0JBQ1gsU0FBUyxFQUFFLGlDQUFpQztpQkFDL0MsQ0FDTTtnQkFDWCxVQUFVLENBQUM7b0JBQ1AsT0FBTyxFQUFFLFVBQVU7b0JBQ25CLE9BQU8sRUFBRTt3QkFDTCxPQUFPLEVBQUU7NEJBQ0w7Z0NBQ0ksSUFBSSxFQUFFLGdCQUFnQjtnQ0FDdEIsTUFBTSxFQUFFO29DQUNKLFNBQVMsRUFBRTt3Q0FDUCxhQUFhLEVBQUUsS0FBSzt3Q0FDcEIsY0FBYyxFQUFFLEtBQUs7d0NBQ3JCLFVBQVUsRUFBRSxLQUFLO3dDQUNqQix5QkFBeUIsRUFBRSxLQUFLO3FDQUNuQztpQ0FDSjs2QkFDSjt5QkFDSjtxQkFDSjtpQkFDSixDQUFDO2FBQ0w7U0FDSixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQUcsTUFBTSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFMUMsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDO1lBQ2YsTUFBTTtZQUNOLElBQUksRUFBRSxFQUFFO1lBQ1IsTUFBTSxFQUFFLElBQUk7WUFDWixXQUFXLEVBQUUsSUFBSTtTQUNwQixDQUFDLENBQUM7UUFFSDs7OztXQUlHO1FBQ0gsTUFBTSxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDekIsQ0FBQztDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtQbHVnaW4sIHJvbGx1cCwgUm9sbHVwT3B0aW9uc30gZnJvbSAncm9sbHVwJztcbmltcG9ydCB0eXBlc2NyaXB0LCB7UlBUMk9wdGlvbnN9IGZyb20gJ3JvbGx1cC1wbHVnaW4tdHlwZXNjcmlwdDInO1xuXG5pbXBvcnQge3JvbGx1cFN2Z299IGZyb20gJy4vcm9sbHVwLXN2Z28nO1xuXG5jb25zdCBiYW5uZXIgPSBgXG4vKipcbiAqIEBkZXNjcmlwdGlvbjpcbiAqIERPIE5PVCBDSEFOR0UgVEhJUyBGSUxFLiBBVVRPR0VORVJBVEVEXG4gKi9cbmA7XG5cbmludGVyZmFjZSBPcHRpb25zIHtcbiAgICBwcnQyT3B0aW9ucz86IFJQVDJPcHRpb25zO1xuICAgIGZyb206IHN0cmluZztcbiAgICB0bzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udmVydEFsbENvbXBpbGVGaWxlVG9BbGxGaWxlKGNvbmZpZzogT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHtmcm9tLCB0bywgcHJ0Mk9wdGlvbnN9ID0gY29uZmlnO1xuXG4gICAgY29uc3QgaW5wdXRPcHRpb25zOiBSb2xsdXBPcHRpb25zID0ge1xuICAgICAgICBpbnB1dDogZnJvbSxcbiAgICAgICAgb3V0cHV0OiB7cHJlZmVyQ29uc3Q6IHRydWV9LFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICB0eXBlc2NyaXB0KFxuICAgICAgICAgICAgICAgIHBydDJPcHRpb25zID8/IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVSb290OiBgbm9kZV9tb2R1bGVzLy5jYWNoZS8ucnB0Ml9jYWNoZWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICkgYXMgUGx1Z2luLFxuICAgICAgICAgICAgcm9sbHVwU3Znbyh7XG4gICAgICAgICAgICAgICAgaW5jbHVkZTogYCoqLyouc3ZnYCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgcHJlc2V0LWRlZmF1bHRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVZpZXdCb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VHcm91cHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cElEczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVVbmtub3duc0FuZERlZmF1bHRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgfTtcblxuICAgIGNvbnN0IGJ1bmRsZSA9IGF3YWl0IHJvbGx1cChpbnB1dE9wdGlvbnMpO1xuXG4gICAgYXdhaXQgYnVuZGxlLndyaXRlKHtcbiAgICAgICAgYmFubmVyLFxuICAgICAgICBmaWxlOiB0byxcbiAgICAgICAgZm9ybWF0OiBgZXNgLFxuICAgICAgICBwcmVmZXJDb25zdDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBub3RlOlxuICAgICAqIFRoZSByb2xsdXAgYnVuZGxlIG11c3QgYmUgY2xvc2VkIG9uY2UgYHdyaXRlYCBpcyBmaW5pc2hlZCB0byBsZXQgcGx1Z2lucyBjbGVhbiB1cCB0aGVpciBleHRlcm5hbFxuICAgICAqIHByb2Nlc3NlcyBvciBzZXJ2aWNlcyB2aWEgdGhlIGBjbG9zZUJ1bmRsZWAgaG9vaywgb3RoZXJ3aXNlIGl0IGNhbiBsZWFkIHRvIG1lbW9yeSBsZWFrcy5cbiAgICAgKi9cbiAgICBhd2FpdCBidW5kbGUuY2xvc2UoKTtcbn1cbiJdfQ==