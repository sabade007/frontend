import { __assign, __awaiter, __generator, __values } from 'tslib';
import { rollup } from 'rollup';
import typescript from 'rollup-plugin-typescript2';
import { createFilter } from '@rollup/pluginutils';
import { optimize } from 'svgo';
import fs, { unlinkSync, readFileSync, writeFileSync, readdirSync } from 'fs';
import prettier from 'prettier';
import { parse } from 'path';

function rollupSvgo(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.include, include = _c === void 0 ? "**/*.svg" : _c, exclude = _b.exclude, options = _b.options;
    var filter = createFilter(include, exclude);
    return {
        name: "rollupSvgo",
        transform: function (svgString, path) {
            var _a;
            var skip = !filter(path);
            if (skip) {
                console.info("\u001B[33m%s\u001B[0m", "[skip]", path);
                return;
            }
            var data;
            var errorMessage;
            try {
                var result = optimize(svgString, __assign({ path: path }, options));
                data = ((_a = result) === null || _a === void 0 ? void 0 : _a.data) || {};
                errorMessage = result.error;
            }
            catch (err) {
                errorMessage = err.message;
            }
            if (errorMessage) {
                console.error("\u001B[31m%s\u001B[0m", "[error]", path, "\n" + svgString, "\n" + errorMessage);
                process.exit(1);
            }
            console.info("\u001B[32m%s\u001B[0m", "[success]", path);
            return {
                code: "export default " + JSON.stringify(data),
                map: { mappings: "" },
            };
        },
    };
}

var banner = "\n/**\n * @description:\n * DO NOT CHANGE THIS FILE. AUTOGENERATED\n */\n";
function convertAllCompileFileToAllFile(config) {
    return __awaiter(this, void 0, void 0, function () {
        var from, to, prt2Options, inputOptions, bundle;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    from = config.from, to = config.to, prt2Options = config.prt2Options;
                    inputOptions = {
                        input: from,
                        output: { preferConst: true },
                        plugins: [
                            typescript(prt2Options !== null && prt2Options !== void 0 ? prt2Options : {
                                cacheRoot: "node_modules/.cache/.rpt2_cache",
                            }),
                            rollupSvgo({
                                include: "**/*.svg",
                                options: {
                                    plugins: [
                                        {
                                            name: "preset-default",
                                            params: {
                                                overrides: {
                                                    removeViewBox: false,
                                                    collapseGroups: false,
                                                    cleanupIDs: false,
                                                    removeUnknownsAndDefaults: false,
                                                },
                                            },
                                        },
                                    ],
                                },
                            }),
                        ],
                    };
                    return [4 /*yield*/, rollup(inputOptions)];
                case 1:
                    bundle = _a.sent();
                    return [4 /*yield*/, bundle.write({
                            banner: banner,
                            file: to,
                            format: "es",
                            preferConst: true,
                        })];
                case 2:
                    _a.sent();
                    /**
                     * @note:
                     * The rollup bundle must be closed once `write` is finished to let plugins clean up their external
                     * processes or services via the `closeBundle` hook, otherwise it can lead to memory leaks.
                     */
                    return [4 /*yield*/, bundle.close()];
                case 3:
                    /**
                     * @note:
                     * The rollup bundle must be closed once `write` is finished to let plugins clean up their external
                     * processes or services via the `closeBundle` hook, otherwise it can lead to memory leaks.
                     */
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}

/**
 * @deprecated:
 * remove from public later
 */
function deleteAllToCompileFile(allToCompilePath) {
    if (Array.isArray(allToCompilePath)) {
        allToCompilePath.forEach(function (file) { return unlinkSync(file); });
    }
    else {
        unlinkSync(allToCompilePath);
    }
}

function postPrettierFormat(filePath, prettierConfig) {
    var bundledBody = readFileSync(filePath, "utf8");
    var options = prettier.resolveConfig.sync(prettierConfig !== null && prettierConfig !== void 0 ? prettierConfig : "prettier.config.js");
    var formatted = prettier.format(bundledBody, __assign(__assign({}, options), { parser: "typescript" }));
    writeFileSync(filePath, formatted);
}

function prepareAllToCompileFile(iconsSrc, entryPointTs) {
    var e_1, _a;
    var icons = readdirSync(iconsSrc).filter(function (file) { return file.split(".").pop() === "svg"; });
    var importDeclarations = "";
    var exportDeclarations = "";
    try {
        for (var icons_1 = __values(icons), icons_1_1 = icons_1.next(); !icons_1_1.done; icons_1_1 = icons_1.next()) {
            var iconPath = icons_1_1.value;
            var fileName = iconPath.split(".").shift();
            importDeclarations += "import " + fileName + " from './src/" + fileName + ".svg';\n";
            exportDeclarations += fileName + ", ";
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (icons_1_1 && !icons_1_1.done && (_a = icons_1.return)) _a.call(icons_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    writeFileSync(entryPointTs, importDeclarations + " \n export { " + exportDeclarations + " }");
}

var START = "<svg";
var WIDTH_SEARCH = "width=\"";
var HEIGHT_SEARCH = "height=\"";
function processIcons(files, interceptor) {
    var e_1, _a;
    try {
        for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
            var file = files_1_1.value;
            var baseContent = String(fs.readFileSync(file));
            var src = interceptor ? interceptor(baseContent) : baseContent;
            var name_1 = parse(file).base.replace(".svg", "");
            if (src.includes("id=\"" + name_1 + "\"")) {
                console.info("\u001B[33m%s\u001B[0m", "[skip]:", file);
                continue;
            }
            var wrapped = wrapIcon(src, name_1);
            var final = typeof wrapped === "string"
                ? wrapped.replace(START, "<svg xmlns=\"http://www.w3.org/2000/svg\"><g id=\"" + name_1 + "\" xmlns=\"http://www.w3.org/2000/svg\"><svg") + "</g></svg>"
                : "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + wrapped.width + "\" height=\"" + wrapped.height + "\">" + wrapped.src + "</svg>";
            fs.writeFileSync(file, final);
            console.info("\u001B[32m%s\u001B[0m", "[preprocessed]:", file);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function wrapIcon(source, name) {
    var src = source.slice(Math.max(0, source.indexOf(START)));
    var attributes = src.slice(0, Math.max(0, src.indexOf(">")));
    if (!(attributes === null || attributes === void 0 ? void 0 : attributes.includes(WIDTH_SEARCH)) || !attributes.includes(HEIGHT_SEARCH)) {
        return src;
    }
    var indexOfWidth = attributes.indexOf(WIDTH_SEARCH);
    var indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);
    var widthOffset = indexOfWidth + WIDTH_SEARCH.length;
    var heightOffset = indexOfHeight + HEIGHT_SEARCH.length;
    var widthString = attributes.slice(widthOffset, attributes.indexOf("\"", widthOffset));
    var heightString = attributes.slice(heightOffset, attributes.indexOf("\"", heightOffset));
    if (!heightString ||
        !widthString ||
        widthString.includes("%") ||
        heightString.includes("%")) {
        return src.replace(START, "<svg id=\"" + name + "\"");
    }
    var width = parseInt(widthString, 10);
    var height = parseInt(heightString, 10);
    var emWidth = width / 16;
    var emHeight = height / 16;
    return {
        width: emWidth + "em",
        height: emHeight + "em",
        src: ("\n        <g id=\"" + name + "\" xmlns=\"http://www.w3.org/2000/svg\">\n            <svg x=\"50%\" y=\"50%\" width=\"" + emWidth + "em\" height=\"" + emHeight + "em\" overflow=\"visible\" viewBox=\"0 0 " + width + " " + height + "\">\n                <svg x=\"" + -width / 2 + "\" y=\"" + -height / 2 + "\">" + src + "</svg>\n            </svg>\n        </g>").trim(),
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { convertAllCompileFileToAllFile, deleteAllToCompileFile, postPrettierFormat, prepareAllToCompileFile, processIcons, rollupSvgo };
//# sourceMappingURL=taiga-ui-icons-scripts.js.map
