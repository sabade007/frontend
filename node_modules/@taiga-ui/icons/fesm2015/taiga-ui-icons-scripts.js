import { __awaiter } from 'tslib';
import { rollup } from 'rollup';
import typescript from 'rollup-plugin-typescript2';
import { createFilter } from '@rollup/pluginutils';
import { optimize } from 'svgo';
import fs, { unlinkSync, readFileSync, writeFileSync, readdirSync } from 'fs';
import prettier from 'prettier';
import { parse } from 'path';

function rollupSvgo({ include = `**/*.svg`, exclude, options, } = {}) {
    const filter = createFilter(include, exclude);
    return {
        name: `rollupSvgo`,
        transform(svgString, path) {
            var _a;
            const skip = !filter(path);
            if (skip) {
                console.info(`\x1B[33m%s\x1B[0m`, `[skip]`, path);
                return;
            }
            let data;
            let errorMessage;
            try {
                const result = optimize(svgString, Object.assign({ path }, options));
                data = ((_a = result) === null || _a === void 0 ? void 0 : _a.data) || {};
                errorMessage = result.error;
            }
            catch (err) {
                errorMessage = err.message;
            }
            if (errorMessage) {
                console.error(`\x1B[31m%s\x1B[0m`, `[error]`, path, `\n${svgString}`, `\n${errorMessage}`);
                process.exit(1);
            }
            console.info(`\x1B[32m%s\x1B[0m`, `[success]`, path);
            return {
                code: `export default ${JSON.stringify(data)}`,
                map: { mappings: `` },
            };
        },
    };
}

const banner = `
/**
 * @description:
 * DO NOT CHANGE THIS FILE. AUTOGENERATED
 */
`;
function convertAllCompileFileToAllFile(config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { from, to, prt2Options } = config;
        const inputOptions = {
            input: from,
            output: { preferConst: true },
            plugins: [
                typescript(prt2Options !== null && prt2Options !== void 0 ? prt2Options : {
                    cacheRoot: `node_modules/.cache/.rpt2_cache`,
                }),
                rollupSvgo({
                    include: `**/*.svg`,
                    options: {
                        plugins: [
                            {
                                name: `preset-default`,
                                params: {
                                    overrides: {
                                        removeViewBox: false,
                                        collapseGroups: false,
                                        cleanupIDs: false,
                                        removeUnknownsAndDefaults: false,
                                    },
                                },
                            },
                        ],
                    },
                }),
            ],
        };
        const bundle = yield rollup(inputOptions);
        yield bundle.write({
            banner,
            file: to,
            format: `es`,
            preferConst: true,
        });
        /**
         * @note:
         * The rollup bundle must be closed once `write` is finished to let plugins clean up their external
         * processes or services via the `closeBundle` hook, otherwise it can lead to memory leaks.
         */
        yield bundle.close();
    });
}

/**
 * @deprecated:
 * remove from public later
 */
function deleteAllToCompileFile(allToCompilePath) {
    if (Array.isArray(allToCompilePath)) {
        allToCompilePath.forEach(file => unlinkSync(file));
    }
    else {
        unlinkSync(allToCompilePath);
    }
}

function postPrettierFormat(filePath, prettierConfig) {
    const bundledBody = readFileSync(filePath, `utf8`);
    const options = prettier.resolveConfig.sync(prettierConfig !== null && prettierConfig !== void 0 ? prettierConfig : `prettier.config.js`);
    const formatted = prettier.format(bundledBody, Object.assign(Object.assign({}, options), { parser: `typescript` }));
    writeFileSync(filePath, formatted);
}

function prepareAllToCompileFile(iconsSrc, entryPointTs) {
    const icons = readdirSync(iconsSrc).filter(file => file.split(`.`).pop() === `svg`);
    let importDeclarations = ``;
    let exportDeclarations = ``;
    for (const iconPath of icons) {
        const fileName = iconPath.split(`.`).shift();
        importDeclarations += `import ${fileName} from './src/${fileName}.svg';\n`;
        exportDeclarations += `${fileName}, `;
    }
    writeFileSync(entryPointTs, `${importDeclarations} \n export { ${exportDeclarations} }`);
}

const START = `<svg`;
const WIDTH_SEARCH = `width="`;
const HEIGHT_SEARCH = `height="`;
function processIcons(files, interceptor) {
    for (const file of files) {
        const baseContent = String(fs.readFileSync(file));
        const src = interceptor ? interceptor(baseContent) : baseContent;
        const name = parse(file).base.replace(`.svg`, ``);
        if (src.includes(`id="${name}"`)) {
            console.info(`\x1B[33m%s\x1B[0m`, `[skip]:`, file);
            continue;
        }
        const wrapped = wrapIcon(src, name);
        const final = typeof wrapped === `string`
            ? `${wrapped.replace(START, `<svg xmlns="http://www.w3.org/2000/svg"><g id="${name}" xmlns="http://www.w3.org/2000/svg"><svg`)}</g></svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" width="${wrapped.width}" height="${wrapped.height}">${wrapped.src}</svg>`;
        fs.writeFileSync(file, final);
        console.info(`\x1B[32m%s\x1B[0m`, `[preprocessed]:`, file);
    }
}
function wrapIcon(source, name) {
    const src = source.slice(Math.max(0, source.indexOf(START)));
    const attributes = src.slice(0, Math.max(0, src.indexOf(`>`)));
    if (!(attributes === null || attributes === void 0 ? void 0 : attributes.includes(WIDTH_SEARCH)) || !attributes.includes(HEIGHT_SEARCH)) {
        return src;
    }
    const indexOfWidth = attributes.indexOf(WIDTH_SEARCH);
    const indexOfHeight = attributes.indexOf(HEIGHT_SEARCH);
    const widthOffset = indexOfWidth + WIDTH_SEARCH.length;
    const heightOffset = indexOfHeight + HEIGHT_SEARCH.length;
    const widthString = attributes.slice(widthOffset, attributes.indexOf(`"`, widthOffset));
    const heightString = attributes.slice(heightOffset, attributes.indexOf(`"`, heightOffset));
    if (!heightString ||
        !widthString ||
        widthString.includes(`%`) ||
        heightString.includes(`%`)) {
        return src.replace(START, `<svg id="${name}"`);
    }
    const width = parseInt(widthString, 10);
    const height = parseInt(heightString, 10);
    const emWidth = width / 16;
    const emHeight = height / 16;
    return {
        width: `${emWidth}em`,
        height: `${emHeight}em`,
        src: `
        <g id="${name}" xmlns="http://www.w3.org/2000/svg">
            <svg x="50%" y="50%" width="${emWidth}em" height="${emHeight}em" overflow="visible" viewBox="0 0 ${width} ${height}">
                <svg x="${-width / 2}" y="${-height / 2}">${src}</svg>
            </svg>
        </g>`.trim(),
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { convertAllCompileFileToAllFile, deleteAllToCompileFile, postPrettierFormat, prepareAllToCompileFile, processIcons, rollupSvgo };
//# sourceMappingURL=taiga-ui-icons-scripts.js.map
