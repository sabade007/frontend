import { __decorate, __param } from "tslib";
import { ElementRef, Inject, Injectable } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { typedFromEvent } from '@taiga-ui/cdk/observables';
import { defer, merge, Observable } from 'rxjs';
/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiParentsScrollService = class TuiParentsScrollService extends Observable {
    constructor(elementRef, windowRef) {
        super(subscriber => this.callback$.subscribe(subscriber));
        this.callback$ = defer(() => {
            let { nativeElement } = elementRef;
            const eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge(...eventTargets.map(element => typedFromEvent(element, `scroll`)));
        });
    }
};
TuiParentsScrollService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
TuiParentsScrollService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(WINDOW))
], TuiParentsScrollService);
export { TuiParentsScrollService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyZW50cy1zY3JvbGwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvc2VydmljZXMvIiwic291cmNlcyI6WyJwYXJlbnRzLXNjcm9sbC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFOUM7O0dBRUc7QUFDSCw4RkFBOEY7QUFDOUYsV0FBVztBQUVYLElBQWEsdUJBQXVCLEdBQXBDLE1BQWEsdUJBQXdCLFNBQVEsVUFBaUI7SUFHMUQsWUFDd0IsVUFBK0IsRUFDbkMsU0FBaUI7UUFFakMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUUxRCxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUU7WUFDeEIsSUFBSSxFQUFDLGFBQWEsRUFBQyxHQUFHLFVBQVUsQ0FBQztZQUNqQyxNQUFNLFlBQVksR0FBNEIsQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFekUsT0FBTyxhQUFhLENBQUMsYUFBYSxFQUFFO2dCQUNoQyxhQUFhLEdBQUcsYUFBYSxDQUFDLGFBQWEsQ0FBQztnQkFDNUMsWUFBWSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQzthQUNwQztZQUVELE9BQU8sS0FBSyxDQUNSLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBb0IsT0FBTyxDQUFDLEVBQUUsQ0FDN0MsY0FBYyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FDcEMsQ0FDSixDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0NBQ0osQ0FBQTs7WUFyQnVDLFVBQVUsdUJBQXpDLE1BQU0sU0FBQyxVQUFVO1lBQ1MsTUFBTSx1QkFBaEMsTUFBTSxTQUFDLE1BQU07O0FBTFQsdUJBQXVCO0lBRG5DLFVBQVUsRUFBRTtJQUtKLFdBQUEsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ2xCLFdBQUEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0dBTFYsdUJBQXVCLENBeUJuQztTQXpCWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1dJTkRPV30gZnJvbSAnQG5nLXdlYi1hcGlzL2NvbW1vbic7XG5pbXBvcnQge3R5cGVkRnJvbUV2ZW50fSBmcm9tICdAdGFpZ2EtdWkvY2RrL29ic2VydmFibGVzJztcbmltcG9ydCB7ZGVmZXIsIG1lcmdlLCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBTZXJ2aWNlIHRoYXQgc3Vic2NyaWJlcyB0byBzY3JvbGwgZXZlbnRzIG9mIGFsbCBwYXJlbnQgZWxlbWVudHNcbiAqL1xuLy8gQW1iaWVudCB0eXBlIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgZHluYW1pYyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMzM5NVxuLy8gQGR5bmFtaWNcbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUdWlQYXJlbnRzU2Nyb2xsU2VydmljZSBleHRlbmRzIE9ic2VydmFibGU8RXZlbnQ+IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhbGxiYWNrJDogT2JzZXJ2YWJsZTxFdmVudD47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KFdJTkRPVykgd2luZG93UmVmOiBXaW5kb3csXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHN1YnNjcmliZXIgPT4gdGhpcy5jYWxsYmFjayQuc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrJCA9IGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB7bmF0aXZlRWxlbWVudH0gPSBlbGVtZW50UmVmO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUYXJnZXRzOiBBcnJheTxFbGVtZW50IHwgV2luZG93PiA9IFt3aW5kb3dSZWYsIG5hdGl2ZUVsZW1lbnRdO1xuXG4gICAgICAgICAgICB3aGlsZSAobmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldHMucHVzaChuYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlPEV2ZW50PihcbiAgICAgICAgICAgICAgICAuLi5ldmVudFRhcmdldHMubWFwPE9ic2VydmFibGU8RXZlbnQ+PihlbGVtZW50ID0+XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkRnJvbUV2ZW50KGVsZW1lbnQsIGBzY3JvbGxgKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19