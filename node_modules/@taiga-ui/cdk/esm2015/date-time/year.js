import { tuiAssert } from '@taiga-ui/cdk/classes';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DAYS_IN_LEAP_YEAR, DAYS_IN_NORMAL_YEAR, DAYS_IN_WEEK, MAX_YEAR, MIN_YEAR, } from './date-time';
/**
 * Immutable year object
 * @nosideeffects
 */
export class TuiYear {
    constructor(year) {
        this.year = year;
        tuiAssert.assert(TuiYear.isValidYear(year));
    }
    /**
     * Checks year for validity
     */
    static isValidYear(year) {
        return Number.isInteger(year) && inRange(year, MIN_YEAR, MAX_YEAR + 1);
    }
    /**
     * Check if passed year is a leap year
     */
    static isLeapYear(year) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
    }
    /**
     * Returns amount of leap years from year 0 to the passed one
     */
    static getAbsoluteLeapYears(year) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));
    }
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Returns day of week offset of the beginning of the passed year
     *
     * @param year
     * @param absoluteLeapYears amount of leap years prior to the passed one
     * @return offset in days
     */
    static getYearStartDaysOffset(year, absoluteLeapYears) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        tuiAssert.assert(Number.isInteger(absoluteLeapYears));
        tuiAssert.assert(year >= absoluteLeapYears);
        tuiAssert.assert(absoluteLeapYears >= 0);
        return ((absoluteLeapYears * DAYS_IN_LEAP_YEAR +
            (year - absoluteLeapYears) * DAYS_IN_NORMAL_YEAR +
            5) %
            DAYS_IN_WEEK);
    }
    static lengthBetween(from, to) {
        return to.year - from.year;
    }
    /**
     * Normalizes year by clamping it between min and max years
     */
    static normalizeYearPart(year) {
        return normalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);
    }
    get formattedYear() {
        return padStart(String(this.year), 4, `0`);
    }
    get isLeapYear() {
        return TuiYear.isLeapYear(this.year);
    }
    /**
     * Returns amount of leap years from year 0 to current
     */
    get absoluteLeapYears() {
        return TuiYear.getAbsoluteLeapYears(this.year);
    }
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Returns day of week offset of the beginning of the current year
     */
    get yearStartDaysOffset() {
        return TuiYear.getYearStartDaysOffset(this.year, this.absoluteLeapYears);
    }
    /**
     * Passed year is after current
     */
    yearBefore({ year }) {
        return this.year < year;
    }
    /**
     * Passed year is the same or after current
     */
    yearSameOrBefore({ year }) {
        return this.year <= year;
    }
    /**
     * Passed year is the same as current
     */
    yearSame({ year }) {
        return this.year === year;
    }
    /**
     * Passed year is either the same of before the current
     */
    yearSameOrAfter({ year }) {
        return this.year >= year;
    }
    /**
     * Passed year is before current
     */
    yearAfter({ year }) {
        return this.year > year;
    }
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably offsets year
     */
    append({ year = 0 }, backwards = false) {
        tuiAssert.assert(Number.isInteger(year));
        if (backwards) {
            year *= -1;
        }
        const resultYear = this.year + year;
        tuiAssert.assert(TuiYear.isValidYear(resultYear));
        return new TuiYear(resultYear);
    }
    toString() {
        return this.formattedYear;
    }
    valueOf() {
        return this.year;
    }
    /**
     * Returns the primitive value of the given Date object.
     * Depending on the argument, the method can return either a string or a number.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@@toPrimitive
     */
    [Symbol.toPrimitive](hint) {
        return Date.prototype[Symbol.toPrimitive].call(this, hint);
    }
    toJSON() {
        return this.formattedYear;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvZGF0ZS10aW1lLyIsInNvdXJjZXMiOlsieWVhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFaEQsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQ3BELE9BQU8sRUFBQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUV2RSxPQUFPLEVBQ0gsaUJBQWlCLEVBQ2pCLG1CQUFtQixFQUNuQixZQUFZLEVBQ1osUUFBUSxFQUNSLFFBQVEsR0FDWCxNQUFNLGFBQWEsQ0FBQztBQUVyQjs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sT0FBTztJQUNoQixZQUFxQixJQUFZO1FBQVosU0FBSSxHQUFKLElBQUksQ0FBUTtRQUM3QixTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsV0FBVyxDQUFDLElBQVk7UUFDM0IsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLElBQVk7UUFDMUIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFNUMsT0FBTyxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFB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QUNILE1BQU0sQ0FBQyxFQUFDLElBQUksR0FBRyxDQUFDLEVBQWMsRUFBRSxZQUFxQixLQUFLO1FBQ3RELFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXpDLElBQUksU0FBUyxFQUFFO1lBQ1gsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2Q7UUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUVwQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUVsRCxPQUFPLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7SUFFRCxPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBWTtRQUM3QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVELE1BQU07UUFDRixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDOUIsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt0dWlBc3NlcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvY2xhc3Nlcyc7XG5pbXBvcnQge1R1aVllYXJMaWtlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtwYWRTdGFydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9mb3JtYXQnO1xuaW1wb3J0IHtpblJhbmdlLCBub3JtYWxpemVUb0ludE51bWJlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9tYXRoJztcblxuaW1wb3J0IHtcbiAgICBEQVlTX0lOX0xFQVBfWUVBUixcbiAgICBEQVlTX0lOX05PUk1BTF9ZRUFSLFxuICAgIERBWVNfSU5fV0VFSyxcbiAgICBNQVhfWUVBUixcbiAgICBNSU5fWUVBUixcbn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuXG4vKipcbiAqIEltbXV0YWJsZSB5ZWFyIG9iamVjdFxuICogQG5vc2lkZWVmZmVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFR1aVllYXIgaW1wbGVtZW50cyBUdWlZZWFyTGlrZSB7XG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgeWVhcjogbnVtYmVyKSB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpWWVhci5pc1ZhbGlkWWVhcih5ZWFyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHllYXIgZm9yIHZhbGlkaXR5XG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWRZZWFyKHllYXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih5ZWFyKSAmJiBpblJhbmdlKHllYXIsIE1JTl9ZRUFSLCBNQVhfWUVBUiArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHBhc3NlZCB5ZWFyIGlzIGEgbGVhcCB5ZWFyXG4gICAgICovXG4gICAgc3RhdGljIGlzTGVhcFllYXIoeWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpWWVhci5pc1ZhbGlkWWVhcih5ZWFyKSk7XG5cbiAgICAgICAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW1vdW50IG9mIGxlYXAgeWVhcnMgZnJvbSB5ZWFyIDAgdG8gdGhlIHBhc3NlZCBvbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QWJzb2x1dGVMZWFwWWVhcnMoeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHllYXIgLyA0MDApICsgKE1hdGguY2VpbCh5ZWFyIC8gNCkgLSBNYXRoLmNlaWwoeWVhciAvIDEwMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERPTlQgVVNFIElUICh3aWxsIGJlIGRlbGV0ZWQgc29vbilcbiAgICAgKlxuICAgICAqIFJldHVybnMgZGF5IG9mIHdlZWsgb2Zmc2V0IG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhc3NlZCB5ZWFyXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZUxlYXBZZWFycyBhbW91bnQgb2YgbGVhcCB5ZWFycyBwcmlvciB0byB0aGUgcGFzc2VkIG9uZVxuICAgICAqIEByZXR1cm4gb2Zmc2V0IGluIGRheXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0WWVhclN0YXJ0RGF5c09mZnNldCh5ZWFyOiBudW1iZXIsIGFic29sdXRlTGVhcFllYXJzOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFR1aVllYXIuaXNWYWxpZFllYXIoeWVhcikpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoYWJzb2x1dGVMZWFwWWVhcnMpKTtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydCh5ZWFyID49IGFic29sdXRlTGVhcFllYXJzKTtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChhYnNvbHV0ZUxlYXBZZWFycyA+PSAwKTtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGFic29sdXRlTGVhcFllYXJzICogREFZU19JTl9MRUFQX1lFQVIgK1xuICAgICAgICAgICAgICAgICh5ZWFyIC0gYWJzb2x1dGVMZWFwWWVhcnMpICogREFZU19JTl9OT1JNQUxfWUVBUiArXG4gICAgICAgICAgICAgICAgNSkgJVxuICAgICAgICAgICAgREFZU19JTl9XRUVLXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxlbmd0aEJldHdlZW4oZnJvbTogVHVpWWVhciwgdG86IFR1aVllYXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdG8ueWVhciAtIGZyb20ueWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHllYXIgYnkgY2xhbXBpbmcgaXQgYmV0d2VlbiBtaW4gYW5kIG1heCB5ZWFyc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgbm9ybWFsaXplWWVhclBhcnQoeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVRvSW50TnVtYmVyKHllYXIsIE1JTl9ZRUFSLCBNQVhfWUVBUik7XG4gICAgfVxuXG4gICAgZ2V0IGZvcm1hdHRlZFllYXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHBhZFN0YXJ0KFN0cmluZyh0aGlzLnllYXIpLCA0LCBgMGApO1xuICAgIH1cblxuICAgIGdldCBpc0xlYXBZZWFyKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gVHVpWWVhci5pc0xlYXBZZWFyKHRoaXMueWVhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbW91bnQgb2YgbGVhcCB5ZWFycyBmcm9tIHllYXIgMCB0byBjdXJyZW50XG4gICAgICovXG4gICAgZ2V0IGFic29sdXRlTGVhcFllYXJzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBUdWlZZWFyLmdldEFic29sdXRlTGVhcFllYXJzKHRoaXMueWVhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRE9OVCBVU0UgSVQgKHdpbGwgYmUgZGVsZXRlZCBzb29uKVxuICAgICAqXG4gICAgICogUmV0dXJucyBkYXkgb2Ygd2VlayBvZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCB5ZWFyXG4gICAgICovXG4gICAgZ2V0IHllYXJTdGFydERheXNPZmZzZXQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIFR1aVllYXIuZ2V0WWVhclN0YXJ0RGF5c09mZnNldCh0aGlzLnllYXIsIHRoaXMuYWJzb2x1dGVMZWFwWWVhcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCB5ZWFyIGlzIGFmdGVyIGN1cnJlbnRcbiAgICAgKi9cbiAgICB5ZWFyQmVmb3JlKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyIDwgeWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgeWVhciBpcyB0aGUgc2FtZSBvciBhZnRlciBjdXJyZW50XG4gICAgICovXG4gICAgeWVhclNhbWVPckJlZm9yZSh7eWVhcn06IFR1aVllYXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhciA8PSB5ZWFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCB5ZWFyIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICB5ZWFyU2FtZSh7eWVhcn06IFR1aVllYXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhciA9PT0geWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgeWVhciBpcyBlaXRoZXIgdGhlIHNhbWUgb2YgYmVmb3JlIHRoZSBjdXJyZW50XG4gICAgICovXG4gICAgeWVhclNhbWVPckFmdGVyKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyID49IHllYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIHllYXIgaXMgYmVmb3JlIGN1cnJlbnRcbiAgICAgKi9cbiAgICB5ZWFyQWZ0ZXIoe3llYXJ9OiBUdWlZZWFyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIgPiB5ZWFyO1xuICAgIH1cblxuICAgIC8vIFRPRE86IDMuMCBDb25zaWRlciByZW1vdmluZyBgYmFja3dhcmRzYCBvcHRpb25cbiAgICAvKipcbiAgICAgKiBJbW11dGFibHkgb2Zmc2V0cyB5ZWFyXG4gICAgICovXG4gICAgYXBwZW5kKHt5ZWFyID0gMH06IFR1aVllYXJMaWtlLCBiYWNrd2FyZHM6IGJvb2xlYW4gPSBmYWxzZSk6IFR1aVllYXIge1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoeWVhcikpO1xuXG4gICAgICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHllYXIgKj0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHRZZWFyID0gdGhpcy55ZWFyICsgeWVhcjtcblxuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFR1aVllYXIuaXNWYWxpZFllYXIocmVzdWx0WWVhcikpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpWWVhcihyZXN1bHRZZWFyKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRZZWFyO1xuICAgIH1cblxuICAgIHZhbHVlT2YoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmltaXRpdmUgdmFsdWUgb2YgdGhlIGdpdmVuIERhdGUgb2JqZWN0LlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgYXJndW1lbnQsIHRoZSBtZXRob2QgY2FuIHJldHVybiBlaXRoZXIgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL0BAdG9QcmltaXRpdmVcbiAgICAgKi9cbiAgICBbU3ltYm9sLnRvUHJpbWl0aXZlXShoaW50OiBzdHJpbmcpOiBudW1iZXIgfCBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGVbU3ltYm9sLnRvUHJpbWl0aXZlXS5jYWxsKHRoaXMsIGhpbnQpO1xuICAgIH1cblxuICAgIHRvSlNPTigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRZZWFyO1xuICAgIH1cbn1cbiJdfQ==