import { tuiAssert } from '@taiga-ui/cdk/classes';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DAYS_IN_WEEK, MAX_MONTH, MIN_MONTH, MONTHS_IN_YEAR } from './date-time';
import { TuiYear } from './year';
/**
 * Immutable object consisting of year and month
 */
export class TuiMonth extends TuiYear {
    /**
     * @param year
     * @param month (starting with 0)
     */
    constructor(year, month) {
        super(year);
        this.month = month;
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
    }
    /**
     * Tests month and year for validity
     */
    static isValidMonth(year, month) {
        return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);
    }
    /**
     * Returns number of days in a month
     */
    static getMonthDaysCount(month, isLeapYear) {
        tuiAssert.assert(TuiMonth.isValidMonthPart(month));
        switch (month) {
            case 1 /* February */:
                return isLeapYear ? 29 : 28;
            case 3 /* April */:
            case 5 /* June */:
            case 8 /* September */:
            case 10 /* November */:
                return 30;
            default:
                return 31;
        }
    }
    /**
     * Returns current month and year based on local time zone
     * @nosideeffects
     */
    static currentLocal() {
        const nativeDate = new Date();
        return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());
    }
    /**
     * Returns current month and year based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());
    }
    static lengthBetween(from, to) {
        const absoluteFrom = from.month + from.year * 12;
        const absoluteTo = to.month + to.year * 12;
        return absoluteTo - absoluteFrom;
    }
    /**
     * Normalizes number by clamping it between min and max month
     */
    static normalizeMonthPart(month) {
        return normalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);
    }
    /**
     * Tests month for validity
     */
    static isValidMonthPart(month) {
        return Number.isInteger(month) && inRange(month, MIN_MONTH, MAX_MONTH + 1);
    }
    get formattedMonthPart() {
        return padStart(String(this.month + 1), 2, `0`);
    }
    /**
     * @deprecated
     * Formatter month and year
     */
    get formattedMonth() {
        return `${this.formattedMonthPart}.${this.formattedYear}`;
    }
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Calculates number of weeks in a month (counting non-full weeks)
     */
    get weeksRowsCount() {
        return Math.ceil((this.monthStartDaysOffset + this.daysCount) / DAYS_IN_WEEK);
    }
    /**
     * Returns days in a month
     */
    get daysCount() {
        return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);
    }
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Computes day of week offset of the beginning of the month
     */
    get monthStartDaysOffset() {
        let result = this.yearStartDaysOffset;
        for (let currentMonth = 0; currentMonth <= this.month - 1; currentMonth++) {
            result += TuiMonth.getMonthDaysCount(currentMonth, this.isLeapYear);
        }
        return result % DAYS_IN_WEEK;
    }
    /**
     * Passed month and year are after current
     */
    monthBefore(another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month < another.month));
    }
    /**
     * Passed month and year are after or the same as current
     */
    monthSameOrBefore(another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month <= another.month));
    }
    /**
     * Passed month and year are the same as current
     */
    monthSame(another) {
        return this.yearSame(another) && this.month === another.month;
    }
    /**
     * Passed month and year are either before or equal to current
     */
    monthSameOrAfter(another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month >= another.month));
    }
    /**
     * Passed month and year are before current
     */
    monthAfter(another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month > another.month));
    }
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably alters current month and year by passed offset
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new month and year object as a result of offsetting current
     */
    append({ year = 0, month = 0 }, backwards = false) {
        if (backwards) {
            year *= -1;
            month *= -1;
        }
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        return new TuiMonth(Math.floor(totalMonths / MONTHS_IN_YEAR), totalMonths % MONTHS_IN_YEAR);
    }
    toString() {
        return this.formattedMonth;
    }
    valueOf() {
        return this.toLocalNativeDate().valueOf();
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedMonthPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkvY2RrL2RhdGUtdGltZS8iLCJzb3VyY2VzIjpbIm1vbnRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDcEQsT0FBTyxFQUFDLE9BQU8sRUFBRSxvQkFBb0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRXZFLE9BQU8sRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDL0UsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUUvQjs7R0FFRztBQUNILE1BQU0sT0FBTyxRQUFTLFNBQVEsT0FBTztJQUNqQzs7O09BR0c7SUFDSCxZQUFZLElBQVksRUFBVyxLQUFhO1FBQzVDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQURtQixVQUFLLEdBQUwsS0FBSyxDQUFRO1FBRTVDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsWUFBWSxDQUFDLElBQVksRUFBRSxLQUFhO1FBQzNDLE9BQU8sT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEtBQWEsRUFBRSxVQUFtQjtRQUN2RCxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBRW5ELFFBQVEsS0FBSyxFQUFFO1lBQ1g7Z0JBQ0ksT0FB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cUIsS0FBSztRQUNsRSxJQUFJLFNBQVMsRUFBRTtZQUNYLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNYLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNmO1FBRUQsTUFBTSxXQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUU3RSxPQUFPLElBQUksUUFBUSxDQUNmLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLGNBQWMsQ0FBQyxFQUN4QyxXQUFXLEdBQUcsY0FBYyxDQUMvQixDQUFDO0lBQ04sQ0FBQztJQUVELFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDL0IsQ0FBQztJQUVELE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzlDLENBQUM7SUFFRCxNQUFNO1FBQ0YsT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUMxRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxpQkFBaUI7UUFDYixPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRDs7T0FFRztJQUNILGVBQWU7UUFDWCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNyRCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpTW9udGhOdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvZW51bXMnO1xuaW1wb3J0IHtUdWlNb250aExpa2V9IGZyb20gJ0B0YWlnYS11aS9jZGsvaW50ZXJmYWNlcyc7XG5pbXBvcnQge3BhZFN0YXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL2Zvcm1hdCc7XG5pbXBvcnQge2luUmFuZ2UsIG5vcm1hbGl6ZVRvSW50TnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21hdGgnO1xuXG5pbXBvcnQge0RBWVNfSU5fV0VFSywgTUFYX01PTlRILCBNSU5fTU9OVEgsIE1PTlRIU19JTl9ZRUFSfSBmcm9tICcuL2RhdGUtdGltZSc7XG5pbXBvcnQge1R1aVllYXJ9IGZyb20gJy4veWVhcic7XG5cbi8qKlxuICogSW1tdXRhYmxlIG9iamVjdCBjb25zaXN0aW5nIG9mIHllYXIgYW5kIG1vbnRoXG4gKi9cbmV4cG9ydCBjbGFzcyBUdWlNb250aCBleHRlbmRzIFR1aVllYXIgaW1wbGVtZW50cyBUdWlNb250aExpa2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoIChzdGFydGluZyB3aXRoIDApXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeWVhcjogbnVtYmVyLCByZWFkb25seSBtb250aDogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyKHllYXIpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIG1vbnRoIGFuZCB5ZWFyIGZvciB2YWxpZGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkTW9udGgoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpICYmIFR1aU1vbnRoLmlzVmFsaWRNb250aFBhcnQobW9udGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNb250aERheXNDb3VudChtb250aDogbnVtYmVyLCBpc0xlYXBZZWFyOiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlNb250aC5pc1ZhbGlkTW9udGhQYXJ0KG1vbnRoKSk7XG5cbiAgICAgICAgc3dpdGNoIChtb250aCkge1xuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5GZWJydWFyeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMZWFwWWVhciA/IDI5IDogMjg7XG4gICAgICAgICAgICBjYXNlIFR1aU1vbnRoTnVtYmVyLkFwcmlsOlxuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5KdW5lOlxuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5TZXB0ZW1iZXI6XG4gICAgICAgICAgICBjYXNlIFR1aU1vbnRoTnVtYmVyLk5vdmVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyIGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqIEBub3NpZGVlZmZlY3RzXG4gICAgICovXG4gICAgc3RhdGljIGN1cnJlbnRMb2NhbCgpOiBUdWlNb250aCB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpTW9udGgobmF0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCBuYXRpdmVEYXRlLmdldE1vbnRoKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBtb250aCBhbmQgeWVhciBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VycmVudFV0YygpOiBUdWlNb250aCB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpTW9udGgobmF0aXZlRGF0ZS5nZXRVVENGdWxsWWVhcigpLCBuYXRpdmVEYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsZW5ndGhCZXR3ZWVuKGZyb206IFR1aU1vbnRoLCB0bzogVHVpTW9udGgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZUZyb20gPSBmcm9tLm1vbnRoICsgZnJvbS55ZWFyICogMTI7XG4gICAgICAgIGNvbnN0IGFic29sdXRlVG8gPSB0by5tb250aCArIHRvLnllYXIgKiAxMjtcblxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUbyAtIGFic29sdXRlRnJvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIG51bWJlciBieSBjbGFtcGluZyBpdCBiZXR3ZWVuIG1pbiBhbmQgbWF4IG1vbnRoXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBub3JtYWxpemVNb250aFBhcnQobW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVUb0ludE51bWJlcihtb250aCwgTUlOX01PTlRILCBNQVhfTU9OVEgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIG1vbnRoIGZvciB2YWxpZGl0eVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGlzVmFsaWRNb250aFBhcnQobW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihtb250aCkgJiYgaW5SYW5nZShtb250aCwgTUlOX01PTlRILCBNQVhfTU9OVEggKyAxKTtcbiAgICB9XG5cbiAgICBnZXQgZm9ybWF0dGVkTW9udGhQYXJ0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwYWRTdGFydChTdHJpbmcodGhpcy5tb250aCArIDEpLCAyLCBgMGApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogRm9ybWF0dGVyIG1vbnRoIGFuZCB5ZWFyXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdHRlZE1vbnRoKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdHRlZE1vbnRoUGFydH0uJHt0aGlzLmZvcm1hdHRlZFllYXJ9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBET05UIFVTRSBJVCAod2lsbCBiZSBkZWxldGVkIHNvb24pXG4gICAgICpcbiAgICAgKiBDYWxjdWxhdGVzIG51bWJlciBvZiB3ZWVrcyBpbiBhIG1vbnRoIChjb3VudGluZyBub24tZnVsbCB3ZWVrcylcbiAgICAgKi9cbiAgICBnZXQgd2Vla3NSb3dzQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgodGhpcy5tb250aFN0YXJ0RGF5c09mZnNldCArIHRoaXMuZGF5c0NvdW50KSAvIERBWVNfSU5fV0VFSyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXlzIGluIGEgbW9udGhcbiAgICAgKi9cbiAgICBnZXQgZGF5c0NvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBUdWlNb250aC5nZXRNb250aERheXNDb3VudCh0aGlzLm1vbnRoLCB0aGlzLmlzTGVhcFllYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERPTlQgVVNFIElUICh3aWxsIGJlIGRlbGV0ZWQgc29vbilcbiAgICAgKlxuICAgICAqIENvbXB1dGVzIGRheSBvZiB3ZWVrIG9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtb250aFxuICAgICAqL1xuICAgIGdldCBtb250aFN0YXJ0RGF5c09mZnNldCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy55ZWFyU3RhcnREYXlzT2Zmc2V0O1xuXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnRNb250aCA9IDA7IGN1cnJlbnRNb250aCA8PSB0aGlzLm1vbnRoIC0gMTsgY3VycmVudE1vbnRoKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChjdXJyZW50TW9udGgsIHRoaXMuaXNMZWFwWWVhcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICUgREFZU19JTl9XRUVLO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBtb250aCBhbmQgeWVhciBhcmUgYWZ0ZXIgY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoQmVmb3JlKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnllYXJCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLnllYXJTYW1lKGFub3RoZXIpICYmIHRoaXMubW9udGggPCBhbm90aGVyLm1vbnRoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBtb250aCBhbmQgeWVhciBhcmUgYWZ0ZXIgb3IgdGhlIHNhbWUgYXMgY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoU2FtZU9yQmVmb3JlKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnllYXJCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLnllYXJTYW1lKGFub3RoZXIpICYmIHRoaXMubW9udGggPD0gYW5vdGhlci5tb250aClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgbW9udGggYW5kIHllYXIgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBtb250aFNhbWUoYW5vdGhlcjogVHVpTW9udGgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhclNhbWUoYW5vdGhlcikgJiYgdGhpcy5tb250aCA9PT0gYW5vdGhlci5tb250aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgbW9udGggYW5kIHllYXIgYXJlIGVpdGhlciBiZWZvcmUgb3IgZXF1YWwgdG8gY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoU2FtZU9yQWZ0ZXIoYW5vdGhlcjogVHVpTW9udGgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueWVhckFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy55ZWFyU2FtZShhbm90aGVyKSAmJiB0aGlzLm1vbnRoID49IGFub3RoZXIubW9udGgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIG1vbnRoIGFuZCB5ZWFyIGFyZSBiZWZvcmUgY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoQWZ0ZXIoYW5vdGhlcjogVHVpTW9udGgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueWVhckFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy55ZWFyU2FtZShhbm90aGVyKSAmJiB0aGlzLm1vbnRoID4gYW5vdGhlci5tb250aClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiAzLjAgQ29uc2lkZXIgcmVtb3ZpbmcgYGJhY2t3YXJkc2Agb3B0aW9uXG4gICAgLyoqXG4gICAgICogSW1tdXRhYmx5IGFsdGVycyBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyIGJ5IHBhc3NlZCBvZmZzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcGFyYW0gYmFja3dhcmRzIHNoaWZ0IGRhdGUgYmFja3dhcmRzXG4gICAgICogQHJldHVybiBuZXcgbW9udGggYW5kIHllYXIgb2JqZWN0IGFzIGEgcmVzdWx0IG9mIG9mZnNldHRpbmcgY3VycmVudFxuICAgICAqL1xuICAgIGFwcGVuZCh7eWVhciA9IDAsIG1vbnRoID0gMH06IFR1aU1vbnRoTGlrZSwgYmFja3dhcmRzOiBib29sZWFuID0gZmFsc2UpOiBUdWlNb250aCB7XG4gICAgICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHllYXIgKj0gLTE7XG4gICAgICAgICAgICBtb250aCAqPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvdGFsTW9udGhzID0gKHRoaXMueWVhciArIHllYXIpICogTU9OVEhTX0lOX1lFQVIgKyB0aGlzLm1vbnRoICsgbW9udGg7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlNb250aChcbiAgICAgICAgICAgIE1hdGguZmxvb3IodG90YWxNb250aHMgLyBNT05USFNfSU5fWUVBUiksXG4gICAgICAgICAgICB0b3RhbE1vbnRocyAlIE1PTlRIU19JTl9ZRUFSLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZE1vbnRoO1xuICAgIH1cblxuICAgIHZhbHVlT2YoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbE5hdGl2ZURhdGUoKS52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci50b0pTT04oKX0tJHt0aGlzLmZvcm1hdHRlZE1vbnRoUGFydH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIFVUQ1xuICAgICAqL1xuICAgIHRvVXRjTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHRoaXMueWVhciwgdGhpcy5tb250aCkpO1xuICAgIH1cbn1cbiJdfQ==