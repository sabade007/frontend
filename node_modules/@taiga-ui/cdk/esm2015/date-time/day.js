import { tuiAssert } from '@taiga-ui/cdk/classes';
import { InvalidDayException, InvalidMonthException, InvalidYearException, } from '@taiga-ui/cdk/exceptions';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DATE_FILLER_LENGTH } from './date-fillers';
import { DAYS_IN_WEEK, MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiMonth } from './month';
import { TuiYear } from './year';
// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
export class TuiDay extends TuiMonth {
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        tuiAssert.assert(TuiDay.isValidDay(year, month, day));
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    }
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Calculated day on a calendar grid
     *
     * @param month
     * @param row row in a calendar
     * @param col column in a calendar
     * @return resulting day on these coordinates (could exceed passed month)
     */
    static getDayFromMonthRowCol(month, row, col) {
        tuiAssert.assert(Number.isInteger(row));
        tuiAssert.assert(inRange(row, 0, 6));
        tuiAssert.assert(Number.isInteger(col));
        tuiAssert.assert(inRange(col, 0, DAYS_IN_WEEK));
        let day = row * DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;
        if (day > month.daysCount) {
            day -= month.daysCount;
            month = month.append({ month: 1 });
        }
        if (day <= 0) {
            month = month.append({ month: -1 });
            day = month.daysCount + day;
        }
        return new TuiDay(month.year, month.month, day);
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Returns current day based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        const year = nativeDate.getUTCFullYear();
        const month = nativeDate.getUTCMonth();
        const day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = TuiYear.normalizeYearPart(year);
        const normalizedMonth = TuiMonth.normalizeMonthPart(month);
        const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    }
    static parseRawDateString(date, dateMode = `DMY`) {
        tuiAssert.assert(date.length === DATE_FILLER_LENGTH, `[parseRawDateString]: wrong date string length`);
        switch (dateMode) {
            case `YMD`:
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case `MDY`:
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            default:
            case `DMY`:
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    static normalizeParse(rawDate, dateMode = `DMY`) {
        const { day, month, year } = this.parseRawDateString(rawDate, dateMode);
        return TuiDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const { day, month, year } = this.parseRawDateString(yearMonthDayString, `YMD`);
        if (!TuiYear.isValidYear(year)) {
            throw new InvalidYearException(year);
        }
        if (!TuiMonth.isValidMonth(year, month)) {
            throw new InvalidMonthException(month);
        }
        if (!Number.isInteger(day) ||
            !inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new InvalidDayException(day);
        }
        return new TuiDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return normalizeToIntNumber(day, 1, monthDaysCount);
    }
    get formattedDayPart() {
        return padStart(String(this.day), 2, `0`);
    }
    /**
     * @deprecated use {@link getFormattedDay} instead
     * Formatted whole date
     */
    get formattedDay() {
        return `${this.formattedDayPart}.${this.formattedMonth}`;
    }
    get isWeekend() {
        const dayOfWeek = this.dayOfWeek(false);
        return dayOfWeek === 6 /* Saturday */ || dayOfWeek === 0 /* Sunday */;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }, backwards = false) {
        if (backwards) {
            year *= -1;
            month *= -1;
            day *= -1;
        }
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        let months = totalMonths % MONTHS_IN_YEAR;
        let days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === 11 /* December */) {
                years++;
                months = 0 /* January */;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === 0 /* January */) {
                years--;
                months = 11 /* December */;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    }
    /**
     * Returns formatted whole date
     */
    getFormattedDay(dateFormat, separator) {
        tuiAssert.assert(separator.length === 1, `Separator should consist of only 1 symbol`);
        const dd = this.formattedDayPart;
        const mm = this.formattedMonthPart;
        const yyyy = this.formattedYear;
        switch (dateFormat) {
            case `YMD`:
                return `${yyyy}${separator}${mm}${separator}${dd}`;
            case `MDY`:
                return `${mm}${separator}${dd}${separator}${yyyy}`;
            case `DMY`:
            default:
                return `${dd}${separator}${mm}${separator}${yyyy}`;
        }
    }
    toString(dateFormat = `DMY`, separator = `.`) {
        return this.getFormattedDay(dateFormat, separator);
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month, this.day);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kYXRlLXRpbWUvIiwic291cmNlcyI6WyJkYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWhELE9BQU8sRUFDSCxtQkFBbUIsRUFDbkIscUJBQXFCLEVBQ3JCLG9CQUFvQixHQUN2QixNQUFNLDBCQUEwQixDQUFDO0FBR2xDLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUNwRCxPQUFPLEVBQUMsT0FBTyxFQUFFLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFFdkUsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ2xFLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDakMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUUvQiw2QkFBNkI7QUFDN0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sTUFBTyxTQUFRLFFBQVE7SUFDaEMsWUFBWSxJQUFZLEVBQUUsS0FBYSxFQUFXLEdBQVc7UUFDekQsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUQyQixRQUFHLEdBQUgsR0FBRyxDQUFRO1FBRXpELFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQVU7UUFDakMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksQ0FB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TyxHQUFHLEVBQUUsR0FBRyxTQUFTLEdBQUcsRUFBRSxHQUFHLFNBQVMsR0FBRyxJQUFJLEVBQUUsQ0FBQztTQUMxRDtJQUNMLENBQUM7SUFFRCxRQUFRLENBQUMsYUFBMEIsS0FBSyxFQUFFLFlBQW9CLEdBQUc7UUFDN0QsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsTUFBTTtRQUNGLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDeEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7T0FFRztJQUNILGVBQWU7UUFDWCxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dHVpQXNzZXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NsYXNzZXMnO1xuaW1wb3J0IHtUdWlEYXlPZldlZWssIFR1aU1vbnRoTnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2VudW1zJztcbmltcG9ydCB7XG4gICAgSW52YWxpZERheUV4Y2VwdGlvbixcbiAgICBJbnZhbGlkTW9udGhFeGNlcHRpb24sXG4gICAgSW52YWxpZFllYXJFeGNlcHRpb24sXG59IGZyb20gJ0B0YWlnYS11aS9jZGsvZXhjZXB0aW9ucyc7XG5pbXBvcnQge1R1aURheUxpa2V9IGZyb20gJ0B0YWlnYS11aS9jZGsvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1R1aURhdGVNb2RlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3R5cGVzJztcbmltcG9ydCB7cGFkU3RhcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvZm9ybWF0JztcbmltcG9ydCB7aW5SYW5nZSwgbm9ybWFsaXplVG9JbnROdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvbWF0aCc7XG5cbmltcG9ydCB7REFURV9GSUxMRVJfTEVOR1RIfSBmcm9tICcuL2RhdGUtZmlsbGVycyc7XG5pbXBvcnQge0RBWVNfSU5fV0VFSywgTUlOX0RBWSwgTU9OVEhTX0lOX1lFQVJ9IGZyb20gJy4vZGF0ZS10aW1lJztcbmltcG9ydCB7VHVpTW9udGh9IGZyb20gJy4vbW9udGgnO1xuaW1wb3J0IHtUdWlZZWFyfSBmcm9tICcuL3llYXInO1xuXG4vLyBUT0RPOiBMb2NhbGl6ZWQgZm9ybWF0dGluZ1xuLyoqXG4gKiBJbW11dGFibGUgZGF0ZSBvYmplY3QsIGNvbnNpc3Rpbmcgb2YgZGF5LCBtb250aCBhbmQgeWVhclxuICovXG5leHBvcnQgY2xhc3MgVHVpRGF5IGV4dGVuZHMgVHVpTW9udGgge1xuICAgIGNvbnN0cnVjdG9yKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgcmVhZG9ubHkgZGF5OiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoeWVhciwgbW9udGgpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFR1aURheS5pc1ZhbGlkRGF5KHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBUdWlEYXl9IGZyb20gbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUxvY2FsTmF0aXZlRGF0ZShkYXRlOiBEYXRlKTogVHVpRGF5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBUdWlEYXl9IGZyb20gbmF0aXZlIHtAbGluayBEYXRlfSB1c2luZyBVVENcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVV0Y05hdGl2ZURhdGUoZGF0ZTogRGF0ZSk6IFR1aURheSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGF0ZS5nZXRVVENNb250aCgpLCBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdmFsaWRpdHkgb2YgeWVhciwgbW9udGggYW5kIGRheVxuICAgICAqXG4gICAgICogQHBhcmFtIHllYXJcbiAgICAgKiBAcGFyYW0gbW9udGhcbiAgICAgKiBAcGFyYW0gZGF5XG4gICAgICogQHJldHVybiBib29sZWFuIHZhbGlkaXR5XG4gICAgICovXG4gICAgc3RhdGljIGlzVmFsaWREYXkoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihkYXkpICYmXG4gICAgICAgICAgICBpblJhbmdlKFxuICAgICAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgICAgICBNSU5fREFZLFxuICAgICAgICAgICAgICAgIFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRoLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcikpICsgMSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBET05UIFVTRSBJVCAod2lsbCBiZSBkZWxldGVkIHNvb24pXG4gICAgICpcbiAgICAgKiBDYWxjdWxhdGVkIGRheSBvbiBhIGNhbGVuZGFyIGdyaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEBwYXJhbSByb3cgcm93IGluIGEgY2FsZW5kYXJcbiAgICAgKiBAcGFyYW0gY29sIGNvbHVtbiBpbiBhIGNhbGVuZGFyXG4gICAgICogQHJldHVybiByZXN1bHRpbmcgZGF5IG9uIHRoZXNlIGNvb3JkaW5hdGVzIChjb3VsZCBleGNlZWQgcGFzc2VkIG1vbnRoKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREYXlGcm9tTW9udGhSb3dDb2wobW9udGg6IFR1aU1vbnRoLCByb3c6IG51bWJlciwgY29sOiBudW1iZXIpOiBUdWlEYXkge1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIocm93KSk7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoaW5SYW5nZShyb3csIDAsIDYpKTtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGNvbCkpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KGluUmFuZ2UoY29sLCAwLCBEQVlTX0lOX1dFRUspKTtcblxuICAgICAgICBsZXQgZGF5ID0gcm93ICogREFZU19JTl9XRUVLICsgY29sIC0gbW9udGgubW9udGhTdGFydERheXNPZmZzZXQgKyAxO1xuXG4gICAgICAgIGlmIChkYXkgPiBtb250aC5kYXlzQ291bnQpIHtcbiAgICAgICAgICAgIGRheSAtPSBtb250aC5kYXlzQ291bnQ7XG4gICAgICAgICAgICBtb250aCA9IG1vbnRoLmFwcGVuZCh7bW9udGg6IDF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPD0gMCkge1xuICAgICAgICAgICAgbW9udGggPSBtb250aC5hcHBlbmQoe21vbnRoOiAtMX0pO1xuICAgICAgICAgICAgZGF5ID0gbW9udGguZGF5c0NvdW50ICsgZGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkobW9udGgueWVhciwgbW9udGgubW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkYXkgYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgc3RhdGljIGN1cnJlbnRMb2NhbCgpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IG5hdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBuYXRpdmVEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBkYXkgYmFzZWQgb24gVVRDXG4gICAgICovXG4gICAgc3RhdGljIGN1cnJlbnRVdGMoKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3QgbmF0aXZlRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHllYXIgPSBuYXRpdmVEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gbmF0aXZlRGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICBjb25zdCBkYXkgPSBuYXRpdmVEYXRlLmdldFVUQ0RhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHtAbGluayBUdWlEYXl9IG5vcm1hbGl6aW5nIHllYXIsIG1vbnRoIGFuZCBkYXkuIHtAbGluayBOYU59IGlzIHR1cm5lZCBpbnRvIG1pbmltYWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhciBhbnkgeWVhciB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWRcbiAgICAgKiBAcGFyYW0gbW9udGggYW55IG1vbnRoIHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZCAobW9udGhzIHN0YXJ0IHdpdGggMClcbiAgICAgKiBAcGFyYW0gZGF5IGFueSBkYXkgdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplT2YoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRZZWFyID0gVHVpWWVhci5ub3JtYWxpemVZZWFyUGFydCh5ZWFyKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZE1vbnRoID0gVHVpTW9udGgubm9ybWFsaXplTW9udGhQYXJ0KG1vbnRoKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZERheSA9IFR1aURheS5ub3JtYWxpemVEYXlQYXJ0KFxuICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgbm9ybWFsaXplZE1vbnRoLFxuICAgICAgICAgICAgbm9ybWFsaXplZFllYXIsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkobm9ybWFsaXplZFllYXIsIG5vcm1hbGl6ZWRNb250aCwgbm9ybWFsaXplZERheSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxlbmd0aEJldHdlZW4oZnJvbTogVHVpRGF5LCB0bzogVHVpRGF5KTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgICAgICAgICAodG8udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkgLSBmcm9tLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0VGltZSgpKSAvXG4gICAgICAgICAgICAgICAgKDEwMDAgKiA2MCAqIDYwICogMjQpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVJhd0RhdGVTdHJpbmcoXG4gICAgICAgIGRhdGU6IHN0cmluZyxcbiAgICAgICAgZGF0ZU1vZGU6IFR1aURhdGVNb2RlID0gYERNWWAsXG4gICAgKToge2RheTogbnVtYmVyOyBtb250aDogbnVtYmVyOyB5ZWFyOiBudW1iZXJ9IHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChcbiAgICAgICAgICAgIGRhdGUubGVuZ3RoID09PSBEQVRFX0ZJTExFUl9MRU5HVEgsXG4gICAgICAgICAgICBgW3BhcnNlUmF3RGF0ZVN0cmluZ106IHdyb25nIGRhdGUgc3RyaW5nIGxlbmd0aGAsXG4gICAgICAgICk7XG5cbiAgICAgICAgc3dpdGNoIChkYXRlTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBgWU1EYDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoOCwgMTApLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDUsIDcpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDQpLCAxMCksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FzZSBgTURZYDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoMywgNSksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoMCwgMiksIDEwKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoNiwgMTApLCAxMCksXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgYERNWWA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5OiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDIpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDMsIDUpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludChkYXRlLnNsaWNlKDYsIDEwKSwgMTApLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBNb3ZlIG1vbnRoIGFuZCB5ZWFyIHJlbGF0ZWQgY29kZSBjb3JyZXNwb25kaW5nIGNsYXNzZXNcbiAgICAvKipcbiAgICAgKiBQYXJzaW5nIGEgc3RyaW5nIHdpdGggZGF0ZSB3aXRoIG5vcm1hbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYXdEYXRlIGRhdGUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRhdGVNb2RlIGRhdGUgZm9ybWF0IG9mIHRoZSBkYXRlIHN0cmluZyAoRE1ZIHwgTURZIHwgWU1EKVxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXRlXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZVBhcnNlKHJhd0RhdGU6IHN0cmluZywgZGF0ZU1vZGU6IFR1aURhdGVNb2RlID0gYERNWWApOiBUdWlEYXkge1xuICAgICAgICBjb25zdCB7ZGF5LCBtb250aCwgeWVhcn0gPSB0aGlzLnBhcnNlUmF3RGF0ZVN0cmluZyhyYXdEYXRlLCBkYXRlTW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIFR1aURheS5ub3JtYWxpemVPZih5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzaW5nIGEgZGF0ZSBzdHJpbmdpZmllZCBpbiBhIHRvSlNPTiBmb3JtYXRcbiAgICAgKiBAcGFyYW0geWVhck1vbnRoRGF5U3RyaW5nIGRhdGUgc3RyaW5nIGluIGZvcm1hdCBvZiBZWVlZLU1NLUREXG4gICAgICogQHJldHVybiBkYXRlXG4gICAgICogQHRocm93cyBleGNlcHRpb25zIGlmIGFueSBwYXJ0IG9mIHRoZSBkYXRlIGlzIGludmFsaWRcbiAgICAgKi9cbiAgICBzdGF0aWMganNvblBhcnNlKHllYXJNb250aERheVN0cmluZzogc3RyaW5nKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qge2RheSwgbW9udGgsIHllYXJ9ID0gdGhpcy5wYXJzZVJhd0RhdGVTdHJpbmcoeWVhck1vbnRoRGF5U3RyaW5nLCBgWU1EYCk7XG5cbiAgICAgICAgaWYgKCFUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFllYXJFeGNlcHRpb24oeWVhcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTW9udGhFeGNlcHRpb24obW9udGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIoZGF5KSB8fFxuICAgICAgICAgICAgIWluUmFuZ2UoXG4gICAgICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgICAgIE1JTl9EQVksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGgsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSkgKyAxLFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF5RXhjZXB0aW9uKGRheSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIG5vcm1hbGl6ZURheVBhcnQoZGF5OiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSk7XG5cbiAgICAgICAgY29uc3QgbW9udGhEYXlzQ291bnQgPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChcbiAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpLFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVUb0ludE51bWJlcihkYXksIDEsIG1vbnRoRGF5c0NvdW50KTtcbiAgICB9XG5cbiAgICBnZXQgZm9ybWF0dGVkRGF5UGFydCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gcGFkU3RhcnQoU3RyaW5nKHRoaXMuZGF5KSwgMiwgYDBgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIGdldEZvcm1hdHRlZERheX0gaW5zdGVhZFxuICAgICAqIEZvcm1hdHRlZCB3aG9sZSBkYXRlXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdHRlZERheSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5mb3JtYXR0ZWREYXlQYXJ0fS4ke3RoaXMuZm9ybWF0dGVkTW9udGh9YDtcbiAgICB9XG5cbiAgICBnZXQgaXNXZWVrZW5kKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSB0aGlzLmRheU9mV2VlayhmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGRheU9mV2VlayA9PT0gVHVpRGF5T2ZXZWVrLlNhdHVyZGF5IHx8IGRheU9mV2VlayA9PT0gVHVpRGF5T2ZXZWVrLlN1bmRheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRheSBvZiB3ZWVrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRGcm9tTW9uZGF5IHdoZXRoZXIgd2VlayBzdGFydHMgZnJvbSBNb25kYXkgYW5kIG5vdCBmcm9tIFN1bmRheVxuICAgICAqIEByZXR1cm4gZGF5IG9mIHdlZWsgKGZyb20gMCB0byA2KVxuICAgICAqL1xuICAgIGRheU9mV2VlayhzdGFydEZyb21Nb25kYXk6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZGF5T2ZXZWVrID0gc3RhcnRGcm9tTW9uZGF5XG4gICAgICAgICAgICA/IHRoaXMudG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXREYXkoKSAtIDFcbiAgICAgICAgICAgIDogdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpO1xuXG4gICAgICAgIHJldHVybiBkYXlPZldlZWsgPCAwID8gNiA6IGRheU9mV2VlaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBhZnRlciBjdXJyZW50XG4gICAgICovXG4gICAgZGF5QmVmb3JlKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5IDwgYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgYWZ0ZXIgb3IgZXF1YWxzIHRvIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlTYW1lT3JCZWZvcmUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQmVmb3JlKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPD0gYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgdGhlIHNhbWUgYXMgY3VycmVudFxuICAgICAqL1xuICAgIGRheVNhbWUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA9PT0gYW5vdGhlci5kYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgZWl0aGVyIGJlZm9yZSBvciB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgZGF5U2FtZU9yQWZ0ZXIoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA+PSBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBiZWZvcmUgY3VycmVudFxuICAgICAqL1xuICAgIGRheUFmdGVyKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPiBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcGluZyBkYXRlIGJldHdlZW4gdHdvIGxpbWl0c1xuICAgICAqXG4gICAgICogQHBhcmFtIG1pblxuICAgICAqIEBwYXJhbSBtYXhcbiAgICAgKiBAcmV0dXJuIGNsYW1wZWQgZGF0ZVxuICAgICAqL1xuICAgIGRheUxpbWl0KG1pbjogVHVpRGF5IHwgbnVsbCwgbWF4OiBUdWlEYXkgfCBudWxsKTogVHVpRGF5IHtcbiAgICAgICAgaWYgKG1pbiAhPT0gbnVsbCAmJiB0aGlzLmRheUJlZm9yZShtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbnVsbCAmJiB0aGlzLmRheUFmdGVyKG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiAzLjAgQ29uc2lkZXIgcmVtb3ZpbmcgYGJhY2t3YXJkc2Agb3B0aW9uXG4gICAgLyoqXG4gICAgICogSW1tdXRhYmx5IGFsdGVycyBjdXJyZW50IGRheSBieSBwYXNzZWQgb2Zmc2V0XG4gICAgICpcbiAgICAgKiBJZiByZXN1bHRpbmcgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIG9yaWdpbmFsIG9uZSwgZGF0ZSBpcyByb3VuZGVkIHRvIHRoZSBtYXhpbXVtIGRheVxuICAgICAqIGluIHRoZSByZXN1bHRpbmcgbW9udGguIE9mZnNldCBvZiBkYXlzIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgcmVzdWx0ZWQgeWVhciBhbmQgbW9udGhcbiAgICAgKiB0byBub3QgaW50ZXJmZXJlIHdpdGggcGFyZW50IGNsYXNzZXMgbWV0aG9kc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEBwYXJhbSBiYWNrd2FyZHMgc2hpZnQgZGF0ZSBiYWNrd2FyZHNcbiAgICAgKiBAcmV0dXJuIG5ldyBkYXRlIG9iamVjdCBhcyBhIHJlc3VsdCBvZiBvZmZzZXR0aW5nIGN1cnJlbnRcbiAgICAgKi9cbiAgICBhcHBlbmQoXG4gICAgICAgIHt5ZWFyID0gMCwgbW9udGggPSAwLCBkYXkgPSAwfTogVHVpRGF5TGlrZSxcbiAgICAgICAgYmFja3dhcmRzOiBib29sZWFuID0gZmFsc2UsXG4gICAgKTogVHVpRGF5IHtcbiAgICAgICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgICAgICAgeWVhciAqPSAtMTtcbiAgICAgICAgICAgIG1vbnRoICo9IC0xO1xuICAgICAgICAgICAgZGF5ICo9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG90YWxNb250aHMgPSAodGhpcy55ZWFyICsgeWVhcikgKiBNT05USFNfSU5fWUVBUiArIHRoaXMubW9udGggKyBtb250aDtcbiAgICAgICAgbGV0IHllYXJzID0gTWF0aC5mbG9vcih0b3RhbE1vbnRocyAvIE1PTlRIU19JTl9ZRUFSKTtcbiAgICAgICAgbGV0IG1vbnRocyA9IHRvdGFsTW9udGhzICUgTU9OVEhTX0lOX1lFQVI7XG5cbiAgICAgICAgbGV0IGRheXMgPVxuICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgdGhpcy5kYXksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKSxcbiAgICAgICAgICAgICkgKyBkYXk7XG5cbiAgICAgICAgd2hpbGUgKGRheXMgPiBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpKSB7XG4gICAgICAgICAgICBkYXlzIC09IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSk7XG5cbiAgICAgICAgICAgIGlmIChtb250aHMgPT09IFR1aU1vbnRoTnVtYmVyLkRlY2VtYmVyKSB7XG4gICAgICAgICAgICAgICAgeWVhcnMrKztcbiAgICAgICAgICAgICAgICBtb250aHMgPSBUdWlNb250aE51bWJlci5KYW51YXJ5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb250aHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChkYXlzIDwgTUlOX0RBWSkge1xuICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gVHVpTW9udGhOdW1iZXIuSmFudWFyeSkge1xuICAgICAgICAgICAgICAgIHllYXJzLS07XG4gICAgICAgICAgICAgICAgbW9udGhzID0gVHVpTW9udGhOdW1iZXIuRGVjZW1iZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRocy0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXlzICs9IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheSh5ZWFycywgbW9udGhzLCBkYXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvcm1hdHRlZCB3aG9sZSBkYXRlXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQ6IFR1aURhdGVNb2RlLCBzZXBhcmF0b3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoXG4gICAgICAgICAgICBzZXBhcmF0b3IubGVuZ3RoID09PSAxLFxuICAgICAgICAgICAgYFNlcGFyYXRvciBzaG91bGQgY29uc2lzdCBvZiBvbmx5IDEgc3ltYm9sYCxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBkZCA9IHRoaXMuZm9ybWF0dGVkRGF5UGFydDtcbiAgICAgICAgY29uc3QgbW0gPSB0aGlzLmZvcm1hdHRlZE1vbnRoUGFydDtcbiAgICAgICAgY29uc3QgeXl5eSA9IHRoaXMuZm9ybWF0dGVkWWVhcjtcblxuICAgICAgICBzd2l0Y2ggKGRhdGVGb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgYFlNRGA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3l5eXl9JHtzZXBhcmF0b3J9JHttbX0ke3NlcGFyYXRvcn0ke2RkfWA7XG4gICAgICAgICAgICBjYXNlIGBNRFlgOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHttbX0ke3NlcGFyYXRvcn0ke2RkfSR7c2VwYXJhdG9yfSR7eXl5eX1gO1xuICAgICAgICAgICAgY2FzZSBgRE1ZYDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2RkfSR7c2VwYXJhdG9yfSR7bW19JHtzZXBhcmF0b3J9JHt5eXl5fWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyhkYXRlRm9ybWF0OiBUdWlEYXRlTW9kZSA9IGBETVlgLCBzZXBhcmF0b3I6IHN0cmluZyA9IGAuYCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlZERheShkYXRlRm9ybWF0LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIHRvSlNPTigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7c3VwZXIudG9KU09OKCl9LSR7dGhpcy5mb3JtYXR0ZWREYXlQYXJ0fWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqL1xuICAgIHRvTG9jYWxOYXRpdmVEYXRlKCk6IERhdGUge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIFVUQ1xuICAgICAqL1xuICAgIHRvVXRjTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpKTtcbiAgICB9XG59XG4iXX0=