import { __decorate, __param } from "tslib";
import { Directive, ElementRef, Inject, Optional, Self } from '@angular/core';
import { ANIMATION_FRAME } from '@ng-web-apis/common';
import { POLLING_TIME } from '@taiga-ui/cdk/constants';
import { TUI_FOCUSABLE_ITEM_ACCESSOR } from '@taiga-ui/cdk/tokens';
import { Observable, race, timer } from 'rxjs';
import { map, skipWhile, take, throttleTime } from 'rxjs/operators';
import { AbstractTuiAutofocusHandler } from './abstract.handler';
const TIMEOUT = 1000;
const NG_ANIMATION_SELECTOR = `.ng-animating`;
let TuiDefaultAutofocusHandler = class TuiDefaultAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef, animationFrame$) {
        super(tuiFocusableComponent, elementRef);
        this.animationFrame$ = animationFrame$;
    }
    setFocus() {
        if (this.isTextFieldElement) {
            race(timer(TIMEOUT), this.animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => this.element.closest(NG_ANIMATION_SELECTOR)), skipWhile(Boolean), take(1))).subscribe(() => this.element.focus());
        }
        else {
            this.element.focus();
        }
    }
};
TuiDefaultAutofocusHandler.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
TuiDefaultAutofocusHandler = __decorate([
    Directive(),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(ANIMATION_FRAME))
], TuiDefaultAutofocusHandler);
export { TuiDefaultAutofocusHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC5oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kaXJlY3RpdmVzL2F1dG8tZm9jdXMvIiwic291cmNlcyI6WyJoYW5kbGVycy9kZWZhdWx0LmhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzVFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFFckQsT0FBTyxFQUFDLDJCQUEyQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDakUsT0FBTyxFQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUVsRSxPQUFPLEVBQUMsMkJBQTJCLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUUvRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDckIsTUFBTSxxQkFBcUIsR0FBRyxlQUFlLENBQUM7QUFHOUMsSUFBYSwwQkFBMEIsR0FBdkMsTUFBYSwwQkFBMkIsU0FBUSwyQkFBMkI7SUFDdkUsWUFJSSxxQkFBeUQsRUFDckMsVUFBbUMsRUFDYixlQUFtQztRQUU3RSxLQUFLLENBQUMscUJBQXFCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFGQyxvQkFBZSxHQUFmLGVBQWUsQ0FBb0I7SUFHakYsQ0FBQztJQUVELFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtZQUN6QixJQUFJLENBQ0EsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUNkLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUNyQixZQUFZLENBQUMsWUFBWSxDQUFDLEVBQzFCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQ3RELFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFDbEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNWLENBQ0osQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQzNDO2FBQU07WUFDSCxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ3hCO0lBQ0wsQ0FBQztDQUNKLENBQUE7OzRDQXpCUSxRQUFRLFlBQ1IsSUFBSSxZQUNKLE1BQU0sU0FBQywyQkFBMkI7WUFFSCxVQUFVLHVCQUF6QyxNQUFNLFNBQUMsVUFBVTtZQUN5QyxVQUFVLHVCQUFwRSxNQUFNLFNBQUMsZUFBZTs7QUFQbEIsMEJBQTBCO0lBRHRDLFNBQVMsRUFBRTtJQUdILFdBQUEsUUFBUSxFQUFFLENBQUE7SUFDVixXQUFBLElBQUksRUFBRSxDQUFBO0lBQ04sV0FBQSxNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQTtJQUVuQyxXQUFBLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUNsQixXQUFBLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQTtHQVBuQiwwQkFBMEIsQ0EyQnRDO1NBM0JZLDBCQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3QsIE9wdGlvbmFsLCBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QU5JTUFUSU9OX0ZSQU1FfSBmcm9tICdAbmctd2ViLWFwaXMvY29tbW9uJztcbmltcG9ydCB7UE9MTElOR19USU1FfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NvbnN0YW50cyc7XG5pbXBvcnQge1R1aUZvY3VzYWJsZUVsZW1lbnRBY2Nlc3Nvcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay9pbnRlcmZhY2VzJztcbmltcG9ydCB7VFVJX0ZPQ1VTQUJMRV9JVEVNX0FDQ0VTU09SfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3Rva2Vucyc7XG5pbXBvcnQge09ic2VydmFibGUsIHJhY2UsIHRpbWVyfSBmcm9tICdyeGpzJztcbmltcG9ydCB7bWFwLCBza2lwV2hpbGUsIHRha2UsIHRocm90dGxlVGltZX0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge0Fic3RyYWN0VHVpQXV0b2ZvY3VzSGFuZGxlcn0gZnJvbSAnLi9hYnN0cmFjdC5oYW5kbGVyJztcblxuY29uc3QgVElNRU9VVCA9IDEwMDA7XG5jb25zdCBOR19BTklNQVRJT05fU0VMRUNUT1IgPSBgLm5nLWFuaW1hdGluZ2A7XG5cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGNsYXNzIFR1aURlZmF1bHRBdXRvZm9jdXNIYW5kbGVyIGV4dGVuZHMgQWJzdHJhY3RUdWlBdXRvZm9jdXNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQE9wdGlvbmFsKClcbiAgICAgICAgQFNlbGYoKVxuICAgICAgICBASW5qZWN0KFRVSV9GT0NVU0FCTEVfSVRFTV9BQ0NFU1NPUilcbiAgICAgICAgdHVpRm9jdXNhYmxlQ29tcG9uZW50OiBUdWlGb2N1c2FibGVFbGVtZW50QWNjZXNzb3IgfCBudWxsLFxuICAgICAgICBASW5qZWN0KEVsZW1lbnRSZWYpIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KEFOSU1BVElPTl9GUkFNRSkgcHJpdmF0ZSByZWFkb25seSBhbmltYXRpb25GcmFtZSQ6IE9ic2VydmFibGU8bnVtYmVyPixcbiAgICApIHtcbiAgICAgICAgc3VwZXIodHVpRm9jdXNhYmxlQ29tcG9uZW50LCBlbGVtZW50UmVmKTtcbiAgICB9XG5cbiAgICBzZXRGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0RmllbGRFbGVtZW50KSB7XG4gICAgICAgICAgICByYWNlKFxuICAgICAgICAgICAgICAgIHRpbWVyKFRJTUVPVVQpLFxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUkLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlVGltZShQT0xMSU5HX1RJTUUpLFxuICAgICAgICAgICAgICAgICAgICBtYXAoKCkgPT4gdGhpcy5lbGVtZW50LmNsb3Nlc3QoTkdfQU5JTUFUSU9OX1NFTEVDVE9SKSksXG4gICAgICAgICAgICAgICAgICAgIHNraXBXaGlsZShCb29sZWFuKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5lbGVtZW50LmZvY3VzKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=