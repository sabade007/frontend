import { tuiAssert } from '@taiga-ui/cdk/classes';
/**
 * Decorator for checking input setter values against a custom assertion which
 * takes value passed to input setter and component instance as arguments.
 * It specifically checks for undefined values and prevents calls to the
 * original setter in this case.
 */
export function tuiRequiredSetter(assertion, ...args) {
    return (target, key, { configurable, enumerable, get, set }) => {
        const { name } = target.constructor;
        return {
            configurable,
            enumerable,
            get,
            set(value) {
                if (value !== undefined && assertion) {
                    tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
                }
                if (!set || value === undefined) {
                    tuiAssert.assert(value !== undefined, errorSet(key, name));
                    return;
                }
                set.call(this, value);
            },
        };
    };
}
function errorSet(key, component) {
    return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWlyZWQtc2V0dGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kZWNvcmF0b3JzLyIsInNvdXJjZXMiOlsicmVxdWlyZWQtc2V0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDN0IsU0FBbUMsRUFDbkMsR0FBRyxJQUFXO0lBRWQsT0FBTyxDQUNILE1BQTJCLEVBQzNCLEdBQUcsRUFDSCxFQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBcUIsRUFDdEMsRUFBRTtRQUNwQixNQUFNLEVBQUMsSUFBSSxFQUFDLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztRQUVsQyxPQUFPO1lBQ0gsWUFBWTtZQUNaLFVBQVU7WUFDVixHQUFHO1lBQ0gsR0FBRyxDQUFVLEtBQVc7Z0JBQ3BCLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxTQUFTLEVBQUU7b0JBQ2xDLFNBQVMsQ0FBQyxNQUFNLENBQ1osU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQzNCLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLElBQUksWUFBWSxFQUNyQyxLQUFLLEVBQ0wsR0FBRyxJQUFJLENBQ1YsQ0FBQztpQkFDTDtnQkFFRCxJQUFJLENBQUMsR0FBRyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7b0JBQzdCLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRSxRQUFRLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7b0JBRTNELE9BQU87aUJBQ1Y7Z0JBRUQsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDMUIsQ0FBQztTQUNKLENBQUM7SUFDTixDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUMsR0FBb0IsRUFBRSxTQUFpQjtJQUNyRCxPQUFPLDJCQUEyQixNQUFNLENBQ3BDLEdBQUcsQ0FDTixPQUFPLFNBQVMsNkJBQTZCLENBQUM7QUFDbkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dHVpQXNzZXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NsYXNzZXMnO1xuaW1wb3J0IHtUdWlCb29sZWFuSGFuZGxlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay90eXBlcyc7XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBjaGVja2luZyBpbnB1dCBzZXR0ZXIgdmFsdWVzIGFnYWluc3QgYSBjdXN0b20gYXNzZXJ0aW9uIHdoaWNoXG4gKiB0YWtlcyB2YWx1ZSBwYXNzZWQgdG8gaW5wdXQgc2V0dGVyIGFuZCBjb21wb25lbnQgaW5zdGFuY2UgYXMgYXJndW1lbnRzLlxuICogSXQgc3BlY2lmaWNhbGx5IGNoZWNrcyBmb3IgdW5kZWZpbmVkIHZhbHVlcyBhbmQgcHJldmVudHMgY2FsbHMgdG8gdGhlXG4gKiBvcmlnaW5hbCBzZXR0ZXIgaW4gdGhpcyBjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHVpUmVxdWlyZWRTZXR0ZXI8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sIEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgICBhc3NlcnRpb24/OiBUdWlCb29sZWFuSGFuZGxlcjxUW0tdPixcbiAgICAuLi5hcmdzOiBhbnlbXVxuKTogTWV0aG9kRGVjb3JhdG9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0YXJnZXQ6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICAgIGtleSxcbiAgICAgICAge2NvbmZpZ3VyYWJsZSwgZW51bWVyYWJsZSwgZ2V0LCBzZXR9OiBQcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgKTogUHJvcGVydHlEZXNjcmlwdG9yID0+IHtcbiAgICAgICAgY29uc3Qge25hbWV9ID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICAgICAgZ2V0LFxuICAgICAgICAgICAgc2V0KHRoaXM6IFQsIHZhbHVlOiBUW0tdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHR1aUFzc2VydC5hc3NlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRpb24uY2FsbCh0aGlzLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtTdHJpbmcoa2V5KX0gaW4gJHtuYW1lfSByZWNlaXZlZDpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc2V0IHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCBlcnJvclNldChrZXksIG5hbWUpKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBlcnJvclNldChrZXk6IHN0cmluZyB8IHN5bWJvbCwgY29tcG9uZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVW5kZWZpbmVkIHdhcyBwYXNzZWQgYXMgJHtTdHJpbmcoXG4gICAgICAgIGtleSxcbiAgICApfSB0byAke2NvbXBvbmVudH0sIHNldHRlciB3aWxsIG5vdCBiZSBjYWxsZWRgO1xufVxuIl19