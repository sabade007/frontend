import { __extends, __decorate, __param, __spread, __read } from 'tslib';
import { Injectable, ComponentFactoryResolver, Inject, Injector, INJECTOR, Renderer2, ɵɵdefineInjectable, ɵɵinject, ElementRef, ChangeDetectorRef, NgZone, Self } from '@angular/core';
import { ReplaySubject, Observable, merge, defer, fromEvent, of, timer } from 'rxjs';
import { DOCUMENT } from '@angular/common';
import { TUI_DEFAULT_RENDERER, TUI_SWIPE_OPTIONS, TUI_ZOOM_OPTIONS } from '@taiga-ui/cdk/tokens';
import { focusVisibleObservable, watch, typedFromEvent, tuiZoneOptimized, tuiZonefree, preventDefault } from '@taiga-ui/cdk/observables';
import { takeUntil, switchMap, filter, take, mapTo, startWith, distinctUntilChanged, delay, throttleTime, map, switchMapTo, pairwise, repeat, catchError, debounceTime, tap, shareReplay, scan } from 'rxjs/operators';
import { getActualTarget, getElementObscurers } from '@taiga-ui/cdk/utils/dom';
import { WINDOW, ANIMATION_FRAME, PERFORMANCE } from '@ng-web-apis/common';
import { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';
import { RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX, ResizeObserverService } from '@ng-web-apis/resize-observer';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { tuiClamp } from '@taiga-ui/cdk/utils/math';
import { tuiEaseInOutQuad, getSwipeDirection, isPresent } from '@taiga-ui/cdk/utils/miscellaneous';
import { distanceBetweenTouches } from '@taiga-ui/cdk/utils';

/**
 * Observable abstraction over ngOnDestroy to use with takeUntil
 */
var TuiDestroyService = /** @class */ (function (_super) {
    __extends(TuiDestroyService, _super);
    function TuiDestroyService() {
        return _super.call(this, 1) || this;
    }
    TuiDestroyService.prototype.ngOnDestroy = function () {
        this.next();
        this.complete();
    };
    TuiDestroyService = __decorate([
        Injectable()
    ], TuiDestroyService);
    return TuiDestroyService;
}(ReplaySubject));

/**
 * Service to use styles with directives
 * @dynamic
 */
var TuiDirectiveStylesService = /** @class */ (function () {
    function TuiDirectiveStylesService(resolver, injector, documentRef, renderer) {
        this.resolver = resolver;
        this.injector = injector;
        this.documentRef = documentRef;
        this.renderer = renderer;
        this.map = new Map();
    }
    TuiDirectiveStylesService.prototype.addComponent = function (component) {
        if (!this.map.has(component)) {
            this.map.set(component, this.resolver.resolveComponentFactory(component).create(this.injector));
        }
    };
    /** @deprecated use components approach
     * TODO: delete in v3.0
     */
    TuiDirectiveStylesService.prototype.addStyle = function (styles, attribute) {
        if (this.documentRef.head.querySelector("style[" + attribute + "]")) {
            return;
        }
        var style = this.renderer.createElement("style");
        this.renderer.setProperty(style, "textContent", styles);
        this.renderer.setAttribute(style, attribute, "");
        this.documentRef.head.appendChild(style);
    };
    TuiDirectiveStylesService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver, decorators: [{ type: Inject, args: [ComponentFactoryResolver,] }] },
        { type: Injector, decorators: [{ type: Inject, args: [INJECTOR,] }] },
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Renderer2, decorators: [{ type: Inject, args: [TUI_DEFAULT_RENDERER,] }] }
    ]; };
    TuiDirectiveStylesService.ɵprov = ɵɵdefineInjectable({ factory: function TuiDirectiveStylesService_Factory() { return new TuiDirectiveStylesService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(INJECTOR), ɵɵinject(DOCUMENT), ɵɵinject(TUI_DEFAULT_RENDERER)); }, token: TuiDirectiveStylesService, providedIn: "root" });
    TuiDirectiveStylesService = __decorate([
        Injectable({
            providedIn: "root",
        }),
        __param(0, Inject(ComponentFactoryResolver)),
        __param(1, Inject(INJECTOR)),
        __param(2, Inject(DOCUMENT)),
        __param(3, Inject(TUI_DEFAULT_RENDERER))
    ], TuiDirectiveStylesService);
    return TuiDirectiveStylesService;
}());

/**
 * Service to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 * @dynamic
 */
var TuiFocusVisibleService = /** @class */ (function (_super) {
    __extends(TuiFocusVisibleService, _super);
    function TuiFocusVisibleService(_a, changeDetectorRef, destroy$) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) { return _this.focusVisible$.subscribe(subscriber); }) || this;
        _this.focusVisible$ = focusVisibleObservable(nativeElement).pipe(watch(changeDetectorRef), takeUntil(destroy$));
        return _this;
    }
    TuiFocusVisibleService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
    ]; };
    TuiFocusVisibleService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(ChangeDetectorRef)),
        __param(2, Inject(TuiDestroyService))
    ], TuiFocusVisibleService);
    return TuiFocusVisibleService;
}(Observable));

/** @deprecated TODO remove in v3.0 */
// @dynamic
var TuiHoveredService = /** @class */ (function () {
    function TuiHoveredService(documentRef, ngZone) {
        this.ngZone = ngZone;
        this.documentEvents$ = merge(typedFromEvent(documentRef, "mousemove"), typedFromEvent(documentRef, "touchstart", { capture: true }));
    }
    TuiHoveredService.prototype.createHovered$ = function (target, options) {
        var _this = this;
        if (options === void 0) { options = { passive: true }; }
        return merge(typedFromEvent(target, "mouseenter", options), typedFromEvent(target, "touchstart", options)).pipe(switchMap(function () {
            return merge(typedFromEvent(target, "mouseleave", options), _this.documentEvents$.pipe(filter(function (event) { return !target.contains(getActualTarget(event)); }), tuiZoneOptimized(_this.ngZone), take(1))).pipe(mapTo(false), startWith(true));
        }), distinctUntilChanged());
    };
    TuiHoveredService.ctorParameters = function () { return [
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] }
    ]; };
    TuiHoveredService.ɵprov = ɵɵdefineInjectable({ factory: function TuiHoveredService_Factory() { return new TuiHoveredService(ɵɵinject(DOCUMENT), ɵɵinject(NgZone)); }, token: TuiHoveredService, providedIn: "root" });
    TuiHoveredService = __decorate([
        Injectable({
            providedIn: "root",
        }),
        __param(0, Inject(DOCUMENT)),
        __param(1, Inject(NgZone))
    ], TuiHoveredService);
    return TuiHoveredService;
}());

var TUI = "tui_";
/**
 * Generates unique ids
 */
var TuiIdService = /** @class */ (function () {
    function TuiIdService() {
    }
    TuiIdService_1 = TuiIdService;
    TuiIdService.prototype.generate = function () {
        return "" + TUI + TuiIdService_1.autoId++ + Date.now();
    };
    var TuiIdService_1;
    TuiIdService.autoId = 0;
    TuiIdService.ɵprov = ɵɵdefineInjectable({ factory: function TuiIdService_Factory() { return new TuiIdService(); }, token: TuiIdService, providedIn: "root" });
    TuiIdService = TuiIdService_1 = __decorate([
        Injectable({
            providedIn: "root",
        })
    ], TuiIdService);
    return TuiIdService;
}());

/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiParentsScrollService = /** @class */ (function (_super) {
    __extends(TuiParentsScrollService, _super);
    function TuiParentsScrollService(elementRef, windowRef) {
        var _this = _super.call(this, function (subscriber) { return _this.callback$.subscribe(subscriber); }) || this;
        _this.callback$ = defer(function () {
            var nativeElement = elementRef.nativeElement;
            var eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge.apply(void 0, __spread(eventTargets.map(function (element) {
                return typedFromEvent(element, "scroll");
            })));
        });
        return _this;
    }
    TuiParentsScrollService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    TuiParentsScrollService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(WINDOW))
    ], TuiParentsScrollService);
    return TuiParentsScrollService;
}(Observable));

// @bad TODO: Consider Intersection Observer with fallback to current implementation
/**
 * Service that monitors element visibility by subscribing to scrolls
 * and polling with set interval, returns either null or an array
 * of elements that overlap given element edges
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiObscuredService = /** @class */ (function (_super) {
    __extends(TuiObscuredService, _super);
    function TuiObscuredService(parentsScroll$, _a, ngZone, windowRef, destroy$, animationFrame$) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) { return _this.obscured$.subscribe(subscriber); }) || this;
        _this.obscured$ = merge(
        // delay is added so it will not interfere with other listeners
        merge(parentsScroll$, fromEvent(windowRef, "resize")).pipe(delay(0)), animationFrame$.pipe(throttleTime(POLLING_TIME))).pipe(map(function () { return getElementObscurers(nativeElement); }), startWith(null), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$));
        return _this;
    }
    TuiObscuredService.ctorParameters = function () { return [
        { type: TuiParentsScrollService, decorators: [{ type: Inject, args: [TuiParentsScrollService,] }, { type: Self }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
    ]; };
    TuiObscuredService = __decorate([
        Injectable(),
        __param(0, Inject(TuiParentsScrollService)),
        __param(0, Self()),
        __param(1, Inject(ElementRef)),
        __param(2, Inject(NgZone)),
        __param(3, Inject(WINDOW)),
        __param(4, Inject(TuiDestroyService)),
        __param(5, Inject(ANIMATION_FRAME))
    ], TuiObscuredService);
    return TuiObscuredService;
}(Observable));

/**
 * @dynamic
 */
var TuiPanService = /** @class */ (function (_super) {
    __extends(TuiPanService, _super);
    function TuiPanService(_a, documentRef) {
        var nativeElement = _a.nativeElement;
        return _super.call(this, function (subscriber) {
            merge(typedFromEvent(nativeElement, "touchstart", { passive: true }), typedFromEvent(nativeElement, "mousedown"))
                .pipe(switchMapTo(merge(typedFromEvent(documentRef, "touchmove", {
                passive: true,
            }).pipe(filter(function (_a) {
                var touches = _a.touches;
                return touches.length < 2;
            }), map(function (_a) {
                var touches = _a.touches;
                return touches[0];
            })), typedFromEvent(documentRef, "mousemove"))), pairwise(), map(function (_a) {
                var _b = __read(_a, 2), first = _b[0], second = _b[1];
                var deltaX = second.clientX - first.clientX;
                var deltaY = second.clientY - first.clientY;
                return [deltaX, deltaY];
            }), 
            // eslint-disable-next-line rxjs/no-unsafe-takeuntil
            takeUntil(merge(typedFromEvent(documentRef, "touchend"), typedFromEvent(documentRef, "mouseup"))), repeat())
                .subscribe(subscriber);
        }) || this;
    }
    TuiPanService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    TuiPanService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(DOCUMENT))
    ], TuiPanService);
    return TuiPanService;
}(Observable));

// @dynamic
var TuiResizeService = /** @class */ (function (_super) {
    __extends(TuiResizeService, _super);
    function TuiResizeService(elementRef, ngZone, destroy$, support, box, animationFrame$) {
        var _this = _super.call(this, elementRef, ngZone, support, box) || this;
        return _this.pipe(catchError(function () {
            return animationFrame$.pipe(throttleTime(POLLING_TIME), map(function () {
                return elementRef.nativeElement.clientWidth + " " + elementRef.nativeElement.clientHeight;
            }), distinctUntilChanged(), mapTo(EMPTY_ARRAY));
        }), debounceTime(0), tuiZonefree(ngZone), takeUntil(destroy$));
    }
    TuiResizeService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [RESIZE_OBSERVER_SUPPORT,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [RESIZE_OPTION_BOX,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
    ]; };
    TuiResizeService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(NgZone)),
        __param(2, Inject(TuiDestroyService)),
        __param(3, Inject(RESIZE_OBSERVER_SUPPORT)),
        __param(4, Inject(RESIZE_OPTION_BOX)),
        __param(5, Inject(ANIMATION_FRAME))
    ], TuiResizeService);
    return TuiResizeService;
}(ResizeObserverService));

var SCROLL_TIME = 300;
// @dynamic
var TuiScrollService = /** @class */ (function () {
    function TuiScrollService(performanceRef, animationFrame$) {
        this.performanceRef = performanceRef;
        this.animationFrame$ = animationFrame$;
    }
    TuiScrollService.prototype.scroll$ = function (elementOrWindow, scrollTop, scrollLeft, duration) {
        var _this = this;
        if (scrollLeft === void 0) { scrollLeft = getX(elementOrWindow); }
        if (duration === void 0) { duration = SCROLL_TIME; }
        tuiAssert.assert(duration >= 0, "Duration cannot be negative");
        tuiAssert.assert(scrollTop >= 0, "scrollTop cannot be negative");
        tuiAssert.assert(scrollLeft >= 0, "scrollLeft cannot be negative");
        var initialTop = getY(elementOrWindow);
        var initialLeft = getX(elementOrWindow);
        var deltaTop = scrollTop - initialTop;
        var deltaLeft = scrollLeft - initialLeft;
        var observable = !duration
            ? of([scrollTop, scrollLeft])
            : defer(function () { return of(_this.performanceRef.now()); }).pipe(switchMap(function (start) { return _this.animationFrame$.pipe(map(function (now) { return now - start; })); }), map(function (elapsed) { return tuiEaseInOutQuad(tuiClamp(elapsed / duration, 0, 1)); }), map(function (percent) {
                return [
                    initialTop + deltaTop * percent,
                    initialLeft + deltaLeft * percent,
                ];
            }), takeUntil(timer(duration)));
        return observable.pipe(tap(function (_a) {
            var _b = __read(_a, 2), scrollTop = _b[0], scrollLeft = _b[1];
            var _c;
            (_c = elementOrWindow.scrollTo) === null || _c === void 0 ? void 0 : _c.call(elementOrWindow, scrollLeft, scrollTop);
        }));
    };
    TuiScrollService.ctorParameters = function () { return [
        { type: Performance, decorators: [{ type: Inject, args: [PERFORMANCE,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
    ]; };
    TuiScrollService.ɵprov = ɵɵdefineInjectable({ factory: function TuiScrollService_Factory() { return new TuiScrollService(ɵɵinject(PERFORMANCE), ɵɵinject(ANIMATION_FRAME)); }, token: TuiScrollService, providedIn: "root" });
    TuiScrollService = __decorate([
        Injectable({
            providedIn: "root",
        }),
        __param(0, Inject(PERFORMANCE)),
        __param(1, Inject(ANIMATION_FRAME))
    ], TuiScrollService);
    return TuiScrollService;
}());
function getX(elementOrWindow) {
    return "scrollX" in elementOrWindow
        ? elementOrWindow.scrollX
        : elementOrWindow.scrollLeft;
}
function getY(elementOrWindow) {
    return "scrollY" in elementOrWindow
        ? elementOrWindow.scrollY
        : elementOrWindow.scrollTop;
}

var TuiStaticRequestService = /** @class */ (function () {
    function TuiStaticRequestService() {
        this.cache = new Map();
    }
    TuiStaticRequestService.prototype.request = function (url) {
        var cache = this.cache.get(url);
        if (cache) {
            return cache;
        }
        var observable = new Observable(function (observer) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var response = xhr.responseType ? xhr.response : xhr.responseText;
                    if (xhr.status === 200) {
                        observer.next(response);
                        observer.complete();
                    }
                    else {
                        observer.error(response);
                    }
                }
            };
            xhr.open("GET", url);
            xhr.send();
            return function () {
                xhr.abort();
            };
        });
        var piped = observable.pipe(shareReplay({ bufferSize: 1, refCount: false }));
        this.cache.set(url, piped);
        return piped;
    };
    TuiStaticRequestService.ɵprov = ɵɵdefineInjectable({ factory: function TuiStaticRequestService_Factory() { return new TuiStaticRequestService(); }, token: TuiStaticRequestService, providedIn: "root" });
    TuiStaticRequestService = __decorate([
        Injectable({
            providedIn: "root",
        })
    ], TuiStaticRequestService);
    return TuiStaticRequestService;
}());

/**
 * @dynamic
 */
var TuiSwipeService = /** @class */ (function (_super) {
    __extends(TuiSwipeService, _super);
    function TuiSwipeService(_a, _b, documentRef) {
        var nativeElement = _a.nativeElement;
        var timeout = _b.timeout, threshold = _b.threshold;
        return _super.call(this, function (subscriber) {
            merge(typedFromEvent(nativeElement, "touchstart", { passive: true }), typedFromEvent(documentRef, "touchend"))
                .pipe(pairwise(), filter(function (_a) {
                var _b = __read(_a, 2), first = _b[0], second = _b[1];
                return !!first.touches.length &&
                    first.touches[0].identifier ===
                        second.changedTouches[0].identifier;
            }), map(function (_a) {
                var _b = __read(_a, 2), start = _b[0], end = _b[1];
                var startX = start.touches[0].clientX;
                var startY = start.touches[0].clientY;
                var endX = end.changedTouches[0].clientX;
                var endY = end.changedTouches[0].clientY;
                var distanceX = startX - endX;
                var distanceY = startY - endY;
                var duration = end.timeStamp - start.timeStamp;
                if ((Math.abs(distanceX) > threshold ||
                    Math.abs(distanceY) > threshold) &&
                    duration < timeout) {
                    return {
                        direction: getSwipeDirection(distanceX, distanceY),
                        events: [start, end],
                    };
                }
                return null;
            }), filter(isPresent))
                .subscribe(subscriber);
        }) || this;
    }
    TuiSwipeService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_SWIPE_OPTIONS,] }] },
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    TuiSwipeService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(TUI_SWIPE_OPTIONS)),
        __param(2, Inject(DOCUMENT))
    ], TuiSwipeService);
    return TuiSwipeService;
}(Observable));

var TOUCH_SENSITIVITY = 0.01;
// @dynamic
var TuiZoomService = /** @class */ (function (_super) {
    __extends(TuiZoomService, _super);
    function TuiZoomService(_a, _b) {
        var nativeElement = _a.nativeElement;
        var wheelSensitivity = _b.wheelSensitivity;
        return _super.call(this, function (subscriber) {
            merge(typedFromEvent(nativeElement, "touchstart", { passive: true }).pipe(filter(function (_a) {
                var touches = _a.touches;
                return touches.length > 1;
            }), switchMap(function (startEvent) {
                return typedFromEvent(nativeElement, "touchmove", {
                    passive: true,
                }).pipe(preventDefault(), scan(function (prev, event) {
                    var distance = distanceBetweenTouches(event);
                    return {
                        event: event,
                        distance: distance,
                        delta: (distance - prev.distance) *
                            TOUCH_SENSITIVITY,
                    };
                }, {
                    event: startEvent,
                    distance: distanceBetweenTouches(startEvent),
                    delta: 0,
                }), map(function (_a) {
                    var event = _a.event, delta = _a.delta;
                    var clientX = (event.touches[0].clientX +
                        event.touches[1].clientX) /
                        2;
                    var clientY = (event.touches[0].clientY +
                        event.touches[1].clientY) /
                        2;
                    return { clientX: clientX, clientY: clientY, delta: delta, event: event };
                }), takeUntil(typedFromEvent(nativeElement, "touchend")));
            })), typedFromEvent(nativeElement, "wheel", { passive: false }).pipe(preventDefault(), map(function (wheel) { return ({
                clientX: wheel.clientX,
                clientY: wheel.clientY,
                delta: -wheel.deltaY * wheelSensitivity,
                event: wheel,
            }); }))).subscribe(subscriber);
        }) || this;
    }
    TuiZoomService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_ZOOM_OPTIONS,] }] }
    ]; };
    TuiZoomService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(TUI_ZOOM_OPTIONS))
    ], TuiZoomService);
    return TuiZoomService;
}(Observable));

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiHoveredService, TuiIdService, TuiObscuredService, TuiPanService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService, TuiSwipeService, TuiZoomService };
//# sourceMappingURL=taiga-ui-cdk-services.js.map
