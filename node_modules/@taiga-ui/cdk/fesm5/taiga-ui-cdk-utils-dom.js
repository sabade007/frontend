import { clamp } from '@taiga-ui/cdk/utils/math';
import { isPresent } from '@taiga-ui/cdk/utils/miscellaneous';
import { tuiAssert } from '@taiga-ui/cdk/classes';

/**
 * @deprecated: use {@link tuiCanScroll} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function canScroll(element, rootElement, vertical, scrollEnd) {
    return vertical
        ? canScrollVertical(element, rootElement, scrollEnd)
        : canScrollHorizontal(element, rootElement, scrollEnd);
}
var tuiCanScroll = canScroll;
function canScrollVertical(element, rootElement, scrollEnd) {
    var currentElement = element;
    while (currentElement !== rootElement.parentElement) {
        if ((Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||
            (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <
                currentElement.scrollHeight &&
                scrollEnd)) {
            return true;
        }
        if (currentElement.parentElement) {
            currentElement = currentElement.parentElement;
        }
        else {
            return false;
        }
    }
    return false;
}
function canScrollHorizontal(element, rootElement, scrollEnd) {
    var currentElement = element;
    while (currentElement !== rootElement.parentElement) {
        if ((Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||
            (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <
                currentElement.scrollWidth &&
                scrollEnd)) {
            return true;
        }
        if (currentElement.parentElement) {
            currentElement = currentElement.parentElement;
        }
        else {
            return false;
        }
    }
    return false;
}

/**
 * @deprecated: use {@link tuiContainsOrAfter} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function containsOrAfter(current, node) {
    return (current.contains(node) ||
        !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING));
}
var tuiContainsOrAfter = containsOrAfter;

/** @deprecated only needed for IE, remove in 3.0 */
function tuiCustomEvent(name, _a, documentRef) {
    var _b = _a === void 0 ? {} : _a, _c = _b.bubbles, bubbles = _c === void 0 ? false : _c, _d = _b.cancelable, cancelable = _d === void 0 ? false : _d, _e = _b.detail, detail = _e === void 0 ? null : _e;
    if (typeof CustomEvent === "function") {
        return new CustomEvent(name, { bubbles: bubbles, cancelable: cancelable, detail: detail });
    }
    var customEvent = documentRef.createEvent("CustomEvent");
    customEvent.initCustomEvent(name, bubbles, cancelable, detail);
    return customEvent;
}

/**
 * @deprecated: use {@link tuiGetActualTarget} instead
 * Gets actual target from open Shadow DOM if event happened within it
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getActualTarget(event) {
    if ("composedPath" in event) {
        return event.composedPath()[0];
    }
    return event.target;
}
var tuiGetActualTarget = getActualTarget;

var DEFAULT_FORMAT = "text/plain";
/**
 * @deprecated: use {@link tuiGetClipboardDataText} instead
 * Gets text from data of clipboardEvent, it also works in IE and Edge browsers
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getClipboardDataText(event, format) {
    if (format === void 0) { format = DEFAULT_FORMAT; }
    return "clipboardData" in event && event.clipboardData !== null
        ? event.clipboardData.getData(format) ||
            event.clipboardData.getData(DEFAULT_FORMAT)
        : event.target.ownerDocument.defaultView.clipboardData.getData("text");
}
var tuiGetClipboardDataText = getClipboardDataText;

/**
 * @deprecated only needed for IE, remove in 3.0
 * Gets the closest element by selector i.e. {@link Element.closest}
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getClosestElement(element, selector) {
    var closest = Element.prototype.closest;
    if (closest) {
        return closest.call(element, selector);
    }
    var matchesSelector = Element.prototype.matches || Element.prototype.msMatchesSelector;
    do {
        if (matchesSelector.call(element, selector)) {
            return element;
        }
        element = element.parentElement;
    } while (element !== null);
    return null;
}

/**
 * @deprecated: use {@link tuiGetDocumentOrShadowRoot} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getDocumentOrShadowRoot(node) {
    return "getRootNode" in node && node.isConnected
        ? node.getRootNode()
        : node.ownerDocument;
}
var tuiGetDocumentOrShadowRoot = getDocumentOrShadowRoot;

/**
 * @deprecated: use {@link tuiGetElementObscures} instead
 * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible
 *
 * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getElementObscurers(element) {
    var ownerDocument = element.ownerDocument;
    if (!(ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.defaultView)) {
        return null;
    }
    var _a = ownerDocument.defaultView, innerWidth = _a.innerWidth, innerHeight = _a.innerHeight;
    var documentRef = getDocumentOrShadowRoot(element);
    var rect = element.getBoundingClientRect();
    var left = clamp(Math.round(rect.left) + 2, 0, innerWidth);
    var top = clamp(Math.round(rect.top) + 2, 0, innerHeight);
    var right = clamp(Math.round(rect.right) - 2, 0, innerWidth);
    var bottom = clamp(Math.round(rect.bottom) - 2, 0, innerHeight);
    var horizontalMiddle = clamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);
    var verticalMiddle = clamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);
    var elements = [
        documentRef.elementFromPoint(horizontalMiddle, top),
        documentRef.elementFromPoint(horizontalMiddle, bottom),
        documentRef.elementFromPoint(left, verticalMiddle),
        documentRef.elementFromPoint(right, verticalMiddle),
    ];
    var nonNull = elements.filter(isPresent);
    if (!nonNull.length) {
        return nonNull;
    }
    var filtered = nonNull.filter(function (el) { return !element.contains(el); });
    return filtered.length === 4 ? filtered : null;
}
var tuiGetElementObscures = getElementObscurers;

/**
 * @deprecated: use {@link tuiGetElementOffset} instead
 * Calculates offset for an element relative to it's parent several levels above
 *
 * @param host parent element
 * @param element
 * @return object with offsetTop and offsetLeft number properties
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getElementOffset(host, element) {
    tuiAssert.assert(host.contains(element), "Host must contain element");
    var offsetTop = element.offsetTop, offsetLeft = element.offsetLeft, offsetParent = element.offsetParent;
    // TODO: iframe warning
    while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {
        offsetTop += offsetParent.offsetTop;
        offsetLeft += offsetParent.offsetLeft;
        offsetParent = offsetParent.offsetParent;
    }
    return { offsetTop: offsetTop, offsetLeft: offsetLeft };
}
var tuiGetElementOffset = getElementOffset;

/**
 * @deprecated: use {@link tuiGetScrollParent} instead
 * Finds the nearest parent with scroll in it
 *
 * @param element initial element
 * @param vertical flag for orientation of scroll
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getScrollParent(element, vertical) {
    if (vertical === void 0) { vertical = true; }
    if (element === null) {
        return null;
    }
    if (vertical && element.scrollHeight > element.clientHeight) {
        return element;
    }
    if (!vertical && element.scrollWidth > element.clientWidth) {
        return element;
    }
    return getScrollParent(element.parentElement, vertical);
}
var tuiGetScrollParent = getScrollParent;

function tuiIsFormFieldElement(element) {
    var textfield = element;
    return (!!textfield &&
        "value" in textfield &&
        "selectionStart" in textfield &&
        "selectionEnd" in textfield);
}

/**
 * @description:
 * cross browser way to get selected text
 *
 * History:
 * BUG - window.getSelection() fails when text selected in a form field
 * https://bugzilla.mozilla.org/show_bug.cgi?id=85686
 */
function tuiGetSelectedText(_a) {
    var getSelection = _a.getSelection, document = _a.document;
    var _b;
    return tuiIsFormFieldElement(document.activeElement)
        ? document.activeElement.value.slice(document.activeElement.selectionStart || 0, document.activeElement.selectionEnd || 0)
        : ((_b = getSelection()) === null || _b === void 0 ? void 0 : _b.toString()) || null;
}

/**
 * @deprecated: use {@link tuiIsCurrentTarget} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isCurrentTarget(_a) {
    var target = _a.target, currentTarget = _a.currentTarget;
    return target === currentTarget;
}
var tuiIsCurrentTarget = isCurrentTarget;

// TODO: Refactor to use this check everywhere
function tuiIsElement(node) {
    return !!node && "nodeType" in node && node.nodeType === Node.ELEMENT_NODE;
}

/**
 * @deprecated: use {@link tuiIsInsideIframe} instead
 * Checks if an app is running inside <iframe /> tag
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isInsideIframe(windowRef) {
    return windowRef.parent !== windowRef;
}
var tuiIsInsideIframe = isInsideIframe;

/**
 * @deprecated: use {@link tuiIsNodeIn} instead
 * Checks if node is inside a specific selector
 *
 * @param node
 * @param selector
 * @return true if node is inside a particular selector
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function isNodeIn(node, selector) {
    return node.nodeType === Node.TEXT_NODE
        ? !!node.parentElement && !!getClosestElement(node.parentElement, selector)
        : node.nodeType === Node.ELEMENT_NODE &&
            !!getClosestElement(node, selector);
}
var tuiIsNodeIn = isNodeIn;

function tuiPointToClientRect(x, y) {
    if (x === void 0) { x = 0; }
    if (y === void 0) { y = 0; }
    return {
        left: x,
        right: x,
        top: y,
        bottom: y,
        width: 0,
        height: 0,
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { canScroll, containsOrAfter, getActualTarget, getClipboardDataText, getClosestElement, getDocumentOrShadowRoot, getElementObscurers, getElementOffset, getScrollParent, isCurrentTarget, isInsideIframe, isNodeIn, tuiCanScroll, tuiContainsOrAfter, tuiCustomEvent, tuiGetActualTarget, tuiGetClipboardDataText, tuiGetDocumentOrShadowRoot, tuiGetElementObscures, tuiGetElementOffset, tuiGetScrollParent, tuiGetSelectedText, tuiIsCurrentTarget, tuiIsElement, tuiIsFormFieldElement, tuiIsInsideIframe, tuiIsNodeIn, tuiPointToClientRect };
//# sourceMappingURL=taiga-ui-cdk-utils-dom.js.map
