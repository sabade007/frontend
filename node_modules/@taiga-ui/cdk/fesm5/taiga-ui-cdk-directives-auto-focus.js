import { __decorate, __extends, __param, __values } from 'tslib';
import { ElementRef, Directive, Optional, Self, Inject, Renderer2, NgZone, InjectionToken, Input, NgModule } from '@angular/core';
import { ANIMATION_FRAME, WINDOW } from '@ng-web-apis/common';
import { TUI_FOCUSABLE_ITEM_ACCESSOR, TUI_IS_IOS } from '@taiga-ui/cdk/tokens';
import { POLLING_TIME } from '@taiga-ui/cdk/constants';
import { race, timer, Observable } from 'rxjs';
import { throttleTime, map, skipWhile, take } from 'rxjs/operators';
import { tuiPx } from '@taiga-ui/cdk/utils';

var AbstractTuiAutofocusHandler = /** @class */ (function () {
    function AbstractTuiAutofocusHandler(tuiFocusableComponent, elementRef) {
        this.tuiFocusableComponent = tuiFocusableComponent;
        this.elementRef = elementRef;
    }
    Object.defineProperty(AbstractTuiAutofocusHandler.prototype, "element", {
        get: function () {
            var _a;
            return (((_a = this.tuiFocusableComponent) === null || _a === void 0 ? void 0 : _a.nativeFocusableElement) ||
                this.elementRef.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiAutofocusHandler.prototype, "isTextFieldElement", {
        get: function () {
            return this.element.matches("input, textarea");
        },
        enumerable: true,
        configurable: true
    });
    AbstractTuiAutofocusHandler.ctorParameters = function () { return [
        { type: undefined },
        { type: ElementRef }
    ]; };
    AbstractTuiAutofocusHandler = __decorate([
        Directive()
    ], AbstractTuiAutofocusHandler);
    return AbstractTuiAutofocusHandler;
}());

var TIMEOUT = 1000;
var NG_ANIMATION_SELECTOR = ".ng-animating";
var TuiDefaultAutofocusHandler = /** @class */ (function (_super) {
    __extends(TuiDefaultAutofocusHandler, _super);
    function TuiDefaultAutofocusHandler(tuiFocusableComponent, elementRef, animationFrame$) {
        var _this = _super.call(this, tuiFocusableComponent, elementRef) || this;
        _this.animationFrame$ = animationFrame$;
        return _this;
    }
    TuiDefaultAutofocusHandler.prototype.setFocus = function () {
        var _this = this;
        if (this.isTextFieldElement) {
            race(timer(TIMEOUT), this.animationFrame$.pipe(throttleTime(POLLING_TIME), map(function () { return _this.element.closest(NG_ANIMATION_SELECTOR); }), skipWhile(Boolean), take(1))).subscribe(function () { return _this.element.focus(); });
        }
        else {
            this.element.focus();
        }
    };
    TuiDefaultAutofocusHandler.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
    ]; };
    TuiDefaultAutofocusHandler = __decorate([
        Directive(),
        __param(0, Optional()),
        __param(0, Self()),
        __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
        __param(1, Inject(ElementRef)),
        __param(2, Inject(ANIMATION_FRAME))
    ], TuiDefaultAutofocusHandler);
    return TuiDefaultAutofocusHandler;
}(AbstractTuiAutofocusHandler));

// @dynamic
var TuiIosAutofocusHandler = /** @class */ (function (_super) {
    __extends(TuiIosAutofocusHandler, _super);
    function TuiIosAutofocusHandler(tuiFocusableComponent, elementRef, renderer, ngZone, windowRef) {
        var _this = _super.call(this, tuiFocusableComponent, elementRef) || this;
        _this.renderer = renderer;
        _this.ngZone = ngZone;
        _this.windowRef = windowRef;
        _this.patchCssStyles();
        return _this;
    }
    TuiIosAutofocusHandler.prototype.setFocus = function () {
        var _this = this;
        if (this.isTextFieldElement) {
            this.ngZone.runOutsideAngular(function () { return _this.iosWebkitAutofocus(); });
        }
        else {
            this.element.focus();
        }
    };
    TuiIosAutofocusHandler.prototype.iosWebkitAutofocus = function () {
        var _this = this;
        var _a;
        var fakeInput = this.makeFakeInput();
        var duration = this.getDurationTimeBeforeFocus();
        var fakeFocusTimeoutId = 0;
        var elementFocusTimeoutId = 0;
        var blurHandler = function () { return fakeInput.focus({ preventScroll: true }); };
        var focusHandler = function () {
            clearTimeout(fakeFocusTimeoutId);
            fakeFocusTimeoutId = _this.windowRef.setTimeout(function () {
                clearTimeout(elementFocusTimeoutId);
                fakeInput.removeEventListener("blur", blurHandler);
                fakeInput.removeEventListener("focus", focusHandler);
                elementFocusTimeoutId = _this.windowRef.setTimeout(function () {
                    _this.element.focus({ preventScroll: false });
                    fakeInput.remove();
                }, duration);
            });
        };
        fakeInput.addEventListener("blur", blurHandler, { once: true });
        fakeInput.addEventListener("focus", focusHandler);
        if (this.insideDialog()) {
            this.windowRef.document.body.appendChild(fakeInput);
        }
        else {
            (_a = this.element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(fakeInput);
        }
        fakeInput.focus({ preventScroll: true });
    };
    /**
     * @note:
     * emulate textfield position in layout with cursor
     * before focus to real textfield element
     */
    TuiIosAutofocusHandler.prototype.makeFakeInput = function () {
        var fakeInput = this.renderer.createElement("input");
        var rect = this.element.getBoundingClientRect();
        fakeInput.setAttribute("maxlength", "0");
        // @note: don't use opacity: 0,
        // sometimes it's doesn't work for emulate real input
        fakeInput.style.height = tuiPx(rect.height);
        fakeInput.style.width = tuiPx(rect.width / 2);
        fakeInput.style.position = "fixed";
        fakeInput.style.zIndex = "-99999999";
        fakeInput.style.caretColor = "transparent";
        fakeInput.style.color = "transparent";
        fakeInput.style.cursor = "none";
        fakeInput.style.fontSize = tuiPx(16); // disable possible auto zoom
        fakeInput.readOnly = true; // prevent keyboard for fake input
        // @note: emulate position cursor before focus to real textfield element
        fakeInput.style.top = tuiPx(rect.top);
        fakeInput.style.left = tuiPx(rect.left);
        return fakeInput;
    };
    TuiIosAutofocusHandler.prototype.getDurationTimeBeforeFocus = function () {
        return (parseFloat(this.windowRef
            .getComputedStyle(this.element)
            .getPropertyValue("--tui-duration")) || 0);
    };
    /**
     * @note:
     * unfortunately, in older versions of iOS
     * there is a bug that the fake input cursor
     * will move along with the dialog animation
     * and then that dialog will be shaking
     */
    TuiIosAutofocusHandler.prototype.insideDialog = function () {
        return !!this.element.closest("tui-dialog");
    };
    /**
     * @note:
     * This is necessary so that the viewport isn't recalculated
     * and then the dialogs don't shake.
     *
     * Also, we need to fixed height viewport,
     * so that when focusing the dialogs don't shake
     */
    TuiIosAutofocusHandler.prototype.patchCssStyles = function () {
        var e_1, _a;
        var documentRef = this.windowRef.document;
        try {
            for (var _b = __values([documentRef.documentElement, documentRef.body]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var element = _c.value;
                element.style.setProperty("overflow", "auto");
                element.style.setProperty("height", "100%");
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    TuiIosAutofocusHandler.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    TuiIosAutofocusHandler = __decorate([
        Directive(),
        __param(0, Optional()),
        __param(0, Self()),
        __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
        __param(1, Inject(ElementRef)),
        __param(2, Inject(Renderer2)),
        __param(3, Inject(NgZone)),
        __param(4, Inject(WINDOW))
    ], TuiIosAutofocusHandler);
    return TuiIosAutofocusHandler;
}(AbstractTuiAutofocusHandler));

var TUI_AUTOFOCUS_HANDLER = new InjectionToken("Autofocusing handler");
// TODO: 3.0 remove in ivy compilation
function tuiAutofocusHandlerFactory(tuiFocusableComponent, elementRef, animationFrame$, renderer, ngZone, windowRef, isIos) {
    return isIos
        ? new TuiIosAutofocusHandler(tuiFocusableComponent, elementRef, renderer, ngZone, windowRef)
        : new TuiDefaultAutofocusHandler(tuiFocusableComponent, elementRef, animationFrame$);
}
var TUI_AUTOFOCUS_PROVIDERS = [
    {
        provide: TUI_AUTOFOCUS_HANDLER,
        // TODO: replace to useClass in v3.0
        useFactory: tuiAutofocusHandlerFactory,
        deps: [
            [new Optional(), new Self(), TUI_FOCUSABLE_ITEM_ACCESSOR],
            ElementRef,
            ANIMATION_FRAME,
            Renderer2,
            NgZone,
            WINDOW,
            TUI_IS_IOS,
        ],
    },
];

// TODO: 3.0 change input name to tuiAutoFocus and handle empty string
var TuiAutoFocusDirective = /** @class */ (function () {
    function TuiAutoFocusDirective(handler) {
        this.handler = handler;
        this.autoFocus = true;
    }
    TuiAutoFocusDirective.prototype.ngAfterViewInit = function () {
        if (this.autoFocus) {
            this.focus();
        }
    };
    TuiAutoFocusDirective.prototype.focus = function () {
        var _this = this;
        void Promise.resolve().then(function () { return _this.handler.setFocus(); });
    };
    TuiAutoFocusDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [TUI_AUTOFOCUS_HANDLER,] }] }
    ]; };
    __decorate([
        Input()
    ], TuiAutoFocusDirective.prototype, "autoFocus", void 0);
    TuiAutoFocusDirective = __decorate([
        Directive({
            selector: '[tuiAutoFocus]',
            providers: TUI_AUTOFOCUS_PROVIDERS,
        }),
        __param(0, Inject(TUI_AUTOFOCUS_HANDLER))
    ], TuiAutoFocusDirective);
    return TuiAutoFocusDirective;
}());

var TuiAutoFocusModule = /** @class */ (function () {
    function TuiAutoFocusModule() {
    }
    TuiAutoFocusModule = __decorate([
        NgModule({
            declarations: [TuiAutoFocusDirective],
            exports: [TuiAutoFocusDirective],
        })
    ], TuiAutoFocusModule);
    return TuiAutoFocusModule;
}());

var TuiSynchronousAutofocusHandler = /** @class */ (function (_super) {
    __extends(TuiSynchronousAutofocusHandler, _super);
    function TuiSynchronousAutofocusHandler(tuiFocusableComponent, elementRef) {
        return _super.call(this, tuiFocusableComponent, elementRef) || this;
    }
    TuiSynchronousAutofocusHandler.prototype.setFocus = function () {
        this.element.focus();
    };
    TuiSynchronousAutofocusHandler.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] }
    ]; };
    TuiSynchronousAutofocusHandler = __decorate([
        Directive(),
        __param(0, Optional()),
        __param(0, Self()),
        __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
        __param(1, Inject(ElementRef))
    ], TuiSynchronousAutofocusHandler);
    return TuiSynchronousAutofocusHandler;
}(AbstractTuiAutofocusHandler));

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiAutofocusHandler, TUI_AUTOFOCUS_HANDLER, TUI_AUTOFOCUS_PROVIDERS, TuiAutoFocusDirective, TuiAutoFocusModule, TuiDefaultAutofocusHandler, TuiIosAutofocusHandler, TuiSynchronousAutofocusHandler, tuiAutofocusHandlerFactory };
//# sourceMappingURL=taiga-ui-cdk-directives-auto-focus.js.map
