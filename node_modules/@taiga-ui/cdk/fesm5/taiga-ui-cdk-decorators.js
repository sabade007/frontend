import { __spread } from 'tslib';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { TuiPureException } from '@taiga-ui/cdk/exceptions';

/**
 * Decorator for checking input values for undefined. You can also pass
 * optional assertion to check input against.
 *
 * CAUTION: This decorator overwrites other getters and setters.
 */
function tuiDefaultProp(assertion) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (target, key) {
        var name = target.constructor.name;
        var errorGetDefaultMessage = errorGetDefault(key, name);
        var errorSetDefaultMessage = errorSetDefault(key, name);
        Object.defineProperty(target, key, {
            configurable: true,
            get: function () {
                tuiAssert.assert(false, errorGetDefaultMessage);
                return undefined;
            },
            set: function (initialValue) {
                var isValid = initialValue !== undefined;
                var errorMessage = errorSetDefaultInitial(key, name);
                var currentValue = initialValue;
                tuiAssert.assert(isValid, errorMessage);
                if (isValid && assertion) {
                    tuiAssert.assert.apply(tuiAssert, __spread([assertion.call(this, initialValue),
                        String(key) + " in " + name + " received:",
                        initialValue], args));
                }
                Object.defineProperty(this, key, {
                    configurable: true,
                    get: function () {
                        return currentValue;
                    },
                    set: function (value) {
                        var isValid = value !== undefined;
                        var backupValue = initialValue;
                        tuiAssert.assert(isValid, errorSetDefaultMessage, String(backupValue));
                        if (isValid && assertion) {
                            tuiAssert.assert.apply(tuiAssert, __spread([assertion.call(this, value),
                                String(key) + " in " + name + " received:",
                                value], args));
                        }
                        currentValue = isValid ? value : backupValue;
                    },
                });
            },
        });
    };
}
function errorGetDefault(key, component) {
    return "Default value for " + String(key) + " was not provided in " + component + ", error in Taiga UI Angular Kit";
}
function errorSetDefault(key, component) {
    return "Undefined was passed as " + String(key) + " to " + component + ", which is invalid input, using default value:";
}
function errorSetDefaultInitial(key, component) {
    return "Undefined was passed as default value for " + String(key) + " to " + component + ", error in Taiga UI Angular Kit";
}

/**
 * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.
 * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned
 * value for function, skipping calculation when arguments are strictly the same.
 *
 * @throws error if used not on getter or function
 *
 * CAUTION: `this` is not available inside such functions/getters, they must be pure.
 */
function tuiPure(_target, propertyKey, _a) {
    var get = _a.get, enumerable = _a.enumerable, value = _a.value;
    if (get) {
        return {
            configurable: true,
            enumerable: enumerable,
            get: function () {
                var value = get.call(this);
                Object.defineProperty(this, propertyKey, { enumerable: enumerable, value: value });
                return value;
            },
        };
    }
    if (typeof value !== "function") {
        throw new TuiPureException();
    }
    var original = value;
    return {
        configurable: true,
        enumerable: enumerable,
        get: function () {
            var _this = this;
            var previousArgs = [];
            var originalFnWasCalledLeastAtOnce = false;
            var pureValue;
            var patched = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var isPure = originalFnWasCalledLeastAtOnce &&
                    previousArgs.length === args.length &&
                    args.every(function (arg, index) { return arg === previousArgs[index]; });
                if (isPure) {
                    return pureValue;
                }
                previousArgs = args;
                pureValue = original.apply(_this, args);
                originalFnWasCalledLeastAtOnce = true;
                return pureValue;
            };
            Object.defineProperty(this, propertyKey, {
                configurable: true,
                value: patched,
            });
            return patched;
        },
    };
}

/**
 * Decorator for checking input setter values against a custom assertion which
 * takes value passed to input setter and component instance as arguments.
 * It specifically checks for undefined values and prevents calls to the
 * original setter in this case.
 */
function tuiRequiredSetter(assertion) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (target, key, _a) {
        var configurable = _a.configurable, enumerable = _a.enumerable, get = _a.get, set = _a.set;
        var name = target.constructor.name;
        return {
            configurable: configurable,
            enumerable: enumerable,
            get: get,
            set: function (value) {
                if (value !== undefined && assertion) {
                    tuiAssert.assert.apply(tuiAssert, __spread([assertion.call(this, value),
                        String(key) + " in " + name + " received:",
                        value], args));
                }
                if (!set || value === undefined) {
                    tuiAssert.assert(value !== undefined, errorSet(key, name));
                    return;
                }
                set.call(this, value);
            },
        };
    };
}
function errorSet(key, component) {
    return "Undefined was passed as " + String(key) + " to " + component + ", setter will not be called";
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiDefaultProp, tuiPure, tuiRequiredSetter };
//# sourceMappingURL=taiga-ui-cdk-decorators.js.map
