import { InjectionToken, inject } from '@angular/core';
import { CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk/constants';
import { __extends } from 'tslib';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { InvalidYearException, InvalidMonthException, InvalidDayException } from '@taiga-ui/cdk/exceptions';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';

var DAYS_IN_WEEK = 7;
var DAYS_IN_NORMAL_YEAR = 365;
var DAYS_IN_LEAP_YEAR = 366;
var MONTHS_IN_YEAR = 12;
var MIN_DAY = 1;
var MIN_MONTH = 0;
var MAX_MONTH = 11;
var MIN_YEAR = 0;
var MAX_YEAR = 9999;
var RANGE_SEPARATOR_CHAR = "" + CHAR_NO_BREAK_SPACE + CHAR_EN_DASH + CHAR_NO_BREAK_SPACE;
var MILLISECONDS_IN_SECOND = 1000;
var SECONDS_IN_MINUTE = 60;
var MINUTES_IN_HOUR = 60;
var HOURS_IN_DAY = 24;
var MILLISECONDS_IN_MINUTE = MILLISECONDS_IN_SECOND * SECONDS_IN_MINUTE;
var MILLISECONDS_IN_HOUR = MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR;
var MILLISECONDS_IN_DAY = MILLISECONDS_IN_HOUR * HOURS_IN_DAY;

/**
 * @deprecated dont use it. See {@link TUI_DATE_FORMAT}
 */
var TUI_DATE_FILLER = new InjectionToken("date filler for Taiga UI", {
    factory: function () { return "dd.mm.yyyy"; },
});
/**
 * @deprecated dont use it
 */
var TUI_DATE_RANGE_FILLER = new InjectionToken("date range filler for Taiga UI", {
    factory: function () {
        var dateFiller = inject(TUI_DATE_FILLER);
        return "" + dateFiller + RANGE_SEPARATOR_CHAR + dateFiller;
    },
});
/**
 * @internal 'dd.mm.yyyy'.length
 * Used in:
 * - {@link TuiInputDateComponent}
 * - {@link TuiInputDateRangeComponent}
 * - {@link TuiInputDateTimeComponent}
 */
var DATE_FILLER_LENGTH = 10;
/**
 * @internal
 * Used in {@link TuiInputDateRangeComponent}
 */
var DATE_RANGE_FILLER_LENGTH = 2 * DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length;

var TUI_DATE_FORMAT = new InjectionToken("Active date format for Taiga UI", {
    factory: function () { return "DMY"; },
});

var TUI_DATE_SEPARATOR = new InjectionToken("Date separator for Taiga UI components", {
    factory: function () { return "."; },
});
var changeDateSeparator = function (dateString, newDateSeparator) { return dateString.replace(/[^0-9A-Za-zА-Яа-я]/gi, newDateSeparator); };

/**
 * Immutable year object
 * @nosideeffects
 */
var TuiYear = /** @class */ (function () {
    function TuiYear(year) {
        this.year = year;
        tuiAssert.assert(TuiYear.isValidYear(year));
    }
    /**
     * Checks year for validity
     */
    TuiYear.isValidYear = function (year) {
        return Number.isInteger(year) && inRange(year, MIN_YEAR, MAX_YEAR + 1);
    };
    /**
     * Check if passed year is a leap year
     */
    TuiYear.isLeapYear = function (year) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
    };
    /**
     * Returns amount of leap years from year 0 to the passed one
     */
    TuiYear.getAbsoluteLeapYears = function (year) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));
    };
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Returns day of week offset of the beginning of the passed year
     *
     * @param year
     * @param absoluteLeapYears amount of leap years prior to the passed one
     * @return offset in days
     */
    TuiYear.getYearStartDaysOffset = function (year, absoluteLeapYears) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        tuiAssert.assert(Number.isInteger(absoluteLeapYears));
        tuiAssert.assert(year >= absoluteLeapYears);
        tuiAssert.assert(absoluteLeapYears >= 0);
        return ((absoluteLeapYears * DAYS_IN_LEAP_YEAR +
            (year - absoluteLeapYears) * DAYS_IN_NORMAL_YEAR +
            5) %
            DAYS_IN_WEEK);
    };
    TuiYear.lengthBetween = function (from, to) {
        return to.year - from.year;
    };
    /**
     * Normalizes year by clamping it between min and max years
     */
    TuiYear.normalizeYearPart = function (year) {
        return normalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);
    };
    Object.defineProperty(TuiYear.prototype, "formattedYear", {
        get: function () {
            return padStart(String(this.year), 4, "0");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiYear.prototype, "isLeapYear", {
        get: function () {
            return TuiYear.isLeapYear(this.year);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiYear.prototype, "absoluteLeapYears", {
        /**
         * Returns amount of leap years from year 0 to current
         */
        get: function () {
            return TuiYear.getAbsoluteLeapYears(this.year);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiYear.prototype, "yearStartDaysOffset", {
        /**
         * @deprecated DONT USE IT (will be deleted soon)
         *
         * Returns day of week offset of the beginning of the current year
         */
        get: function () {
            return TuiYear.getYearStartDaysOffset(this.year, this.absoluteLeapYears);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Passed year is after current
     */
    TuiYear.prototype.yearBefore = function (_a) {
        var year = _a.year;
        return this.year < year;
    };
    /**
     * Passed year is the same or after current
     */
    TuiYear.prototype.yearSameOrBefore = function (_a) {
        var year = _a.year;
        return this.year <= year;
    };
    /**
     * Passed year is the same as current
     */
    TuiYear.prototype.yearSame = function (_a) {
        var year = _a.year;
        return this.year === year;
    };
    /**
     * Passed year is either the same of before the current
     */
    TuiYear.prototype.yearSameOrAfter = function (_a) {
        var year = _a.year;
        return this.year >= year;
    };
    /**
     * Passed year is before current
     */
    TuiYear.prototype.yearAfter = function (_a) {
        var year = _a.year;
        return this.year > year;
    };
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably offsets year
     */
    TuiYear.prototype.append = function (_a, backwards) {
        var _b = _a.year, year = _b === void 0 ? 0 : _b;
        if (backwards === void 0) { backwards = false; }
        tuiAssert.assert(Number.isInteger(year));
        if (backwards) {
            year *= -1;
        }
        var resultYear = this.year + year;
        tuiAssert.assert(TuiYear.isValidYear(resultYear));
        return new TuiYear(resultYear);
    };
    TuiYear.prototype.toString = function () {
        return this.formattedYear;
    };
    TuiYear.prototype.valueOf = function () {
        return this.year;
    };
    /**
     * Returns the primitive value of the given Date object.
     * Depending on the argument, the method can return either a string or a number.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@@toPrimitive
     */
    TuiYear.prototype[Symbol.toPrimitive] = function (hint) {
        return Date.prototype[Symbol.toPrimitive].call(this, hint);
    };
    TuiYear.prototype.toJSON = function () {
        return this.formattedYear;
    };
    return TuiYear;
}());

/**
 * Immutable object consisting of year and month
 */
var TuiMonth = /** @class */ (function (_super) {
    __extends(TuiMonth, _super);
    /**
     * @param year
     * @param month (starting with 0)
     */
    function TuiMonth(year, month) {
        var _this = _super.call(this, year) || this;
        _this.month = month;
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        return _this;
    }
    /**
     * Tests month and year for validity
     */
    TuiMonth.isValidMonth = function (year, month) {
        return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);
    };
    /**
     * Returns number of days in a month
     */
    TuiMonth.getMonthDaysCount = function (month, isLeapYear) {
        tuiAssert.assert(TuiMonth.isValidMonthPart(month));
        switch (month) {
            case 1 /* February */:
                return isLeapYear ? 29 : 28;
            case 3 /* April */:
            case 5 /* June */:
            case 8 /* September */:
            case 10 /* November */:
                return 30;
            default:
                return 31;
        }
    };
    /**
     * Returns current month and year based on local time zone
     * @nosideeffects
     */
    TuiMonth.currentLocal = function () {
        var nativeDate = new Date();
        return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());
    };
    /**
     * Returns current month and year based on UTC
     */
    TuiMonth.currentUtc = function () {
        var nativeDate = new Date();
        return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());
    };
    TuiMonth.lengthBetween = function (from, to) {
        var absoluteFrom = from.month + from.year * 12;
        var absoluteTo = to.month + to.year * 12;
        return absoluteTo - absoluteFrom;
    };
    /**
     * Normalizes number by clamping it between min and max month
     */
    TuiMonth.normalizeMonthPart = function (month) {
        return normalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);
    };
    /**
     * Tests month for validity
     */
    TuiMonth.isValidMonthPart = function (month) {
        return Number.isInteger(month) && inRange(month, MIN_MONTH, MAX_MONTH + 1);
    };
    Object.defineProperty(TuiMonth.prototype, "formattedMonthPart", {
        get: function () {
            return padStart(String(this.month + 1), 2, "0");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "formattedMonth", {
        /**
         * @deprecated
         * Formatter month and year
         */
        get: function () {
            return this.formattedMonthPart + "." + this.formattedYear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "weeksRowsCount", {
        /**
         * @deprecated DONT USE IT (will be deleted soon)
         *
         * Calculates number of weeks in a month (counting non-full weeks)
         */
        get: function () {
            return Math.ceil((this.monthStartDaysOffset + this.daysCount) / DAYS_IN_WEEK);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "daysCount", {
        /**
         * Returns days in a month
         */
        get: function () {
            return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "monthStartDaysOffset", {
        /**
         * @deprecated DONT USE IT (will be deleted soon)
         *
         * Computes day of week offset of the beginning of the month
         */
        get: function () {
            var result = this.yearStartDaysOffset;
            for (var currentMonth = 0; currentMonth <= this.month - 1; currentMonth++) {
                result += TuiMonth.getMonthDaysCount(currentMonth, this.isLeapYear);
            }
            return result % DAYS_IN_WEEK;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Passed month and year are after current
     */
    TuiMonth.prototype.monthBefore = function (another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month < another.month));
    };
    /**
     * Passed month and year are after or the same as current
     */
    TuiMonth.prototype.monthSameOrBefore = function (another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month <= another.month));
    };
    /**
     * Passed month and year are the same as current
     */
    TuiMonth.prototype.monthSame = function (another) {
        return this.yearSame(another) && this.month === another.month;
    };
    /**
     * Passed month and year are either before or equal to current
     */
    TuiMonth.prototype.monthSameOrAfter = function (another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month >= another.month));
    };
    /**
     * Passed month and year are before current
     */
    TuiMonth.prototype.monthAfter = function (another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month > another.month));
    };
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably alters current month and year by passed offset
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new month and year object as a result of offsetting current
     */
    TuiMonth.prototype.append = function (_a, backwards) {
        var _b = _a.year, year = _b === void 0 ? 0 : _b, _c = _a.month, month = _c === void 0 ? 0 : _c;
        if (backwards === void 0) { backwards = false; }
        if (backwards) {
            year *= -1;
            month *= -1;
        }
        var totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        return new TuiMonth(Math.floor(totalMonths / MONTHS_IN_YEAR), totalMonths % MONTHS_IN_YEAR);
    };
    TuiMonth.prototype.toString = function () {
        return this.formattedMonth;
    };
    TuiMonth.prototype.valueOf = function () {
        return this.toLocalNativeDate().valueOf();
    };
    TuiMonth.prototype.toJSON = function () {
        return _super.prototype.toJSON.call(this) + "-" + this.formattedMonthPart;
    };
    /**
     * Returns native {@link Date} based on local time zone
     */
    TuiMonth.prototype.toLocalNativeDate = function () {
        return new Date(this.year, this.month);
    };
    /**
     * Returns native {@link Date} based on UTC
     */
    TuiMonth.prototype.toUtcNativeDate = function () {
        return new Date(Date.UTC(this.year, this.month));
    };
    return TuiMonth;
}(TuiYear));

// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
var TuiDay = /** @class */ (function (_super) {
    __extends(TuiDay, _super);
    function TuiDay(year, month, day) {
        var _this = _super.call(this, year, month) || this;
        _this.day = day;
        tuiAssert.assert(TuiDay.isValidDay(year, month, day));
        return _this;
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    TuiDay.fromLocalNativeDate = function (date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    };
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    TuiDay.fromUtcNativeDate = function (date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    };
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    TuiDay.isValidDay = function (year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    };
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Calculated day on a calendar grid
     *
     * @param month
     * @param row row in a calendar
     * @param col column in a calendar
     * @return resulting day on these coordinates (could exceed passed month)
     */
    TuiDay.getDayFromMonthRowCol = function (month, row, col) {
        tuiAssert.assert(Number.isInteger(row));
        tuiAssert.assert(inRange(row, 0, 6));
        tuiAssert.assert(Number.isInteger(col));
        tuiAssert.assert(inRange(col, 0, DAYS_IN_WEEK));
        var day = row * DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;
        if (day > month.daysCount) {
            day -= month.daysCount;
            month = month.append({ month: 1 });
        }
        if (day <= 0) {
            month = month.append({ month: -1 });
            day = month.daysCount + day;
        }
        return new TuiDay(month.year, month.month, day);
    };
    /**
     * Current day based on local time zone
     */
    TuiDay.currentLocal = function () {
        var nativeDate = new Date();
        var year = nativeDate.getFullYear();
        var month = nativeDate.getMonth();
        var day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    };
    /**
     * Returns current day based on UTC
     */
    TuiDay.currentUtc = function () {
        var nativeDate = new Date();
        var year = nativeDate.getUTCFullYear();
        var month = nativeDate.getUTCMonth();
        var day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    };
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    TuiDay.normalizeOf = function (year, month, day) {
        var normalizedYear = TuiYear.normalizeYearPart(year);
        var normalizedMonth = TuiMonth.normalizeMonthPart(month);
        var normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    };
    TuiDay.lengthBetween = function (from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    };
    TuiDay.parseRawDateString = function (date, dateMode) {
        if (dateMode === void 0) { dateMode = "DMY"; }
        tuiAssert.assert(date.length === DATE_FILLER_LENGTH, "[parseRawDateString]: wrong date string length");
        switch (dateMode) {
            case "YMD":
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case "MDY":
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            default:
            case "DMY":
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    };
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    TuiDay.normalizeParse = function (rawDate, dateMode) {
        if (dateMode === void 0) { dateMode = "DMY"; }
        var _a = this.parseRawDateString(rawDate, dateMode), day = _a.day, month = _a.month, year = _a.year;
        return TuiDay.normalizeOf(year, month, day);
    };
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    TuiDay.jsonParse = function (yearMonthDayString) {
        var _a = this.parseRawDateString(yearMonthDayString, "YMD"), day = _a.day, month = _a.month, year = _a.year;
        if (!TuiYear.isValidYear(year)) {
            throw new InvalidYearException(year);
        }
        if (!TuiMonth.isValidMonth(year, month)) {
            throw new InvalidMonthException(month);
        }
        if (!Number.isInteger(day) ||
            !inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new InvalidDayException(day);
        }
        return new TuiDay(year, month, day);
    };
    TuiDay.normalizeDayPart = function (day, month, year) {
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        var monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return normalizeToIntNumber(day, 1, monthDaysCount);
    };
    Object.defineProperty(TuiDay.prototype, "formattedDayPart", {
        get: function () {
            return padStart(String(this.day), 2, "0");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDay.prototype, "formattedDay", {
        /**
         * @deprecated use {@link getFormattedDay} instead
         * Formatted whole date
         */
        get: function () {
            return this.formattedDayPart + "." + this.formattedMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDay.prototype, "isWeekend", {
        get: function () {
            var dayOfWeek = this.dayOfWeek(false);
            return dayOfWeek === 6 /* Saturday */ || dayOfWeek === 0 /* Sunday */;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    TuiDay.prototype.dayOfWeek = function (startFromMonday) {
        if (startFromMonday === void 0) { startFromMonday = true; }
        var dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    };
    /**
     * Passed date is after current
     */
    TuiDay.prototype.dayBefore = function (another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    };
    /**
     * Passed date is after or equals to current
     */
    TuiDay.prototype.daySameOrBefore = function (another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    };
    /**
     * Passed date is the same as current
     */
    TuiDay.prototype.daySame = function (another) {
        return this.monthSame(another) && this.day === another.day;
    };
    /**
     * Passed date is either before or the same as current
     */
    TuiDay.prototype.daySameOrAfter = function (another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    };
    /**
     * Passed date is before current
     */
    TuiDay.prototype.dayAfter = function (another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    };
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    TuiDay.prototype.dayLimit = function (min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    };
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new date object as a result of offsetting current
     */
    TuiDay.prototype.append = function (_a, backwards) {
        var _b = _a.year, year = _b === void 0 ? 0 : _b, _c = _a.month, month = _c === void 0 ? 0 : _c, _d = _a.day, day = _d === void 0 ? 0 : _d;
        if (backwards === void 0) { backwards = false; }
        if (backwards) {
            year *= -1;
            month *= -1;
            day *= -1;
        }
        var totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        var years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        var months = totalMonths % MONTHS_IN_YEAR;
        var days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === 11 /* December */) {
                years++;
                months = 0 /* January */;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === 0 /* January */) {
                years--;
                months = 11 /* December */;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    };
    /**
     * Returns formatted whole date
     */
    TuiDay.prototype.getFormattedDay = function (dateFormat, separator) {
        tuiAssert.assert(separator.length === 1, "Separator should consist of only 1 symbol");
        var dd = this.formattedDayPart;
        var mm = this.formattedMonthPart;
        var yyyy = this.formattedYear;
        switch (dateFormat) {
            case "YMD":
                return "" + yyyy + separator + mm + separator + dd;
            case "MDY":
                return "" + mm + separator + dd + separator + yyyy;
            case "DMY":
            default:
                return "" + dd + separator + mm + separator + yyyy;
        }
    };
    TuiDay.prototype.toString = function (dateFormat, separator) {
        if (dateFormat === void 0) { dateFormat = "DMY"; }
        if (separator === void 0) { separator = "."; }
        return this.getFormattedDay(dateFormat, separator);
    };
    TuiDay.prototype.toJSON = function () {
        return _super.prototype.toJSON.call(this) + "-" + this.formattedDayPart;
    };
    /**
     * Returns native {@link Date} based on local time zone
     */
    TuiDay.prototype.toLocalNativeDate = function () {
        return new Date(this.year, this.month, this.day);
    };
    /**
     * Returns native {@link Date} based on UTC
     */
    TuiDay.prototype.toUtcNativeDate = function () {
        return new Date(Date.UTC(this.year, this.month, this.day));
    };
    return TuiDay;
}(TuiMonth));

/**
 * An immutable range of two {@link TuiMonth} objects
 */
var TuiMonthRange = /** @class */ (function () {
    function TuiMonthRange(from, to) {
        this.from = from;
        this.to = to;
        tuiAssert.assert(from.monthSameOrBefore(to));
    }
    TuiMonthRange.sort = function (month1, month2) {
        return month1.monthSameOrBefore(month2)
            ? new TuiMonthRange(month1, month2)
            : new TuiMonthRange(month2, month1);
    };
    Object.defineProperty(TuiMonthRange.prototype, "isSingleMonth", {
        get: function () {
            return this.from.monthSame(this.to);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonthRange.prototype, "formattedMonthRange", {
        /**
         * @deprecated
         */
        get: function () {
            return "" + this.from.formattedMonth + RANGE_SEPARATOR_CHAR + this.to.formattedMonth;
        },
        enumerable: true,
        configurable: true
    });
    TuiMonthRange.prototype.monthSame = function (another) {
        return this.from.monthSame(another.from) && this.to.monthSame(another.to);
    };
    TuiMonthRange.prototype.toString = function () {
        return "" + this.from + RANGE_SEPARATOR_CHAR + this.to;
    };
    return TuiMonthRange;
}());

/**
 * Temporary type guard to satisfy ts-overloading of normalizeParse method
 * @deprecated
 */
var isDateMode = function (dateMode) {
    return ["DMY", "YMD", "MDY"].includes(dateMode);
};
/**
 * An immutable range of two {@link TuiDay} objects
 */
var TuiDayRange = /** @class */ (function (_super) {
    __extends(TuiDayRange, _super);
    function TuiDayRange(from, to) {
        var _this = _super.call(this, from, to) || this;
        _this.from = from;
        _this.to = to;
        tuiAssert.assert(from.daySameOrBefore(to));
        return _this;
    }
    /**
     * Creates range from two days after sorting them
     *
     * @param day1
     * @param day2
     * @return new range with sorted days
     */
    TuiDayRange.sort = function (day1, day2) {
        return day1.daySameOrBefore(day2)
            ? new TuiDayRange(day1, day2)
            : new TuiDayRange(day2, day1);
    };
    /**
     * Parse and correct a day range in string format
     *
     * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy
     * @param dateMode {@link TuiDateMode}
     * @return normalized day range object
     */
    TuiDayRange.normalizeParse = function (rangeString, dateMode) {
        if (dateMode === void 0) { dateMode = "DMY"; }
        var dateFormat = isDateMode(dateMode) ? dateMode : "DMY";
        var leftDay = TuiDay.normalizeParse(rangeString.slice(0, DATE_FILLER_LENGTH), dateFormat);
        if (rangeString.length < DATE_RANGE_FILLER_LENGTH) {
            return new TuiDayRange(leftDay, leftDay);
        }
        return TuiDayRange.sort(leftDay, TuiDay.normalizeParse(rangeString.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), dateFormat));
    };
    Object.defineProperty(TuiDayRange.prototype, "isSingleDay", {
        get: function () {
            return this.from.daySame(this.to);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDayRange.prototype, "formattedDayRange", {
        /**
         * Human readable format.
         * @deprecated use {@link getFormattedDayRange} instead
         */
        get: function () {
            var from = this.from.getFormattedDay("DMY", ".");
            var to = this.to.getFormattedDay("DMY", ".");
            return "" + from + RANGE_SEPARATOR_CHAR + to;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Tests ranges for identity
     *
     * @param another second range to test against current
     * @return `true` if days are identical
     */
    TuiDayRange.prototype.daySame = function (another) {
        return this.from.daySame(another.from) && this.to.daySame(another.to);
    };
    /**
     * Locks range between two days included, or limits from one side if the other is null
     *
     * @param min
     * @param max
     * @return range — clamped range
     */
    TuiDayRange.prototype.dayLimit = function (min, max) {
        return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));
    };
    /**
     * Human readable format.
     */
    TuiDayRange.prototype.getFormattedDayRange = function (dateFormat, dateSeparator) {
        var from = this.from.getFormattedDay(dateFormat, dateSeparator);
        var to = this.to.getFormattedDay(dateFormat, dateSeparator);
        return "" + from + RANGE_SEPARATOR_CHAR + to;
    };
    TuiDayRange.prototype.toString = function (dateFormat, dateSeparator) {
        if (dateFormat === void 0) { dateFormat = "DMY"; }
        if (dateSeparator === void 0) { dateSeparator = "."; }
        var from = this.from.getFormattedDay(dateFormat, dateSeparator);
        var to = this.to.getFormattedDay(dateFormat, dateSeparator);
        return "" + from + RANGE_SEPARATOR_CHAR + to;
    };
    return TuiDayRange;
}(TuiMonthRange));

var TUI_FIRST_DAY = new TuiDay(MIN_YEAR, MIN_MONTH, MIN_DAY);
var TUI_LAST_DAY = new TuiDay(MAX_YEAR, MAX_MONTH, 31);

/**
 * Immutable time object with hours, minutes, seconds and ms
 */
var TuiTime = /** @class */ (function () {
    function TuiTime(hours, minutes, seconds, ms) {
        if (seconds === void 0) { seconds = 0; }
        if (ms === void 0) { ms = 0; }
        this.hours = hours;
        this.minutes = minutes;
        this.seconds = seconds;
        this.ms = ms;
        tuiAssert.assert(TuiTime.isValidTime(hours, minutes, seconds, ms), "Time must be real, but got:", hours, minutes, seconds, ms);
    }
    /**
     * Checks if time is valid
     */
    TuiTime.isValidTime = function (hours, minutes, seconds, ms) {
        if (seconds === void 0) { seconds = 0; }
        if (ms === void 0) { ms = 0; }
        return (Number.isInteger(hours) &&
            inRange(hours, 0, HOURS_IN_DAY) &&
            Number.isInteger(minutes) &&
            inRange(minutes, 0, MINUTES_IN_HOUR) &&
            Number.isInteger(seconds) &&
            inRange(seconds, 0, SECONDS_IN_MINUTE) &&
            Number.isInteger(ms) &&
            inRange(ms, 0, 1000));
    };
    /**
     * Current UTC time.
     */
    TuiTime.current = function () {
        return TuiTime.fromAbsoluteMilliseconds(Date.now() % MILLISECONDS_IN_DAY);
    };
    /**
     * Current time in local timezone
     */
    TuiTime.currentLocal = function () {
        var date = new Date();
        return TuiTime.fromAbsoluteMilliseconds((Date.now() - date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE) %
            MILLISECONDS_IN_DAY);
    };
    /**
     * Calculates TuiTime from milliseconds
     */
    TuiTime.fromAbsoluteMilliseconds = function (milliseconds) {
        tuiAssert.assert(Number.isInteger(milliseconds));
        tuiAssert.assert(inRange(milliseconds, 0, MILLISECONDS_IN_DAY), "Milliseconds must be below " + MILLISECONDS_IN_DAY + " (milliseconds in a day).");
        var hours = Math.floor(milliseconds / MILLISECONDS_IN_HOUR);
        var minutes = Math.floor((milliseconds % MILLISECONDS_IN_HOUR) / MILLISECONDS_IN_MINUTE);
        var seconds = Math.floor(((milliseconds % MILLISECONDS_IN_HOUR) % MILLISECONDS_IN_MINUTE) / 1000) || 0;
        var ms = Math.floor(((milliseconds % MILLISECONDS_IN_HOUR) % MILLISECONDS_IN_MINUTE) % 1000) || 0;
        return new TuiTime(hours, minutes, seconds, ms);
    };
    /**
     * Parses string into TuiTime object
     */
    TuiTime.fromString = function (time) {
        var hours = Number(time.slice(0, 2));
        var minutes = Number(time.slice(3, 5));
        var seconds = Number(time.slice(6, 8)) || 0;
        var ms = Number(time.slice(9, 12)) || 0;
        return new TuiTime(hours, minutes, seconds, ms);
    };
    /**
     * Converts Date object into TuiTime
     * @param date
     */
    TuiTime.fromLocalNativeDate = function (date) {
        return new TuiTime(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    };
    /**
     * Shifts time by hours and minutes
     */
    TuiTime.prototype.shift = function (_a) {
        var _b = _a.hours, hours = _b === void 0 ? 0 : _b, _c = _a.minutes, minutes = _c === void 0 ? 0 : _c, _d = _a.seconds, seconds = _d === void 0 ? 0 : _d, _e = _a.ms, ms = _e === void 0 ? 0 : _e;
        var newMs = (1000 + this.ms + (ms % 1000)) % 1000;
        var secondsInMs = ms < 0 ? Math.ceil(ms / 1000) : Math.floor(ms / 1000);
        var secondsToAdd = secondsInMs + seconds;
        var newSeconds = (60 + this.seconds + (secondsToAdd % 60)) % 60;
        var minutesInSeconds = secondsToAdd < 0
            ? Math.ceil(secondsToAdd / 60)
            : Math.floor(secondsToAdd / 60);
        var minutesToAdd = minutesInSeconds + minutes;
        var newMinutes = (60 + this.minutes + (minutesToAdd % 60)) % 60;
        var hoursInMinutes = minutesToAdd < 0
            ? Math.ceil(minutesToAdd / 60)
            : Math.floor(minutesToAdd / 60);
        var hoursToAdd = hoursInMinutes + hours;
        var newHours = (24 + this.hours + (hoursToAdd % 24)) % 24;
        return new TuiTime(newHours, newMinutes, newSeconds, newMs);
    };
    /**
     * Converts TuiTime to string
     */
    TuiTime.prototype.toString = function (mode) {
        var needAddMs = mode === "HH:MM:SS.MSS" || (!mode && this.ms > 0);
        var needAddSeconds = needAddMs || mode === "HH:MM:SS" || (!mode && this.seconds > 0);
        return (this.formatTime(this.hours) + ":" + this.formatTime(this.minutes) +
            ("" + (needAddSeconds ? ":" + this.formatTime(this.seconds) : "")) +
            ("" + (needAddMs ? "." + this.formatTime(this.ms, 3) : "")));
    };
    TuiTime.prototype.valueOf = function () {
        return this.toAbsoluteMilliseconds();
    };
    /**
     * Returns the primitive value of the given Date object.
     * Depending on the argument, the method can return either a string or a number.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@@toPrimitive
     */
    TuiTime.prototype[Symbol.toPrimitive] = function (hint) {
        return Date.prototype[Symbol.toPrimitive].call(this, hint);
    };
    /**
     * Converts TuiTime to milliseconds
     */
    TuiTime.prototype.toAbsoluteMilliseconds = function () {
        return (this.hours * MILLISECONDS_IN_HOUR +
            this.minutes * MILLISECONDS_IN_MINUTE +
            this.seconds * 1000 +
            this.ms);
    };
    TuiTime.prototype.formatTime = function (time, digits) {
        if (digits === void 0) { digits = 2; }
        return padStart(String(time), digits, "0");
    };
    return TuiTime;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, DAYS_IN_LEAP_YEAR, DAYS_IN_NORMAL_YEAR, DAYS_IN_WEEK, HOURS_IN_DAY, MAX_MONTH, MAX_YEAR, MILLISECONDS_IN_DAY, MILLISECONDS_IN_HOUR, MILLISECONDS_IN_MINUTE, MILLISECONDS_IN_SECOND, MINUTES_IN_HOUR, MIN_DAY, MIN_MONTH, MIN_YEAR, MONTHS_IN_YEAR, RANGE_SEPARATOR_CHAR, SECONDS_IN_MINUTE, TUI_DATE_FILLER, TUI_DATE_FORMAT, TUI_DATE_RANGE_FILLER, TUI_DATE_SEPARATOR, TUI_FIRST_DAY, TUI_LAST_DAY, TuiDay, TuiDayRange, TuiMonth, TuiMonthRange, TuiTime, TuiYear, changeDateSeparator, isDateMode };
//# sourceMappingURL=taiga-ui-cdk-date-time.js.map
