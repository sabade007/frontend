import { TuiOwnerDocumentException, TuiValuePresentException, TuiValueChangesException } from '@taiga-ui/cdk/exceptions';
import { isPresent, getOriginalArrayFromQueryList } from '@taiga-ui/cdk/utils/miscellaneous';
import { fromEvent, merge, concat, pipe, timer, Observable } from 'rxjs';
import { take, map, endWith, takeWhile, repeat, switchMapTo, mapTo, startWith, distinctUntilChanged, shareReplay, filter, ignoreElements, withLatestFrom, tap } from 'rxjs/operators';
import { isNativeFocused } from '@taiga-ui/cdk/utils/focus';

/**
 * @deprecated: use {@link tuiTypedFromEvent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function typedFromEvent(target, event, options) {
    if (options === void 0) { options = {}; }
    return fromEvent(target, event, options);
}
var tuiTypedFromEvent = typedFromEvent;

/**
 * @deprecated: use {@link tuiMouseDragFinishFrom} instead
 * Letting go of the mouse after it was pressed
 * @param target
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function mouseDragFinishFrom(target) {
    return merge(typedFromEvent(target, "mouseup"), typedFromEvent(target, "dragend"));
}
var tuiMouseDragFinishFrom = mouseDragFinishFrom;

var TuiDragStage;
(function (TuiDragStage) {
    TuiDragStage[TuiDragStage["Start"] = 0] = "Start";
    TuiDragStage[TuiDragStage["Continues"] = 1] = "Continues";
    TuiDragStage[TuiDragStage["End"] = 2] = "End";
})(TuiDragStage || (TuiDragStage = {}));
var TuiDragState = /** @class */ (function () {
    function TuiDragState(stage, event) {
        this.stage = stage;
        this.event = event;
    }
    return TuiDragState;
}());
/**
 * @deprecated: use {@link tuiDragAndDropFrom} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function dragAndDropFrom(element) {
    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        throw new TuiOwnerDocumentException();
    }
    return concat(typedFromEvent(element, "mousedown").pipe(take(1), map(function (event) { return new TuiDragState(0 /* Start */, event); })), merge(typedFromEvent(ownerDocument, "mousemove").pipe(map(function (event) { return new TuiDragState(1 /* Continues */, event); })), mouseDragFinishFrom(ownerDocument).pipe(take(1), map(function (event) { return new TuiDragState(2 /* End */, event); }), endWith(null))).pipe(takeWhile(isPresent))).pipe(repeat());
}
var tuiDragAndDropFrom = dragAndDropFrom;

/**
 * Operator to set lifespan after which current value is considered obsolete
 */
function tuiIsAlive(lifespan) {
    if (lifespan === void 0) { lifespan = 0; }
    return pipe(switchMapTo(timer(lifespan).pipe(mapTo(false), startWith(true))), distinctUntilChanged());
}

var documentMouseUpIsAlive$;
var documentMouseDownIsAlive$;
/**
 * @deprecated: use {@link tuiFocusVisibleObservable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function focusVisibleObservable(element) {
    var elementBlur$ = typedFromEvent(element, "blur");
    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        throw new TuiOwnerDocumentException();
    }
    if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
        documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, "mouseup", {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay({ bufferSize: 1, refCount: true }));
        documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, "mousedown", {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay({ bufferSize: 1, refCount: true }));
    }
    return merge(
    // focus events excluding ones that came right after mouse action
    concat(typedFromEvent(element, "focus").pipe(take(1)), 
    // filtering out blur events when element remains focused so that we ignore browser tab focus loss
    elementBlur$.pipe(filter(function () { return !isNativeFocused(element); }), take(1), ignoreElements())).pipe(repeat(), withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, function (_event, elementActual, documentActual) {
        return elementActual || documentActual;
    }), filter(function (isUserFocus) { return !isUserFocus; }))).pipe(switchMapTo(elementBlur$.pipe(mapTo(false), take(1), startWith(true))), distinctUntilChanged());
}
var tuiFocusVisibleObservable = focusVisibleObservable;

/**
 * In RxJS 8 `observers` will be removed, this util is for future safety
 */
function tuiIsObserved(observable) {
    return observable.observed || !!observable.observers.length;
}

/**
 * @deprecated: use {@link tuiItemsQueryListObservable} instead
 * Converts changes observable of a QueryList to an Observable of arrays
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function itemsQueryListObservable(queryList) {
    return queryList.changes.pipe(map(function () { return getOriginalArrayFromQueryList(queryList); }), startWith(getOriginalArrayFromQueryList(queryList)));
}
var tuiItemsQueryListObservable = itemsQueryListObservable;

/**
 * @deprecated: use {@link tuiMustBePresent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function mustBePresent() {
    return map(function (value) {
        if (!isPresent(value)) {
            throw new TuiValuePresentException();
        }
        return value;
    });
}
var tuiMustBePresent = mustBePresent;

/**
 * @deprecated: use {@link tuiPressedObservable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function pressedObservable(element, _a) {
    var onlyTrusted = (_a === void 0 ? { onlyTrusted: true } : _a).onlyTrusted;
    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        throw new TuiOwnerDocumentException();
    }
    return typedFromEvent(element, "mousedown").pipe(filter(function (_a) {
        var isTrusted = _a.isTrusted;
        return isTrusted || !onlyTrusted;
    }), switchMapTo(mouseDragFinishFrom(ownerDocument).pipe(mapTo(false), take(1), startWith(true))));
}
var tuiPressedObservable = pressedObservable;

/**
 * @deprecated: use {@link tuiPreventDefault} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function preventDefault() {
    return tap(function (event) { return event.preventDefault(); });
}
var tuiPreventDefault = preventDefault;

/**
 * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
 * TODO: 3.0 name should be shorter.
 */
function tuiReplayedValueChangesFrom(control) {
    return new Observable(function (subscriber) {
        if (!control.valueChanges) {
            throw new TuiValueChangesException();
        }
        control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);
    });
}

/**
 * Normalizes scroll event in case element is `html` (document.documentElement)
 */
function tuiScrollFrom(element) {
    var _a;
    return tuiTypedFromEvent(element === ((_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement)
        ? element.ownerDocument
        : element, "scroll");
}

/**
 * @deprecated: use {@link tuiStopPropagation} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function stopPropagation() {
    return tap(function (e) {
        e.stopPropagation();
    });
}
var tuiStopPropagation = stopPropagation;

/**
 * @deprecated: use {@link tuiWatch} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function watch(changeDetectorRef) {
    return tap(function () {
        changeDetectorRef.markForCheck();
    });
}
var tuiWatch = watch;

function tuiZonefull(ngZone) {
    return function (source) {
        return new Observable(function (subscriber) {
            return source.subscribe({
                next: function (value) { return ngZone.run(function () { return subscriber.next(value); }); },
                error: function (error) { return ngZone.run(function () { return subscriber.error(error); }); },
                complete: function () { return ngZone.run(function () { return subscriber.complete(); }); },
            });
        });
    };
}
function tuiZonefree(ngZone) {
    return function (source) {
        return new Observable(function (subscriber) {
            return ngZone.runOutsideAngular(function () { return source.subscribe(subscriber); });
        });
    };
}
function tuiZoneOptimized(ngZone) {
    return pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));
}

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDragStage, TuiDragState, dragAndDropFrom, focusVisibleObservable, itemsQueryListObservable, mouseDragFinishFrom, mustBePresent, pressedObservable, preventDefault, stopPropagation, tuiDragAndDropFrom, tuiFocusVisibleObservable, tuiIsAlive, tuiIsObserved, tuiItemsQueryListObservable, tuiMouseDragFinishFrom, tuiMustBePresent, tuiPressedObservable, tuiPreventDefault, tuiReplayedValueChangesFrom, tuiScrollFrom, tuiStopPropagation, tuiTypedFromEvent, tuiWatch, tuiZoneOptimized, tuiZonefree, tuiZonefull, typedFromEvent, watch };
//# sourceMappingURL=taiga-ui-cdk-observables.js.map
