import { __decorate, __param } from 'tslib';
import { EventEmitter, Input, Output, HostBinding, Directive, ChangeDetectorRef, Inject, Injectable, TemplateRef, Injector, ElementRef, ViewChild, ViewContainerRef } from '@angular/core';
import { NgModel, NgControl } from '@angular/forms';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { EMPTY_FUNCTION } from '@taiga-ui/cdk/constants';
import { tuiDefaultProp } from '@taiga-ui/cdk/decorators';
import { tuiIsPresent } from '@taiga-ui/cdk/utils';
import { Subject, merge, Observable, BehaviorSubject, EMPTY } from 'rxjs';
import { delay, startWith, map, filter, distinctUntilChanged, switchMap, takeUntil, ignoreElements, endWith } from 'rxjs/operators';
import { PolymorpheusTemplate } from '@tinkoff/ng-polymorpheus';
import { TuiIdService } from '@taiga-ui/cdk/services';
import { TuiNoHostException } from '@taiga-ui/cdk/exceptions';
import { DOCUMENT } from '@angular/common';

var AbstractTuiInteractive_1;
const TUI = `tui_interactive_`;
/**
 * The most basic class for interactive components
 */
let AbstractTuiInteractive = AbstractTuiInteractive_1 = class AbstractTuiInteractive {
    constructor() {
        this.pseudoHovered = null;
        this.pseudoPressed = null;
        this.pseudoFocused = null;
        /**
         * Determines if component is focusable with keyboard.
         */
        this.focusable = true;
        this.nativeId = ``;
        /**
         * Emits 'true' on focus and 'false' on blur.
         */
        this.focusedChange = new EventEmitter();
        /** @deprecated use `tuiPressedChange` directive */
        this.pressedChange = new EventEmitter();
        /** @deprecated use `tuiHoveredChange` directive */
        this.hoveredChange = new EventEmitter();
        this.focusVisibleChange = new EventEmitter();
        /** @deprecated use `tuiHoveredChange` directive */
        this.hovered = false;
        /** @deprecated use `tuiPressedChange` directive */
        this.pressed = false;
        this.focusVisible = false;
        this.autoIdString = `${TUI}${AbstractTuiInteractive_1.autoId++}${Date.now()}`;
    }
    get computedDisabled() {
        return this.disabled;
    }
    /** @deprecated */
    get computedHovered() {
        var _a;
        return !this.computedDisabled && ((_a = this.pseudoHovered) !== null && _a !== void 0 ? _a : this.hovered);
    }
    /** @deprecated */
    get computedPressed() {
        var _a;
        return !this.computedDisabled && ((_a = this.pseudoPressed) !== null && _a !== void 0 ? _a : this.pressed);
    }
    get computedFocusable() {
        return !this.computedDisabled && (this.focusable || this.focused);
    }
    get computedFocused() {
        var _a;
        return !this.computedDisabled && ((_a = this.pseudoFocused) !== null && _a !== void 0 ? _a : this.focused);
    }
    get computedFocusVisible() {
        var _a;
        return !this.computedDisabled && ((_a = this.pseudoFocused) !== null && _a !== void 0 ? _a : this.focusVisible);
    }
    // TODO: 3.0 Consider removing since native input is exposed
    get id() {
        return this.nativeId ? this.nativeId : this.autoIdString;
    }
    /** @deprecated */
    updateHovered(hovered) {
        if (this.hovered === hovered) {
            return;
        }
        this.hovered = hovered;
        this.hoveredChange.emit(hovered);
    }
    /** @deprecated */
    updatePressed(pressed) {
        if (this.pressed === pressed) {
            return;
        }
        this.pressed = pressed;
        this.pressedChange.emit(pressed);
    }
    updateFocused(focused) {
        this.focusedChange.emit(focused);
    }
    updateFocusVisible(focusVisible) {
        if (this.focusVisible === focusVisible) {
            return;
        }
        this.focusVisible = focusVisible;
        this.focusVisibleChange.emit(focusVisible);
    }
};
AbstractTuiInteractive.autoId = 0;
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoHovered", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoPressed", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoFocused", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "focusable", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "nativeId", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "focusedChange", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "pressedChange", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "hoveredChange", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "focusVisibleChange", void 0);
__decorate([
    HostBinding(`class._disabled`)
], AbstractTuiInteractive.prototype, "computedDisabled", null);
__decorate([
    HostBinding(`class._hovered`)
], AbstractTuiInteractive.prototype, "computedHovered", null);
__decorate([
    HostBinding(`class._pressed`)
], AbstractTuiInteractive.prototype, "computedPressed", null);
__decorate([
    HostBinding(`class._focused`)
], AbstractTuiInteractive.prototype, "computedFocused", null);
__decorate([
    HostBinding(`class._focus-visible`)
], AbstractTuiInteractive.prototype, "computedFocusVisible", null);
AbstractTuiInteractive = AbstractTuiInteractive_1 = __decorate([
    Directive()
], AbstractTuiInteractive);

/**
 * Basic ControlValueAccessor class to build form components upon
 */
let AbstractTuiControl = class AbstractTuiControl extends AbstractTuiInteractive {
    constructor(ngControl, changeDetectorRef, valueTransformer) {
        super();
        this.ngControl = ngControl;
        this.changeDetectorRef = changeDetectorRef;
        this.valueTransformer = valueTransformer;
        this.refresh$ = new Subject();
        this.onTouched = EMPTY_FUNCTION;
        this.onChange = EMPTY_FUNCTION;
        this.fallbackValue = this.getFallbackValue();
        this.destroy$ = new Subject();
        this.readOnly = false;
        this.pseudoInvalid = null;
        if (this.ngControl === null) {
            tuiAssert.assert(false, `NgControl not injected in ${this.constructor.name}!\n`, `Use [(ngModel)] or [formControl] or formControlName for correct work.`);
        }
        else {
            this.ngControl.valueAccessor = this;
        }
    }
    get computedInvalid() {
        return (this.interactive &&
            (this.pseudoInvalid !== null
                ? this.pseudoInvalid
                : this.touched && this.invalid));
    }
    get value() {
        var _a;
        return (_a = this.previousInternalValue) !== null && _a !== void 0 ? _a : this.fallbackValue;
    }
    get safeCurrentValue() {
        var _a;
        return (_a = this.rawValue) !== null && _a !== void 0 ? _a : this.fallbackValue;
    }
    get invalid() {
        return this.safeNgControlData(({ invalid }) => invalid, false);
    }
    get valid() {
        return this.safeNgControlData(({ valid }) => valid, false);
    }
    get touched() {
        return this.safeNgControlData(({ touched }) => touched, false);
    }
    get disabled() {
        return this.safeNgControlData(({ disabled }) => disabled, false);
    }
    get interactive() {
        return !this.readOnly && !this.computedDisabled;
    }
    get control() {
        return this.safeNgControlData(({ control }) => control, null);
    }
    get computedName() {
        var _a, _b;
        return (_b = (_a = this.controlName) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null;
    }
    get controlName() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : null;
    }
    get rawValue() {
        const { ngControl } = this;
        if (ngControl === null) {
            return undefined;
        }
        const controlValue = ngControl instanceof NgModel && this.previousInternalValue === undefined
            ? ngControl.viewModel
            : ngControl.value;
        return this.fromControlValue(controlValue);
    }
    ngOnInit() {
        this.refresh$
            .pipe(delay(0), startWith(null), map(() => { var _a; return (_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.control; }), filter(tuiIsPresent), distinctUntilChanged(), switchMap(control => merge(control.valueChanges, control.statusChanges)), takeUntil(this.destroy$))
            .subscribe(() => {
            this.refreshLocalValue(this.safeCurrentValue);
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkControlUpdate() {
        this.changeDetectorRef.markForCheck();
    }
    registerOnChange(onChange) {
        this.onChange = (componentValue) => {
            onChange(this.toControlValue(componentValue));
        };
        this.refresh$.next();
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    setDisabledState() {
        this.checkControlUpdate();
    }
    writeValue(value) {
        const controlValue = this.ngControl instanceof NgModel && this.previousInternalValue === undefined
            ? this.ngControl.model
            : value;
        this.refreshLocalValue(this.fromControlValue(controlValue));
    }
    updateFocused(focused) {
        if (!focused) {
            this.controlMarkAsTouched();
        }
        super.updateFocused(focused);
    }
    updateValue(value) {
        if (this.disabled || this.valueIdenticalComparator(this.value, value)) {
            return;
        }
        this.previousInternalValue = value;
        this.controlSetValue(value);
    }
    valueIdenticalComparator(oldValue, newValue) {
        return oldValue === newValue;
    }
    safeNgControlData(extractor, defaultFieldValue) {
        var _a;
        return (_a = (this.ngControl && extractor(this.ngControl))) !== null && _a !== void 0 ? _a : defaultFieldValue;
    }
    controlMarkAsTouched() {
        this.onTouched();
        this.checkControlUpdate();
    }
    controlSetValue(value) {
        this.onChange(value);
        this.checkControlUpdate();
    }
    refreshLocalValue(value) {
        this.previousInternalValue = value;
        this.checkControlUpdate();
    }
    fromControlValue(controlValue) {
        return this.valueTransformer
            ? this.valueTransformer.fromControlValue(controlValue)
            : controlValue;
    }
    toControlValue(componentValue) {
        return this.valueTransformer
            ? this.valueTransformer.toControlValue(componentValue)
            : componentValue;
    }
};
AbstractTuiControl.ctorParameters = () => [
    { type: NgControl },
    { type: ChangeDetectorRef },
    { type: undefined }
];
__decorate([
    Input(),
    HostBinding(`class._readonly`),
    tuiDefaultProp()
], AbstractTuiControl.prototype, "readOnly", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiControl.prototype, "pseudoInvalid", void 0);
__decorate([
    HostBinding(`class._invalid`)
], AbstractTuiControl.prototype, "computedInvalid", null);
AbstractTuiControl = __decorate([
    Directive()
], AbstractTuiControl);

/**
 * @deprecated
 * TODO: 3.0 replace with {@link AbstractTuiController}
 */
class TuiController {
    constructor() {
        this.change$ = new Subject();
    }
    ngOnChanges() {
        this.change$.next();
    }
}
class AbstractTuiController extends TuiController {
}

let AbstractTuiDialogService = class AbstractTuiDialogService extends Observable {
    constructor(idService) {
        super(observer => this.dialogs$.subscribe(observer));
        this.idService = idService;
        this.dialogs$ = new BehaviorSubject([]);
    }
    open(content, options = {}) {
        return new Observable(observer => {
            const completeWith = (result) => {
                observer.next(result);
                observer.complete();
            };
            const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), { content,
                completeWith, $implicit: observer, component: this.component, createdAt: Date.now(), id: this.idService.generate() });
            this.dialogs$.next([...this.dialogs$.value, dialog]);
            return () => {
                this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));
            };
        });
    }
};
AbstractTuiDialogService.ctorParameters = () => [
    { type: TuiIdService, decorators: [{ type: Inject, args: [TuiIdService,] }] }
];
AbstractTuiDialogService = __decorate([
    Injectable(),
    __param(0, Inject(TuiIdService))
], AbstractTuiDialogService);

let AbstractTuiDialogDirective = class AbstractTuiDialogDirective extends PolymorpheusTemplate {
    constructor(templateRef, changeDetectorRef, service) {
        super(templateRef, changeDetectorRef);
        this.service = service;
        this.open$ = new Subject();
        this.options = {};
        this.openChange = this.open$.pipe(switchMap(open => open
            ? this.service
                .open(this, this.options)
                .pipe(ignoreElements(), endWith(false))
            : EMPTY));
    }
    set open(open) {
        this.open$.next(open);
    }
};
AbstractTuiDialogDirective.ctorParameters = () => [
    { type: TemplateRef, decorators: [{ type: Inject, args: [TemplateRef,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: AbstractTuiDialogService, decorators: [{ type: Inject, args: [AbstractTuiDialogService,] }] }
];
AbstractTuiDialogDirective = __decorate([
    Directive(),
    __param(0, Inject(TemplateRef)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(AbstractTuiDialogService))
], AbstractTuiDialogDirective);

let AbstractTuiMultipleControl = class AbstractTuiMultipleControl extends AbstractTuiControl {
    clear() {
        this.updateValue([]);
    }
    getFallbackValue() {
        return [];
    }
};
AbstractTuiMultipleControl = __decorate([
    Directive()
], AbstractTuiMultipleControl);

let AbstractTuiNullableControl = class AbstractTuiNullableControl extends AbstractTuiControl {
    getFallbackValue() {
        return null;
    }
};
AbstractTuiNullableControl = __decorate([
    Directive()
], AbstractTuiNullableControl);

/**
 * Abstract service for displaying portals
 */
let AbstractTuiPortalService = class AbstractTuiPortalService {
    get safeHost() {
        if (!this.host) {
            throw new TuiNoHostException();
        }
        return this.host;
    }
    attach(host) {
        this.host = host;
    }
    add(componentFactory, injector) {
        return this.safeHost.addComponentChild(componentFactory, injector);
    }
    remove({ hostView }) {
        hostView.destroy();
    }
    addTemplate(templateRef, context) {
        return this.safeHost.addTemplateChild(templateRef, context);
    }
    removeTemplate(viewRef) {
        viewRef.destroy();
    }
};
AbstractTuiPortalService = __decorate([
    Injectable()
], AbstractTuiPortalService);

var AbstractTuiPortalHostComponent_1;
/**
 * Abstract class for host element for dynamically created portals.
 */
let AbstractTuiPortalHostComponent = AbstractTuiPortalHostComponent_1 = class AbstractTuiPortalHostComponent {
    constructor(elementRef, portalService) {
        this.elementRef = elementRef;
        portalService.attach(this);
    }
    get clientRect() {
        return this.elementRef.nativeElement.getBoundingClientRect();
    }
    addComponentChild(componentFactory, injector) {
        return this.viewContainerRef.createComponent(componentFactory, undefined, Injector.create({
            parent: injector,
            providers: [
                {
                    provide: AbstractTuiPortalHostComponent_1,
                    useValue: this,
                },
            ],
        }));
    }
    addTemplateChild(templateRef, context) {
        return this.viewContainerRef.createEmbeddedView(templateRef, context);
    }
};
AbstractTuiPortalHostComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: AbstractTuiPortalService, decorators: [{ type: Inject, args: [AbstractTuiPortalService,] }] }
];
__decorate([
    ViewChild(`viewContainer`, { read: ViewContainerRef })
], AbstractTuiPortalHostComponent.prototype, "viewContainerRef", void 0);
AbstractTuiPortalHostComponent = AbstractTuiPortalHostComponent_1 = __decorate([
    Directive(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(AbstractTuiPortalService))
], AbstractTuiPortalHostComponent);

var AbstractTuiThemeSwitcher_1;
/**
 * Use this abstract class to create your own toggleable themes.
 * A component extending this class must have CSS variables definitions
 * and have ViewEncapsulation set to NONE. A boolean input allows to
 * switch theme on or off.
 * @dynamic
 */
let AbstractTuiThemeSwitcher = AbstractTuiThemeSwitcher_1 = class AbstractTuiThemeSwitcher {
    constructor(documentRef) {
        this.documentRef = documentRef;
        if (this.style !== null) {
            this.addTheme();
            return;
        }
        const styles = this.documentRef.head.querySelectorAll(`style`);
        this.constructor.style =
            styles[styles.length - 1];
    }
    get style() {
        return this.constructor.style;
    }
    ngOnDestroy() {
        this.removeTheme();
    }
    addTheme() {
        if (this.style) {
            this.documentRef.head.appendChild(this.style);
        }
    }
    removeTheme() {
        if (this.style && this.documentRef.head.contains(this.style)) {
            this.documentRef.head.removeChild(this.style);
        }
    }
};
AbstractTuiThemeSwitcher.style = null;
AbstractTuiThemeSwitcher.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AbstractTuiThemeSwitcher = AbstractTuiThemeSwitcher_1 = __decorate([
    Directive(),
    __param(0, Inject(DOCUMENT))
], AbstractTuiThemeSwitcher);

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiControl, AbstractTuiController, AbstractTuiDialogDirective, AbstractTuiDialogService, AbstractTuiInteractive, AbstractTuiMultipleControl, AbstractTuiNullableControl, AbstractTuiPortalHostComponent, AbstractTuiPortalService, AbstractTuiThemeSwitcher, TuiController };
//# sourceMappingURL=taiga-ui-cdk-abstract.js.map
