import { TuiOwnerDocumentException, TuiValuePresentException, TuiValueChangesException } from '@taiga-ui/cdk/exceptions';
import { isPresent, getOriginalArrayFromQueryList } from '@taiga-ui/cdk/utils/miscellaneous';
import { fromEvent, merge, concat, pipe, timer, Observable } from 'rxjs';
import { take, map, endWith, takeWhile, repeat, switchMapTo, mapTo, startWith, distinctUntilChanged, shareReplay, filter, ignoreElements, withLatestFrom, tap } from 'rxjs/operators';
import { isNativeFocused } from '@taiga-ui/cdk/utils/focus';

/**
 * @deprecated: use {@link tuiTypedFromEvent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function typedFromEvent(target, event, options = {}) {
    return fromEvent(target, event, options);
}
const tuiTypedFromEvent = typedFromEvent;

/**
 * @deprecated: use {@link tuiMouseDragFinishFrom} instead
 * Letting go of the mouse after it was pressed
 * @param target
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function mouseDragFinishFrom(target) {
    return merge(typedFromEvent(target, `mouseup`), typedFromEvent(target, `dragend`));
}
const tuiMouseDragFinishFrom = mouseDragFinishFrom;

var TuiDragStage;
(function (TuiDragStage) {
    TuiDragStage[TuiDragStage["Start"] = 0] = "Start";
    TuiDragStage[TuiDragStage["Continues"] = 1] = "Continues";
    TuiDragStage[TuiDragStage["End"] = 2] = "End";
})(TuiDragStage || (TuiDragStage = {}));
class TuiDragState {
    constructor(stage, event) {
        this.stage = stage;
        this.event = event;
    }
}
/**
 * @deprecated: use {@link tuiDragAndDropFrom} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function dragAndDropFrom(element) {
    const { ownerDocument } = element;
    if (!ownerDocument) {
        throw new TuiOwnerDocumentException();
    }
    return concat(typedFromEvent(element, `mousedown`).pipe(take(1), map(event => new TuiDragState(0 /* Start */, event))), merge(typedFromEvent(ownerDocument, `mousemove`).pipe(map(event => new TuiDragState(1 /* Continues */, event))), mouseDragFinishFrom(ownerDocument).pipe(take(1), map(event => new TuiDragState(2 /* End */, event)), endWith(null))).pipe(takeWhile(isPresent))).pipe(repeat());
}
const tuiDragAndDropFrom = dragAndDropFrom;

/**
 * Operator to set lifespan after which current value is considered obsolete
 */
function tuiIsAlive(lifespan = 0) {
    return pipe(switchMapTo(timer(lifespan).pipe(mapTo(false), startWith(true))), distinctUntilChanged());
}

let documentMouseUpIsAlive$;
let documentMouseDownIsAlive$;
/**
 * @deprecated: use {@link tuiFocusVisibleObservable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function focusVisibleObservable(element) {
    const elementBlur$ = typedFromEvent(element, `blur`);
    const { ownerDocument } = element;
    if (!ownerDocument) {
        throw new TuiOwnerDocumentException();
    }
    if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
        documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, `mouseup`, {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay({ bufferSize: 1, refCount: true }));
        documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, `mousedown`, {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay({ bufferSize: 1, refCount: true }));
    }
    return merge(
    // focus events excluding ones that came right after mouse action
    concat(typedFromEvent(element, `focus`).pipe(take(1)), 
    // filtering out blur events when element remains focused so that we ignore browser tab focus loss
    elementBlur$.pipe(filter(() => !isNativeFocused(element)), take(1), ignoreElements())).pipe(repeat(), withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, (_event, elementActual, documentActual) => elementActual || documentActual), filter(isUserFocus => !isUserFocus))).pipe(switchMapTo(elementBlur$.pipe(mapTo(false), take(1), startWith(true))), distinctUntilChanged());
}
const tuiFocusVisibleObservable = focusVisibleObservable;

/**
 * In RxJS 8 `observers` will be removed, this util is for future safety
 */
function tuiIsObserved(observable) {
    return observable.observed || !!observable.observers.length;
}

/**
 * @deprecated: use {@link tuiItemsQueryListObservable} instead
 * Converts changes observable of a QueryList to an Observable of arrays
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function itemsQueryListObservable(queryList) {
    return queryList.changes.pipe(map(() => getOriginalArrayFromQueryList(queryList)), startWith(getOriginalArrayFromQueryList(queryList)));
}
const tuiItemsQueryListObservable = itemsQueryListObservable;

/**
 * @deprecated: use {@link tuiMustBePresent} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function mustBePresent() {
    return map(value => {
        if (!isPresent(value)) {
            throw new TuiValuePresentException();
        }
        return value;
    });
}
const tuiMustBePresent = mustBePresent;

/**
 * @deprecated: use {@link tuiPressedObservable} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function pressedObservable(element, { onlyTrusted } = { onlyTrusted: true }) {
    const { ownerDocument } = element;
    if (!ownerDocument) {
        throw new TuiOwnerDocumentException();
    }
    return typedFromEvent(element, `mousedown`).pipe(filter(({ isTrusted }) => isTrusted || !onlyTrusted), switchMapTo(mouseDragFinishFrom(ownerDocument).pipe(mapTo(false), take(1), startWith(true))));
}
const tuiPressedObservable = pressedObservable;

/**
 * @deprecated: use {@link tuiPreventDefault} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function preventDefault() {
    return tap(event => event.preventDefault());
}
const tuiPreventDefault = preventDefault;

/**
 * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
 * TODO: 3.0 name should be shorter.
 */
function tuiReplayedValueChangesFrom(control) {
    return new Observable(subscriber => {
        if (!control.valueChanges) {
            throw new TuiValueChangesException();
        }
        control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);
    });
}

/**
 * Normalizes scroll event in case element is `html` (document.documentElement)
 */
function tuiScrollFrom(element) {
    var _a;
    return tuiTypedFromEvent(element === ((_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement)
        ? element.ownerDocument
        : element, `scroll`);
}

/**
 * @deprecated: use {@link tuiStopPropagation} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function stopPropagation() {
    return tap(e => {
        e.stopPropagation();
    });
}
const tuiStopPropagation = stopPropagation;

/**
 * @deprecated: use {@link tuiWatch} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function watch(changeDetectorRef) {
    return tap(() => {
        changeDetectorRef.markForCheck();
    });
}
const tuiWatch = watch;

function tuiZonefull(ngZone) {
    return source => new Observable(subscriber => source.subscribe({
        next: value => ngZone.run(() => subscriber.next(value)),
        error: (error) => ngZone.run(() => subscriber.error(error)),
        complete: () => ngZone.run(() => subscriber.complete()),
    }));
}
function tuiZonefree(ngZone) {
    return source => new Observable(subscriber => ngZone.runOutsideAngular(() => source.subscribe(subscriber)));
}
function tuiZoneOptimized(ngZone) {
    return pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));
}

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDragStage, TuiDragState, dragAndDropFrom, focusVisibleObservable, itemsQueryListObservable, mouseDragFinishFrom, mustBePresent, pressedObservable, preventDefault, stopPropagation, tuiDragAndDropFrom, tuiFocusVisibleObservable, tuiIsAlive, tuiIsObserved, tuiItemsQueryListObservable, tuiMouseDragFinishFrom, tuiMustBePresent, tuiPressedObservable, tuiPreventDefault, tuiReplayedValueChangesFrom, tuiScrollFrom, tuiStopPropagation, tuiTypedFromEvent, tuiWatch, tuiZoneOptimized, tuiZonefree, tuiZonefull, typedFromEvent, watch };
//# sourceMappingURL=taiga-ui-cdk-observables.js.map
