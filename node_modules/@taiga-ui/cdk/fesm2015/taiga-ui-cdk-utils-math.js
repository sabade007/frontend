import { tuiAssert } from '@taiga-ui/cdk/classes';

/**
 * @deprecated: use {@link tuiClamp} instead
 * Clamps a value between two inclusive limits
 *
 * @param value
 * @param min lower limit
 * @param max upper limit
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function clamp(value, min, max) {
    tuiAssert.assert(!Number.isNaN(value));
    tuiAssert.assert(!Number.isNaN(min));
    tuiAssert.assert(!Number.isNaN(max));
    tuiAssert.assert(max >= min);
    return Math.min(max, Math.max(min, value));
}
const tuiClamp = clamp;

/**
 * @deprecated: use {@link tuiInRange} instead
 * Checks if the value is in range
 *
 * @param value
 * @param fromInclude lower inclusive limit
 * @param toExclude upper exclusive limit
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function inRange(value, fromInclude, toExclude) {
    tuiAssert.assert(!Number.isNaN(value));
    tuiAssert.assert(!Number.isNaN(fromInclude));
    tuiAssert.assert(!Number.isNaN(toExclude));
    tuiAssert.assert(fromInclude < toExclude);
    return value >= fromInclude && value < toExclude;
}
const tuiInRange = inRange;

/**
 * @deprecated: use {@link tuiNormalizeToIntNumber} instead
 * Normalizes any number to an integer within inclusive range
 *
 * @param value
 * @param min lower inclusive integer
 * @param max upper inclusive integer
 * @return an integer between min and max inclusive
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function normalizeToIntNumber(value, min, max) {
    tuiAssert.assert(Number.isInteger(min));
    tuiAssert.assert(Number.isInteger(max));
    tuiAssert.assert(min <= max);
    if (Number.isNaN(value) || value <= min) {
        return min;
    }
    if (value >= max) {
        return max;
    }
    return Math.round(value);
}
const tuiNormalizeToIntNumber = normalizeToIntNumber;

/**
 * @deprecated: use {@link tuiQuantize} instead
 * Rounds a number to the closest value in a fixed discrete series
 *
 * @param value
 * @param quantum series step
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function quantize(value, quantum) {
    tuiAssert.assert(Number.isFinite(value));
    tuiAssert.assert(Number.isFinite(quantum));
    tuiAssert.assert(quantum > 0);
    const remainder = value % quantum;
    return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
}
const tuiQuantize = quantize;

const MAX_PRECISION = 292;
/**
 * @deprecated: use {@link tuiRound} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function round(value, precision = 0) {
    return calculate(value, precision, Math.round);
}
/**
 * @deprecated: use {@link tuiCeil} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function ceil(value, precision = 0) {
    return calculate(value, precision, Math.ceil);
}
/**
 * @deprecated: use {@link tuiFloor} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function floor(value, precision = 0) {
    return calculate(value, precision, Math.floor);
}
const tuiRound = round;
const tuiCeil = ceil;
const tuiFloor = floor;
/**
 * Rounding number to the set precision
 *
 * @param value
 * @param precision number of digits in a float part
 * @param func rounding function (round, floor, ceil)
 */
function calculate(value, precision, func) {
    if (value === Infinity) {
        return value;
    }
    tuiAssert.assert(!Number.isNaN(value), `Value must be number`);
    tuiAssert.assert(Number.isInteger(precision), `Precision must be integer`);
    precision = Math.min(precision, MAX_PRECISION);
    const pair = `${value}e`.split(`e`);
    const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));
    const processedPair = `${tempValue}e`.split(`e`);
    return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);
}

/**
 * @deprecated: use {@link tuiSum} instead
 * Calculates sum of any number of passed arguments
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function sum(...args) {
    return args.reduce((a, b) => a + b, 0);
}
const tuiSum = sum;

/**
 * @deprecated: use {@link tuiToInt} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function toInt(bool) {
    return bool ? 1 : 0;
}
const tuiToInt = toInt;

/**
 * @deprecated: use {@link tuiToRadians} instead
 * Converts angle in degrees to radians
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function toRadians(deg) {
    return (deg * Math.PI) / 180;
}
const tuiToRadians = toRadians;

/**
 * Generated bundle index. Do not edit.
 */

export { ceil, clamp, floor, inRange, normalizeToIntNumber, quantize, round, sum, toInt, toRadians, tuiCeil, tuiClamp, tuiFloor, tuiInRange, tuiNormalizeToIntNumber, tuiQuantize, tuiRound, tuiSum, tuiToInt, tuiToRadians };
//# sourceMappingURL=taiga-ui-cdk-utils-math.js.map
