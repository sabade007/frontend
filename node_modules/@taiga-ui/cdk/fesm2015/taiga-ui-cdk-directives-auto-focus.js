import { __decorate, __param } from 'tslib';
import { ElementRef, Directive, Optional, Self, Inject, Renderer2, NgZone, InjectionToken, Input, NgModule } from '@angular/core';
import { ANIMATION_FRAME, WINDOW } from '@ng-web-apis/common';
import { TUI_FOCUSABLE_ITEM_ACCESSOR, TUI_IS_IOS } from '@taiga-ui/cdk/tokens';
import { POLLING_TIME } from '@taiga-ui/cdk/constants';
import { race, timer, Observable } from 'rxjs';
import { throttleTime, map, skipWhile, take } from 'rxjs/operators';
import { tuiPx } from '@taiga-ui/cdk/utils';

let AbstractTuiAutofocusHandler = class AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef) {
        this.tuiFocusableComponent = tuiFocusableComponent;
        this.elementRef = elementRef;
    }
    get element() {
        var _a;
        return (((_a = this.tuiFocusableComponent) === null || _a === void 0 ? void 0 : _a.nativeFocusableElement) ||
            this.elementRef.nativeElement);
    }
    get isTextFieldElement() {
        return this.element.matches(`input, textarea`);
    }
};
AbstractTuiAutofocusHandler.ctorParameters = () => [
    { type: undefined },
    { type: ElementRef }
];
AbstractTuiAutofocusHandler = __decorate([
    Directive()
], AbstractTuiAutofocusHandler);

const TIMEOUT = 1000;
const NG_ANIMATION_SELECTOR = `.ng-animating`;
let TuiDefaultAutofocusHandler = class TuiDefaultAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef, animationFrame$) {
        super(tuiFocusableComponent, elementRef);
        this.animationFrame$ = animationFrame$;
    }
    setFocus() {
        if (this.isTextFieldElement) {
            race(timer(TIMEOUT), this.animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => this.element.closest(NG_ANIMATION_SELECTOR)), skipWhile(Boolean), take(1))).subscribe(() => this.element.focus());
        }
        else {
            this.element.focus();
        }
    }
};
TuiDefaultAutofocusHandler.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
TuiDefaultAutofocusHandler = __decorate([
    Directive(),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(ANIMATION_FRAME))
], TuiDefaultAutofocusHandler);

// @dynamic
let TuiIosAutofocusHandler = class TuiIosAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef, renderer, ngZone, windowRef) {
        super(tuiFocusableComponent, elementRef);
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.windowRef = windowRef;
        this.patchCssStyles();
    }
    setFocus() {
        if (this.isTextFieldElement) {
            this.ngZone.runOutsideAngular(() => this.iosWebkitAutofocus());
        }
        else {
            this.element.focus();
        }
    }
    iosWebkitAutofocus() {
        var _a;
        const fakeInput = this.makeFakeInput();
        const duration = this.getDurationTimeBeforeFocus();
        let fakeFocusTimeoutId = 0;
        let elementFocusTimeoutId = 0;
        const blurHandler = () => fakeInput.focus({ preventScroll: true });
        const focusHandler = () => {
            clearTimeout(fakeFocusTimeoutId);
            fakeFocusTimeoutId = this.windowRef.setTimeout(() => {
                clearTimeout(elementFocusTimeoutId);
                fakeInput.removeEventListener(`blur`, blurHandler);
                fakeInput.removeEventListener(`focus`, focusHandler);
                elementFocusTimeoutId = this.windowRef.setTimeout(() => {
                    this.element.focus({ preventScroll: false });
                    fakeInput.remove();
                }, duration);
            });
        };
        fakeInput.addEventListener(`blur`, blurHandler, { once: true });
        fakeInput.addEventListener(`focus`, focusHandler);
        if (this.insideDialog()) {
            this.windowRef.document.body.appendChild(fakeInput);
        }
        else {
            (_a = this.element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(fakeInput);
        }
        fakeInput.focus({ preventScroll: true });
    }
    /**
     * @note:
     * emulate textfield position in layout with cursor
     * before focus to real textfield element
     */
    makeFakeInput() {
        const fakeInput = this.renderer.createElement(`input`);
        const rect = this.element.getBoundingClientRect();
        fakeInput.setAttribute(`maxlength`, `0`);
        // @note: don't use opacity: 0,
        // sometimes it's doesn't work for emulate real input
        fakeInput.style.height = tuiPx(rect.height);
        fakeInput.style.width = tuiPx(rect.width / 2);
        fakeInput.style.position = `fixed`;
        fakeInput.style.zIndex = `-99999999`;
        fakeInput.style.caretColor = `transparent`;
        fakeInput.style.color = `transparent`;
        fakeInput.style.cursor = `none`;
        fakeInput.style.fontSize = tuiPx(16); // disable possible auto zoom
        fakeInput.readOnly = true; // prevent keyboard for fake input
        // @note: emulate position cursor before focus to real textfield element
        fakeInput.style.top = tuiPx(rect.top);
        fakeInput.style.left = tuiPx(rect.left);
        return fakeInput;
    }
    getDurationTimeBeforeFocus() {
        return (parseFloat(this.windowRef
            .getComputedStyle(this.element)
            .getPropertyValue(`--tui-duration`)) || 0);
    }
    /**
     * @note:
     * unfortunately, in older versions of iOS
     * there is a bug that the fake input cursor
     * will move along with the dialog animation
     * and then that dialog will be shaking
     */
    insideDialog() {
        return !!this.element.closest(`tui-dialog`);
    }
    /**
     * @note:
     * This is necessary so that the viewport isn't recalculated
     * and then the dialogs don't shake.
     *
     * Also, we need to fixed height viewport,
     * so that when focusing the dialogs don't shake
     */
    patchCssStyles() {
        const documentRef = this.windowRef.document;
        for (const element of [documentRef.documentElement, documentRef.body]) {
            element.style.setProperty(`overflow`, `auto`);
            element.style.setProperty(`height`, `100%`);
        }
    }
};
TuiIosAutofocusHandler.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
TuiIosAutofocusHandler = __decorate([
    Directive(),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(Renderer2)),
    __param(3, Inject(NgZone)),
    __param(4, Inject(WINDOW))
], TuiIosAutofocusHandler);

const TUI_AUTOFOCUS_HANDLER = new InjectionToken(`Autofocusing handler`);
// TODO: 3.0 remove in ivy compilation
function tuiAutofocusHandlerFactory(tuiFocusableComponent, elementRef, animationFrame$, renderer, ngZone, windowRef, isIos) {
    return isIos
        ? new TuiIosAutofocusHandler(tuiFocusableComponent, elementRef, renderer, ngZone, windowRef)
        : new TuiDefaultAutofocusHandler(tuiFocusableComponent, elementRef, animationFrame$);
}
const TUI_AUTOFOCUS_PROVIDERS = [
    {
        provide: TUI_AUTOFOCUS_HANDLER,
        // TODO: replace to useClass in v3.0
        useFactory: tuiAutofocusHandlerFactory,
        deps: [
            [new Optional(), new Self(), TUI_FOCUSABLE_ITEM_ACCESSOR],
            ElementRef,
            ANIMATION_FRAME,
            Renderer2,
            NgZone,
            WINDOW,
            TUI_IS_IOS,
        ],
    },
];

// TODO: 3.0 change input name to tuiAutoFocus and handle empty string
let TuiAutoFocusDirective = class TuiAutoFocusDirective {
    constructor(handler) {
        this.handler = handler;
        this.autoFocus = true;
    }
    ngAfterViewInit() {
        if (this.autoFocus) {
            this.focus();
        }
    }
    focus() {
        void Promise.resolve().then(() => this.handler.setFocus());
    }
};
TuiAutoFocusDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [TUI_AUTOFOCUS_HANDLER,] }] }
];
__decorate([
    Input()
], TuiAutoFocusDirective.prototype, "autoFocus", void 0);
TuiAutoFocusDirective = __decorate([
    Directive({
        selector: '[tuiAutoFocus]',
        providers: TUI_AUTOFOCUS_PROVIDERS,
    }),
    __param(0, Inject(TUI_AUTOFOCUS_HANDLER))
], TuiAutoFocusDirective);

let TuiAutoFocusModule = class TuiAutoFocusModule {
};
TuiAutoFocusModule = __decorate([
    NgModule({
        declarations: [TuiAutoFocusDirective],
        exports: [TuiAutoFocusDirective],
    })
], TuiAutoFocusModule);

let TuiSynchronousAutofocusHandler = class TuiSynchronousAutofocusHandler extends AbstractTuiAutofocusHandler {
    constructor(tuiFocusableComponent, elementRef) {
        super(tuiFocusableComponent, elementRef);
    }
    setFocus() {
        this.element.focus();
    }
};
TuiSynchronousAutofocusHandler.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [TUI_FOCUSABLE_ITEM_ACCESSOR,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] }
];
TuiSynchronousAutofocusHandler = __decorate([
    Directive(),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(TUI_FOCUSABLE_ITEM_ACCESSOR)),
    __param(1, Inject(ElementRef))
], TuiSynchronousAutofocusHandler);

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiAutofocusHandler, TUI_AUTOFOCUS_HANDLER, TUI_AUTOFOCUS_PROVIDERS, TuiAutoFocusDirective, TuiAutoFocusModule, TuiDefaultAutofocusHandler, TuiIosAutofocusHandler, TuiSynchronousAutofocusHandler, tuiAutofocusHandlerFactory };
//# sourceMappingURL=taiga-ui-cdk-directives-auto-focus.js.map
