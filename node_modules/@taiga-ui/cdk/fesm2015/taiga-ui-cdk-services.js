import { __decorate, __param } from 'tslib';
import { Injectable, ComponentFactoryResolver, Inject, Injector, INJECTOR, Renderer2, ɵɵdefineInjectable, ɵɵinject, ElementRef, ChangeDetectorRef, NgZone, Self } from '@angular/core';
import { ReplaySubject, Observable, merge, defer, fromEvent, of, timer } from 'rxjs';
import { DOCUMENT } from '@angular/common';
import { TUI_DEFAULT_RENDERER, TUI_SWIPE_OPTIONS, TUI_ZOOM_OPTIONS } from '@taiga-ui/cdk/tokens';
import { focusVisibleObservable, watch, typedFromEvent, tuiZoneOptimized, tuiZonefree, preventDefault } from '@taiga-ui/cdk/observables';
import { takeUntil, switchMap, filter, take, mapTo, startWith, distinctUntilChanged, delay, throttleTime, map, switchMapTo, pairwise, repeat, catchError, debounceTime, tap, shareReplay, scan } from 'rxjs/operators';
import { getActualTarget, getElementObscurers } from '@taiga-ui/cdk/utils/dom';
import { WINDOW, ANIMATION_FRAME, PERFORMANCE } from '@ng-web-apis/common';
import { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';
import { ResizeObserverService, RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX } from '@ng-web-apis/resize-observer';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { tuiClamp } from '@taiga-ui/cdk/utils/math';
import { tuiEaseInOutQuad, getSwipeDirection, isPresent } from '@taiga-ui/cdk/utils/miscellaneous';
import { distanceBetweenTouches } from '@taiga-ui/cdk/utils';

/**
 * Observable abstraction over ngOnDestroy to use with takeUntil
 */
let TuiDestroyService = class TuiDestroyService extends ReplaySubject {
    constructor() {
        super(1);
    }
    ngOnDestroy() {
        this.next();
        this.complete();
    }
};
TuiDestroyService = __decorate([
    Injectable()
], TuiDestroyService);

/**
 * Service to use styles with directives
 * @dynamic
 */
let TuiDirectiveStylesService = class TuiDirectiveStylesService {
    constructor(resolver, injector, documentRef, renderer) {
        this.resolver = resolver;
        this.injector = injector;
        this.documentRef = documentRef;
        this.renderer = renderer;
        this.map = new Map();
    }
    addComponent(component) {
        if (!this.map.has(component)) {
            this.map.set(component, this.resolver.resolveComponentFactory(component).create(this.injector));
        }
    }
    /** @deprecated use components approach
     * TODO: delete in v3.0
     */
    addStyle(styles, attribute) {
        if (this.documentRef.head.querySelector(`style[${attribute}]`)) {
            return;
        }
        const style = this.renderer.createElement(`style`);
        this.renderer.setProperty(style, `textContent`, styles);
        this.renderer.setAttribute(style, attribute, ``);
        this.documentRef.head.appendChild(style);
    }
};
TuiDirectiveStylesService.ctorParameters = () => [
    { type: ComponentFactoryResolver, decorators: [{ type: Inject, args: [ComponentFactoryResolver,] }] },
    { type: Injector, decorators: [{ type: Inject, args: [INJECTOR,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2, decorators: [{ type: Inject, args: [TUI_DEFAULT_RENDERER,] }] }
];
TuiDirectiveStylesService.ɵprov = ɵɵdefineInjectable({ factory: function TuiDirectiveStylesService_Factory() { return new TuiDirectiveStylesService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(INJECTOR), ɵɵinject(DOCUMENT), ɵɵinject(TUI_DEFAULT_RENDERER)); }, token: TuiDirectiveStylesService, providedIn: "root" });
TuiDirectiveStylesService = __decorate([
    Injectable({
        providedIn: `root`,
    }),
    __param(0, Inject(ComponentFactoryResolver)),
    __param(1, Inject(INJECTOR)),
    __param(2, Inject(DOCUMENT)),
    __param(3, Inject(TUI_DEFAULT_RENDERER))
], TuiDirectiveStylesService);

/**
 * Service to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 * @dynamic
 */
let TuiFocusVisibleService = class TuiFocusVisibleService extends Observable {
    constructor({ nativeElement }, changeDetectorRef, destroy$) {
        super(subscriber => this.focusVisible$.subscribe(subscriber));
        this.focusVisible$ = focusVisibleObservable(nativeElement).pipe(watch(changeDetectorRef), takeUntil(destroy$));
    }
};
TuiFocusVisibleService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
];
TuiFocusVisibleService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(TuiDestroyService))
], TuiFocusVisibleService);

/** @deprecated TODO remove in v3.0 */
// @dynamic
let TuiHoveredService = class TuiHoveredService {
    constructor(documentRef, ngZone) {
        this.ngZone = ngZone;
        this.documentEvents$ = merge(typedFromEvent(documentRef, `mousemove`), typedFromEvent(documentRef, `touchstart`, { capture: true }));
    }
    createHovered$(target, options = { passive: true }) {
        return merge(typedFromEvent(target, `mouseenter`, options), typedFromEvent(target, `touchstart`, options)).pipe(switchMap(() => merge(typedFromEvent(target, `mouseleave`, options), this.documentEvents$.pipe(filter(event => !target.contains(getActualTarget(event))), tuiZoneOptimized(this.ngZone), take(1))).pipe(mapTo(false), startWith(true))), distinctUntilChanged());
    }
};
TuiHoveredService.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] }
];
TuiHoveredService.ɵprov = ɵɵdefineInjectable({ factory: function TuiHoveredService_Factory() { return new TuiHoveredService(ɵɵinject(DOCUMENT), ɵɵinject(NgZone)); }, token: TuiHoveredService, providedIn: "root" });
TuiHoveredService = __decorate([
    Injectable({
        providedIn: `root`,
    }),
    __param(0, Inject(DOCUMENT)),
    __param(1, Inject(NgZone))
], TuiHoveredService);

var TuiIdService_1;
const TUI = `tui_`;
/**
 * Generates unique ids
 */
let TuiIdService = TuiIdService_1 = class TuiIdService {
    generate() {
        return `${TUI}${TuiIdService_1.autoId++}${Date.now()}`;
    }
};
TuiIdService.autoId = 0;
TuiIdService.ɵprov = ɵɵdefineInjectable({ factory: function TuiIdService_Factory() { return new TuiIdService(); }, token: TuiIdService, providedIn: "root" });
TuiIdService = TuiIdService_1 = __decorate([
    Injectable({
        providedIn: `root`,
    })
], TuiIdService);

/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiParentsScrollService = class TuiParentsScrollService extends Observable {
    constructor(elementRef, windowRef) {
        super(subscriber => this.callback$.subscribe(subscriber));
        this.callback$ = defer(() => {
            let { nativeElement } = elementRef;
            const eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge(...eventTargets.map(element => typedFromEvent(element, `scroll`)));
        });
    }
};
TuiParentsScrollService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
TuiParentsScrollService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(WINDOW))
], TuiParentsScrollService);

// @bad TODO: Consider Intersection Observer with fallback to current implementation
/**
 * Service that monitors element visibility by subscribing to scrolls
 * and polling with set interval, returns either null or an array
 * of elements that overlap given element edges
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiObscuredService = class TuiObscuredService extends Observable {
    constructor(parentsScroll$, { nativeElement }, ngZone, windowRef, destroy$, animationFrame$) {
        super(subscriber => this.obscured$.subscribe(subscriber));
        this.obscured$ = merge(
        // delay is added so it will not interfere with other listeners
        merge(parentsScroll$, fromEvent(windowRef, `resize`)).pipe(delay(0)), animationFrame$.pipe(throttleTime(POLLING_TIME))).pipe(map(() => getElementObscurers(nativeElement)), startWith(null), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$));
    }
};
TuiObscuredService.ctorParameters = () => [
    { type: TuiParentsScrollService, decorators: [{ type: Inject, args: [TuiParentsScrollService,] }, { type: Self }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
TuiObscuredService = __decorate([
    Injectable(),
    __param(0, Inject(TuiParentsScrollService)),
    __param(0, Self()),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(NgZone)),
    __param(3, Inject(WINDOW)),
    __param(4, Inject(TuiDestroyService)),
    __param(5, Inject(ANIMATION_FRAME))
], TuiObscuredService);

/**
 * @dynamic
 */
let TuiPanService = class TuiPanService extends Observable {
    constructor({ nativeElement }, documentRef) {
        super(subscriber => {
            merge(typedFromEvent(nativeElement, `touchstart`, { passive: true }), typedFromEvent(nativeElement, `mousedown`))
                .pipe(switchMapTo(merge(typedFromEvent(documentRef, `touchmove`, {
                passive: true,
            }).pipe(filter(({ touches }) => touches.length < 2), map(({ touches }) => touches[0])), typedFromEvent(documentRef, `mousemove`))), pairwise(), map(([first, second]) => {
                const deltaX = second.clientX - first.clientX;
                const deltaY = second.clientY - first.clientY;
                return [deltaX, deltaY];
            }), 
            // eslint-disable-next-line rxjs/no-unsafe-takeuntil
            takeUntil(merge(typedFromEvent(documentRef, `touchend`), typedFromEvent(documentRef, `mouseup`))), repeat())
                .subscribe(subscriber);
        });
    }
};
TuiPanService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
TuiPanService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(DOCUMENT))
], TuiPanService);

// @dynamic
let TuiResizeService = class TuiResizeService extends ResizeObserverService {
    constructor(elementRef, ngZone, destroy$, support, box, animationFrame$) {
        super(elementRef, ngZone, support, box);
        return this.pipe(catchError(() => animationFrame$.pipe(throttleTime(POLLING_TIME), map(() => `${elementRef.nativeElement.clientWidth} ${elementRef.nativeElement.clientHeight}`), distinctUntilChanged(), mapTo(EMPTY_ARRAY))), debounceTime(0), tuiZonefree(ngZone), takeUntil(destroy$));
    }
};
TuiResizeService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [RESIZE_OBSERVER_SUPPORT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [RESIZE_OPTION_BOX,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
TuiResizeService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(NgZone)),
    __param(2, Inject(TuiDestroyService)),
    __param(3, Inject(RESIZE_OBSERVER_SUPPORT)),
    __param(4, Inject(RESIZE_OPTION_BOX)),
    __param(5, Inject(ANIMATION_FRAME))
], TuiResizeService);

const SCROLL_TIME = 300;
// @dynamic
let TuiScrollService = class TuiScrollService {
    constructor(performanceRef, animationFrame$) {
        this.performanceRef = performanceRef;
        this.animationFrame$ = animationFrame$;
    }
    scroll$(elementOrWindow, scrollTop, scrollLeft = getX(elementOrWindow), duration = SCROLL_TIME) {
        tuiAssert.assert(duration >= 0, `Duration cannot be negative`);
        tuiAssert.assert(scrollTop >= 0, `scrollTop cannot be negative`);
        tuiAssert.assert(scrollLeft >= 0, `scrollLeft cannot be negative`);
        const initialTop = getY(elementOrWindow);
        const initialLeft = getX(elementOrWindow);
        const deltaTop = scrollTop - initialTop;
        const deltaLeft = scrollLeft - initialLeft;
        const observable = !duration
            ? of([scrollTop, scrollLeft])
            : defer(() => of(this.performanceRef.now())).pipe(switchMap(start => this.animationFrame$.pipe(map(now => now - start))), map(elapsed => tuiEaseInOutQuad(tuiClamp(elapsed / duration, 0, 1))), map(percent => [
                initialTop + deltaTop * percent,
                initialLeft + deltaLeft * percent,
            ]), takeUntil(timer(duration)));
        return observable.pipe(tap(([scrollTop, scrollLeft]) => {
            var _a;
            (_a = elementOrWindow.scrollTo) === null || _a === void 0 ? void 0 : _a.call(elementOrWindow, scrollLeft, scrollTop);
        }));
    }
};
TuiScrollService.ctorParameters = () => [
    { type: Performance, decorators: [{ type: Inject, args: [PERFORMANCE,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
TuiScrollService.ɵprov = ɵɵdefineInjectable({ factory: function TuiScrollService_Factory() { return new TuiScrollService(ɵɵinject(PERFORMANCE), ɵɵinject(ANIMATION_FRAME)); }, token: TuiScrollService, providedIn: "root" });
TuiScrollService = __decorate([
    Injectable({
        providedIn: `root`,
    }),
    __param(0, Inject(PERFORMANCE)),
    __param(1, Inject(ANIMATION_FRAME))
], TuiScrollService);
function getX(elementOrWindow) {
    return `scrollX` in elementOrWindow
        ? elementOrWindow.scrollX
        : elementOrWindow.scrollLeft;
}
function getY(elementOrWindow) {
    return `scrollY` in elementOrWindow
        ? elementOrWindow.scrollY
        : elementOrWindow.scrollTop;
}

let TuiStaticRequestService = class TuiStaticRequestService {
    constructor() {
        this.cache = new Map();
    }
    request(url) {
        const cache = this.cache.get(url);
        if (cache) {
            return cache;
        }
        const observable = new Observable((observer) => {
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    const response = xhr.responseType ? xhr.response : xhr.responseText;
                    if (xhr.status === 200) {
                        observer.next(response);
                        observer.complete();
                    }
                    else {
                        observer.error(response);
                    }
                }
            };
            xhr.open(`GET`, url);
            xhr.send();
            return () => {
                xhr.abort();
            };
        });
        const piped = observable.pipe(shareReplay({ bufferSize: 1, refCount: false }));
        this.cache.set(url, piped);
        return piped;
    }
};
TuiStaticRequestService.ɵprov = ɵɵdefineInjectable({ factory: function TuiStaticRequestService_Factory() { return new TuiStaticRequestService(); }, token: TuiStaticRequestService, providedIn: "root" });
TuiStaticRequestService = __decorate([
    Injectable({
        providedIn: `root`,
    })
], TuiStaticRequestService);

/**
 * @dynamic
 */
let TuiSwipeService = class TuiSwipeService extends Observable {
    constructor({ nativeElement }, { timeout, threshold }, documentRef) {
        super(subscriber => {
            merge(typedFromEvent(nativeElement, `touchstart`, { passive: true }), typedFromEvent(documentRef, `touchend`))
                .pipe(pairwise(), filter(([first, second]) => !!first.touches.length &&
                first.touches[0].identifier ===
                    second.changedTouches[0].identifier), map(([start, end]) => {
                const startX = start.touches[0].clientX;
                const startY = start.touches[0].clientY;
                const endX = end.changedTouches[0].clientX;
                const endY = end.changedTouches[0].clientY;
                const distanceX = startX - endX;
                const distanceY = startY - endY;
                const duration = end.timeStamp - start.timeStamp;
                if ((Math.abs(distanceX) > threshold ||
                    Math.abs(distanceY) > threshold) &&
                    duration < timeout) {
                    return {
                        direction: getSwipeDirection(distanceX, distanceY),
                        events: [start, end],
                    };
                }
                return null;
            }), filter(isPresent))
                .subscribe(subscriber);
        });
    }
};
TuiSwipeService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_SWIPE_OPTIONS,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
TuiSwipeService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(TUI_SWIPE_OPTIONS)),
    __param(2, Inject(DOCUMENT))
], TuiSwipeService);

const TOUCH_SENSITIVITY = 0.01;
// @dynamic
let TuiZoomService = class TuiZoomService extends Observable {
    constructor({ nativeElement }, { wheelSensitivity }) {
        super(subscriber => {
            merge(typedFromEvent(nativeElement, `touchstart`, { passive: true }).pipe(filter(({ touches }) => touches.length > 1), switchMap(startEvent => typedFromEvent(nativeElement, `touchmove`, {
                passive: true,
            }).pipe(preventDefault(), scan((prev, event) => {
                const distance = distanceBetweenTouches(event);
                return {
                    event,
                    distance,
                    delta: (distance - prev.distance) *
                        TOUCH_SENSITIVITY,
                };
            }, {
                event: startEvent,
                distance: distanceBetweenTouches(startEvent),
                delta: 0,
            }), map(({ event, delta }) => {
                const clientX = (event.touches[0].clientX +
                    event.touches[1].clientX) /
                    2;
                const clientY = (event.touches[0].clientY +
                    event.touches[1].clientY) /
                    2;
                return { clientX, clientY, delta, event };
            }), takeUntil(typedFromEvent(nativeElement, `touchend`))))), typedFromEvent(nativeElement, `wheel`, { passive: false }).pipe(preventDefault(), map(wheel => ({
                clientX: wheel.clientX,
                clientY: wheel.clientY,
                delta: -wheel.deltaY * wheelSensitivity,
                event: wheel,
            })))).subscribe(subscriber);
        });
    }
};
TuiZoomService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_ZOOM_OPTIONS,] }] }
];
TuiZoomService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(TUI_ZOOM_OPTIONS))
], TuiZoomService);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiHoveredService, TuiIdService, TuiObscuredService, TuiPanService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService, TuiSwipeService, TuiZoomService };
//# sourceMappingURL=taiga-ui-cdk-services.js.map
