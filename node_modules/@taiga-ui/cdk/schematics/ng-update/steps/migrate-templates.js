"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ng_morph_1 = require("ng-morph");
const constants_1 = require("../../constants");
const add_unique_import_1 = require("../../utils/add-unique-import");
const ng_component_1 = require("../../utils/angular/ng-component");
const colored_log_1 = require("../../utils/colored-log");
const progress_1 = require("../../utils/progress");
const elements_1 = require("../../utils/templates/elements");
const get_component_templates_1 = require("../../utils/templates/get-component-templates");
const ng_component_input_manipulations_1 = require("../../utils/templates/ng-component-input-manipulations");
const template_resource_1 = require("../../utils/templates/template-resource");
const templates_1 = require("../constants/templates");
const START_TAG_OFFSET = 1;
const END_TAG_OFFSET = 2;
function migrateTemplates(fileSystem) {
    colored_log_1.infoLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.REPLACE_SYMBOL} migrating templates...`);
    const componentWithTemplatesPaths = get_component_templates_1.getComponentTemplates(constants_1.ALL_TS_FILES);
    const actions = [
        replaceTags,
        replaceAttrs,
        replaceAttrsByDirective,
        replaceBreadcrumbs,
        replaceFieldError,
        addHTMLCommentTags,
        addEditorProviders,
        migrateTuiHideSelectedPipe,
        removeInputs,
    ];
    componentWithTemplatesPaths.forEach((resource, templateIndex, templates) => {
        const path = fileSystem.resolve(template_resource_1.getPathFromTemplateResource(resource));
        const recorder = fileSystem.edit(path);
        const isLastTemplate = templateIndex === templates.length - 1;
        actions.forEach((action, actionIndex) => {
            const isLastAction = actionIndex === actions.length - 1;
            const progressLog = `${templateIndex + 1} / ${templates.length} (${action.name}...)`;
            progress_1.printProgress(`${colored_log_1.SMALL_TAB_SYMBOL.repeat(2)}${progressLog}`, isLastTemplate && isLastAction);
            action({ resource, fileSystem, recorder });
        });
    });
    colored_log_1.successLog(`${colored_log_1.SMALL_TAB_SYMBOL}${colored_log_1.SUCCESS_SYMBOL} templates migrated \n`);
}
exports.migrateTemplates = migrateTemplates;
function replaceAttrsByDirective({ resource, fileSystem, }) {
    templates_1.ATTR_TO_DIRECTIVE.forEach(({ componentSelector, directiveModule, directive, inputProperty, filterFn }) => {
        ng_component_input_manipulations_1.replaceInputPropertyByDirective({
            componentSelector,
            directiveModule,
            directive,
            inputProperty,
            fileSystem,
            templateResource: resource,
            filterFn,
        });
    });
}
function replaceAttrs({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.ATTRS_TO_REPLACE.forEach(({ from, to }) => {
        const offsets = [
            ...elements_1.findAttributeOnElementWithTag(template, from.attrName, from.withTagNames || [], from.filterFn),
            ...elements_1.findAttributeOnElementWithAttrs(template, from.attrName, from.withAttrsNames || [], from.filterFn),
        ];
        offsets.forEach(offset => {
            recorder.remove(offset + templateOffset, from.attrName.length);
            recorder.insertRight(offset + templateOffset, to.attrName);
        });
    });
}
function replaceTags({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.TAGS_TO_REPLACE.forEach(({ from, to, addAttributes }) => {
        const elements = elements_1.findElementsByTagName(template, from);
        elements.forEach(({ sourceCodeLocation }) => {
            if (sourceCodeLocation) {
                replaceTag(recorder, sourceCodeLocation, from, to, templateOffset, addAttributes);
            }
        });
    });
}
function addHTMLCommentTags({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.TEMPLATE_COMMENTS.forEach(({ comment, tag, withAttr }) => {
        const elementStartOffsets = [
            ...elements_1.findElementsWithAttribute(template, withAttr),
            ...elements_1.findElementsWithAttribute(template, `[${withAttr}]`),
        ]
            .filter(el => el.tagName === tag)
            .map(el => { var _a; return (((_a = el.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.startOffset) || 0) + templateOffset; });
        elementStartOffsets.forEach(offset => {
            recorder.insertRight(offset, `<!-- TODO: (Taiga UI migration) ${comment} -->\n`);
        });
    });
}
function replaceBreadcrumbs({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    const elements = elements_1.findElementsByTagName(template, `tui-breadcrumbs`);
    elements.forEach(element => {
        var _a, _b, _c;
        const itemsAttr = element.attrs.find(attr => attr.name === `[items]`);
        const itemsValue = itemsAttr === null || itemsAttr === void 0 ? void 0 : itemsAttr.value;
        const insertTo = (_a = element === null || element === void 0 ? void 0 : element.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.startTag.endOffset;
        if (!itemsValue || !insertTo) {
            return;
        }
        recorder.insertRight(insertTo + templateOffset, `
    <ng-container *ngFor="let item of ${itemsValue}">
        <a
            *tuiBreadcrumb
            tuiLink
            [routerLink]="item.routerLink"
        >
            {{ item.caption }}
        </a>
    </ng-container>`);
        const { startOffset = 0, endOffset = 0 } = ((_c = (_b = element.sourceCodeLocation) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c[`[items]`]) || {};
        recorder.remove(templateOffset + startOffset - 1, endOffset - startOffset + 1);
    });
}
function replaceFieldError({ resource, recorder, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    const elements = elements_1.findElementsByTagName(template, `tui-field-error`);
    elements.forEach(element => {
        var _a, _b;
        const orderAttr = element.attrs.find(attr => attr.name === `[order]`);
        const orderVal = orderAttr === null || orderAttr === void 0 ? void 0 : orderAttr.value;
        if (orderAttr) {
            const { startOffset = 0, endOffset = 0 } = ((_b = (_a = element.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[`[order]`]) || {};
            recorder.remove(templateOffset + startOffset - 1, endOffset - startOffset + 1);
        }
        const input = `[error]="${orderVal !== null && orderVal !== void 0 ? orderVal : `[]`} | tuiFieldError | async"`;
        replaceTag(recorder, 
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        element.sourceCodeLocation, `tui-field-error`, `tui-error`, templateOffset, [input]);
    });
}
function replaceTag(recorder, sourceCodeLocation, from, to, templateOffset = 0, addAttributes = []) {
    var _a;
    const startTagOffset = sourceCodeLocation.startTag.startOffset;
    const endTagOffset = (_a = sourceCodeLocation.endTag) === null || _a === void 0 ? void 0 : _a.startOffset;
    if (endTagOffset) {
        recorder.remove(endTagOffset + templateOffset + END_TAG_OFFSET, from.length);
        recorder.insertRight(endTagOffset + templateOffset + END_TAG_OFFSET, to);
    }
    recorder.remove(startTagOffset + templateOffset + START_TAG_OFFSET, from.length);
    recorder.insertRight(startTagOffset + templateOffset + START_TAG_OFFSET, `${to} ${addAttributes.join(` `)}`);
}
function addEditorProviders({ resource, fileSystem, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const elements = elements_1.findElementsByTagName(template, `tui-editor`).filter(element => !elements_1.hasElementAttribute(element, `new`));
    if (elements.length) {
        const componentPath = resource.componentPath;
        const componentClass = ng_component_1.getNgComponents(componentPath);
        ng_morph_1.addProviderToComponent(componentClass[0], `{
            provide: TUI_EDITOR_EXTENSIONS,
            useValue: defaultEditorExtensions
        }`, { unique: true });
        add_unique_import_1.addUniqueImport(componentPath, `TUI_EDITOR_EXTENSIONS`, `@taiga-ui/addon-editor`);
        add_unique_import_1.addUniqueImport(componentPath, `defaultEditorExtensions`, `@taiga-ui/addon-editor`);
    }
}
// eslint-disable-next-line unicorn/no-unsafe-regex
const HIDE_SELECTED_PIPE_WITH_ARGS_REG = /\|\s*tuiHideSelected(\s*:\s*[^|'"]*)?/gi;
function migrateTuiHideSelectedPipe({ resource, fileSystem, recorder, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    const elementsWithPipe = elements_1.findElementByFn(template, el => { var _a; return (_a = el.attrs) === null || _a === void 0 ? void 0 : _a.some(attr => attr.value.match(HIDE_SELECTED_PIPE_WITH_ARGS_REG)); });
    elementsWithPipe.forEach(el => {
        var _a;
        const { name, value: oldValue } = el.attrs.find(attr => attr.value.match(HIDE_SELECTED_PIPE_WITH_ARGS_REG)) ||
            {};
        const attrLocations = (_a = el.sourceCodeLocation) === null || _a === void 0 ? void 0 : _a.attrs;
        if (!name || !oldValue || !attrLocations) {
            return;
        }
        const newValue = oldValue.replace(HIDE_SELECTED_PIPE_WITH_ARGS_REG, `| tuiHideSelected`);
        const { startOffset } = attrLocations[name];
        const valueOffset = templateOffset + startOffset + name.length + `="`.length;
        recorder.remove(valueOffset, oldValue.length);
        recorder.insertRight(valueOffset, newValue);
    });
}
function removeInputs({ resource, fileSystem, recorder, }) {
    const template = template_resource_1.getTemplateFromTemplateResource(resource, fileSystem);
    const templateOffset = template_resource_1.getTemplateOffset(resource);
    templates_1.INPUTS_TO_REMOVE.forEach(({ inputName, tags }) => {
        const offsets = [
            ...ng_component_input_manipulations_1.getInputPropertyOffsets(template, inputName, tags),
            ...ng_component_input_manipulations_1.getInputPropertyOffsets(template, `[${inputName}]`, tags),
        ];
        offsets.forEach(([start, end]) => {
            recorder.remove(start + templateOffset, end - start);
        });
    });
}
