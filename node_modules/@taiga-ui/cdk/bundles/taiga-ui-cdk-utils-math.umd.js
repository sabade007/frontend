(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/classes')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/math', ['exports', '@taiga-ui/cdk/classes'], factory) :
    (global = global || self, factory((global['taiga-ui'] = global['taiga-ui'] || {}, global['taiga-ui'].cdk = global['taiga-ui'].cdk || {}, global['taiga-ui'].cdk.utils = global['taiga-ui'].cdk.utils || {}, global['taiga-ui'].cdk.utils.math = {}), global['taiga-ui'].cdk.classes));
}(this, (function (exports, classes) { 'use strict';

    /**
     * @deprecated: use {@link tuiClamp} instead
     * Clamps a value between two inclusive limits
     *
     * @param value
     * @param min lower limit
     * @param max upper limit
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function clamp(value, min, max) {
        classes.tuiAssert.assert(!Number.isNaN(value));
        classes.tuiAssert.assert(!Number.isNaN(min));
        classes.tuiAssert.assert(!Number.isNaN(max));
        classes.tuiAssert.assert(max >= min);
        return Math.min(max, Math.max(min, value));
    }
    var tuiClamp = clamp;

    /**
     * @deprecated: use {@link tuiInRange} instead
     * Checks if the value is in range
     *
     * @param value
     * @param fromInclude lower inclusive limit
     * @param toExclude upper exclusive limit
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function inRange(value, fromInclude, toExclude) {
        classes.tuiAssert.assert(!Number.isNaN(value));
        classes.tuiAssert.assert(!Number.isNaN(fromInclude));
        classes.tuiAssert.assert(!Number.isNaN(toExclude));
        classes.tuiAssert.assert(fromInclude < toExclude);
        return value >= fromInclude && value < toExclude;
    }
    var tuiInRange = inRange;

    /**
     * @deprecated: use {@link tuiNormalizeToIntNumber} instead
     * Normalizes any number to an integer within inclusive range
     *
     * @param value
     * @param min lower inclusive integer
     * @param max upper inclusive integer
     * @return an integer between min and max inclusive
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function normalizeToIntNumber(value, min, max) {
        classes.tuiAssert.assert(Number.isInteger(min));
        classes.tuiAssert.assert(Number.isInteger(max));
        classes.tuiAssert.assert(min <= max);
        if (Number.isNaN(value) || value <= min) {
            return min;
        }
        if (value >= max) {
            return max;
        }
        return Math.round(value);
    }
    var tuiNormalizeToIntNumber = normalizeToIntNumber;

    /**
     * @deprecated: use {@link tuiQuantize} instead
     * Rounds a number to the closest value in a fixed discrete series
     *
     * @param value
     * @param quantum series step
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function quantize(value, quantum) {
        classes.tuiAssert.assert(Number.isFinite(value));
        classes.tuiAssert.assert(Number.isFinite(quantum));
        classes.tuiAssert.assert(quantum > 0);
        var remainder = value % quantum;
        return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
    }
    var tuiQuantize = quantize;

    var MAX_PRECISION = 292;
    /**
     * @deprecated: use {@link tuiRound} instead
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function round(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.round);
    }
    /**
     * @deprecated: use {@link tuiCeil} instead
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function ceil(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.ceil);
    }
    /**
     * @deprecated: use {@link tuiFloor} instead
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function floor(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.floor);
    }
    var tuiRound = round;
    var tuiCeil = ceil;
    var tuiFloor = floor;
    /**
     * Rounding number to the set precision
     *
     * @param value
     * @param precision number of digits in a float part
     * @param func rounding function (round, floor, ceil)
     */
    function calculate(value, precision, func) {
        if (value === Infinity) {
            return value;
        }
        classes.tuiAssert.assert(!Number.isNaN(value), "Value must be number");
        classes.tuiAssert.assert(Number.isInteger(precision), "Precision must be integer");
        precision = Math.min(precision, MAX_PRECISION);
        var pair = (value + "e").split("e");
        var tempValue = func(Number(pair[0] + "e" + (Number(pair[1]) + precision)));
        var processedPair = (tempValue + "e").split("e");
        return Number(processedPair[0] + "e" + (Number(processedPair[1]) - precision));
    }

    /**
     * @deprecated: use {@link tuiSum} instead
     * Calculates sum of any number of passed arguments
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function sum() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.reduce(function (a, b) { return a + b; }, 0);
    }
    var tuiSum = sum;

    /**
     * @deprecated: use {@link tuiToInt} instead
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function toInt(bool) {
        return bool ? 1 : 0;
    }
    var tuiToInt = toInt;

    /**
     * @deprecated: use {@link tuiToRadians} instead
     * Converts angle in degrees to radians
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function toRadians(deg) {
        return (deg * Math.PI) / 180;
    }
    var tuiToRadians = toRadians;

    exports.ceil = ceil;
    exports.clamp = clamp;
    exports.floor = floor;
    exports.inRange = inRange;
    exports.normalizeToIntNumber = normalizeToIntNumber;
    exports.quantize = quantize;
    exports.round = round;
    exports.sum = sum;
    exports.toInt = toInt;
    exports.toRadians = toRadians;
    exports.tuiCeil = tuiCeil;
    exports.tuiClamp = tuiClamp;
    exports.tuiFloor = tuiFloor;
    exports.tuiInRange = tuiInRange;
    exports.tuiNormalizeToIntNumber = tuiNormalizeToIntNumber;
    exports.tuiQuantize = tuiQuantize;
    exports.tuiRound = tuiRound;
    exports.tuiSum = tuiSum;
    exports.tuiToInt = tuiToInt;
    exports.tuiToRadians = tuiToRadians;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taiga-ui-cdk-utils-math.umd.js.map
