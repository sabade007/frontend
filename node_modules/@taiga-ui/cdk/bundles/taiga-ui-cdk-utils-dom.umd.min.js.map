{"version":3,"sources":["ng://@taiga-ui/cdk/utils/dom/can-scroll.ts","ng://@taiga-ui/cdk/utils/dom/contains-or-after.ts","ng://@taiga-ui/cdk/utils/dom/get-actual-target.ts","ng://@taiga-ui/cdk/utils/dom/get-clipboard-data-text.ts","ng://@taiga-ui/cdk/utils/dom/get-closest-element.ts","ng://@taiga-ui/cdk/utils/dom/get-document-or-shadow-root.ts","ng://@taiga-ui/cdk/utils/dom/get-element-obscurers.ts","ng://@taiga-ui/cdk/utils/dom/get-element-offset.ts","ng://@taiga-ui/cdk/utils/dom/get-scroll-parent.ts","ng://@taiga-ui/cdk/utils/dom/is-form-field.ts","ng://@taiga-ui/cdk/utils/dom/is-current-target.ts","ng://@taiga-ui/cdk/utils/dom/is-inside-iframe.ts","ng://@taiga-ui/cdk/utils/dom/is-node-in.ts","ng://@taiga-ui/cdk/utils/dom/custom-event.ts","ng://@taiga-ui/cdk/utils/dom/get-selected-text.ts","ng://@taiga-ui/cdk/utils/dom/is-element.ts","ng://@taiga-ui/cdk/utils/dom/point-to-client-rect.ts"],"names":["canScroll","element","rootElement","vertical","scrollEnd","currentElement","parentElement","Math","floor","scrollTop","ceil","clientHeight","scrollHeight","canScrollVertical","scrollLeft","clientWidth","scrollWidth","canScrollHorizontal","tuiCanScroll","containsOrAfter","current","node","contains","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","tuiContainsOrAfter","getActualTarget","event","composedPath","target","tuiGetActualTarget","getClipboardDataText","format","clipboardData","getData","ownerDocument","defaultView","tuiGetClipboardDataText","getClosestElement","selector","closest","Element","prototype","call","matchesSelector","matches","msMatchesSelector","getDocumentOrShadowRoot","isConnected","getRootNode","tuiGetDocumentOrShadowRoot","getElementObscurers","_a","innerWidth","innerHeight","documentRef","rect","getBoundingClientRect","left","clamp","round","top","right","bottom","horizontalMiddle","width","verticalMiddle","height","nonNull","elementFromPoint","filter","isPresent","length","filtered","el","tuiGetElementObscures","getElementOffset","host","tuiAssert","assert","offsetTop","offsetLeft","offsetParent","HTMLElement","tuiGetElementOffset","getScrollParent","tuiGetScrollParent","tuiIsFormFieldElement","isCurrentTarget","currentTarget","tuiIsCurrentTarget","isInsideIframe","windowRef","parent","tuiIsInsideIframe","isNodeIn","nodeType","TEXT_NODE","ELEMENT_NODE","tuiIsNodeIn","name","_b","_c","bubbles","_d","cancelable","_e","detail","CustomEvent","customEvent","createEvent","initCustomEvent","getSelection","document","activeElement","value","slice","selectionStart","selectionEnd","toString","x","y"],"mappings":"oqBAIgBA,EACZC,EACAC,EACAC,EACAC,GAEA,OAAOD,EAOX,SACIF,EACAC,EACAE,GAEA,IAAIC,EAAiBJ,EAErB,KAAOI,IAAmBH,EAAYI,eAAe,CACjD,GACKC,KAAKC,MAAMH,EAAeI,WAAa,IAAML,GAC7CG,KAAKG,KAAKL,EAAeI,UAAYJ,EAAeM,cACjDN,EAAeO,cACfR,EAEJ,OAAO,EAGX,IAAIC,EAAeC,cAGf,OAAO,EAFPD,EAAiBA,EAAeC,cAMxC,OAAO,EA9BDO,CAAkBZ,EAASC,EAAaE,GAiClD,SACIH,EACAC,EACAE,GAEA,IAAIC,EAAiBJ,EAErB,KAAOI,IAAmBH,EAAYI,eAAe,CACjD,GACKC,KAAKC,MAAMH,EAAeS,YAAc,IAAMV,GAC9CG,KAAKG,KAAKL,EAAeS,WAAaT,EAAeU,aAClDV,EAAeW,aACfZ,EAEJ,OAAO,EAGX,IAAIC,EAAeC,cAGf,OAAO,EAFPD,EAAiBA,EAAeC,cAMxC,OAAO,EAxDDW,CAAoBhB,EAASC,EAAaE,OAGvCc,EAAelB,WCXZmB,EAAgBC,EAAeC,GAC3C,OACID,EAAQE,SAASD,OACdA,EAAKE,wBAAwBH,GAAWI,KAAKC,iCAI3CC,EAAqBP,WCNlBQ,EAAgBC,GAC5B,MAAI,iBAAkBA,EACVA,EAAcC,eAAe,GAGjCD,EAAcE,WAGbC,EAAqBJ,WCNlBK,EACZJ,EACAK,GAEA,YAFA,IAAAA,IAAAA,EATmB,cAWZ,kBAAmBL,GAAiC,OAAxBA,EAAMM,cACnCN,EAAMM,cAAcC,QAAQF,IACxBL,EAAMM,cAAcC,QAbX,cAcZP,EAAcE,OAAOM,cAAcC,YAAYH,cAAcC,QAAQ,YAGnEG,EAA0BN,WCZvBO,EAAkBtC,EAAkBuC,GAChD,IAAMC,EAAUC,QAAQC,UAAUF,QAElC,GAAIA,EACA,OAAOA,EAAQG,KAAK3C,EAASuC,GAGjC,IAAMK,EACFH,QAAQC,UAAUG,SAAYJ,QAAQC,UAAkBI,kBAE5D,EAAG,CACC,GAAIF,EAAgBD,KAAK3C,EAASuC,GAC9B,OAAOvC,EAGXA,EAAUA,EAAQK,oBACD,OAAZL,GAET,OAAO,cCnBK+C,EAAwB3B,GACpC,MAAO,gBAAiBA,GAAQA,EAAK4B,YAC9B5B,EAAK6B,cACL7B,EAAKe,kBAGHe,EAA6BH,WCE1BI,EAAoBnD,GACzB,IAAAmC,EAAAnC,EAAAmC,cAEP,KAAKA,MAAAA,OAAa,EAAbA,EAAeC,aAChB,OAAO,KAGL,IAAAgB,EAAAjB,EAAAC,YAACiB,EAAAD,EAAAC,WAAYC,EAAAF,EAAAE,YACbC,EAAcR,EAAwB/C,GACtCwD,EAAOxD,EAAQyD,wBACfC,EAAOC,EAAAA,MAAMrD,KAAKsD,MAAMJ,EAAKE,MAAQ,EAAG,EAAGL,GAC3CQ,EAAMF,EAAAA,MAAMrD,KAAKsD,MAAMJ,EAAKK,KAAO,EAAG,EAAGP,GACzCQ,EAAQH,EAAAA,MAAMrD,KAAKsD,MAAMJ,EAAKM,OAAS,EAAG,EAAGT,GAC7CU,EAASJ,EAAAA,MAAMrD,KAAKsD,MAAMJ,EAAKO,QAAU,EAAG,EAAGT,GAC/CU,EAAmBL,EAAAA,MAAMrD,KAAKsD,MAAMJ,EAAKE,KAAOF,EAAKS,MAAQ,GAAI,EAAGZ,GACpEa,EAAiBP,EAAAA,MAAMrD,KAAKsD,MAAMJ,EAAKK,IAAML,EAAKW,OAAS,GAAI,EAAGb,GAOlEc,EANW,CACbb,EAAYc,iBAAiBL,EAAkBH,GAC/CN,EAAYc,iBAAiBL,EAAkBD,GAC/CR,EAAYc,iBAAiBX,EAAMQ,GACnCX,EAAYc,iBAAiBP,EAAOI,IAEfI,OAAOC,EAAAA,WAEhC,IAAKH,EAAQI,OACT,OAAOJ,EAGX,IAAMK,EAAWL,EAAQE,QAAO,SAAAI,GAAM,OAAC1E,EAAQqB,SAASqD,MAExD,OAA2B,IAApBD,EAASD,OAAeC,EAAW,SAGjCE,EAAwBxB,WClCrByB,EACZC,EACA7E,GAEA8E,EAAAA,UAAUC,OAAOF,EAAKxD,SAASrB,GAAU,6BAKzC,IAHK,IAAAgF,EAAAhF,EAAAgF,UAAWC,EAAAjF,EAAAiF,WAAYC,EAAAlF,EAAAkF,aAGrBA,GAAgBA,aAAwBC,aAAeD,IAAiBL,GAC3EG,GAAaE,EAAaF,UAC1BC,GAAcC,EAAaD,WAC3BC,EAAeA,EAAaA,aAGhC,MAAO,CAACF,UAASA,EAAEC,WAAUA,OAGpBG,EAAsBR,WCrBnBS,EACZrF,EACAE,GAEA,YAFA,IAAAA,IAAAA,GAAA,GAEgB,OAAZF,EACO,KAGPE,GAAYF,EAAQW,aAAeX,EAAQU,eAI1CR,GAAYF,EAAQe,YAAcf,EAAQc,YAHpCd,EAOJqF,EAAgBrF,EAAQK,cAAeH,OAGrCoF,EAAqBD,WC3BlBE,EACZvF,GAIA,QAFkBA,GAId,UAJcA,GAKd,mBALcA,GAMd,iBANcA,WCCNwF,EAAgBpC,GAC5B,OAD6BA,EAAAvB,SAAQuB,EAAAqC,kBAI5BC,EAAqBF,WCHlBG,EAAeC,GAC3B,OAAOA,EAAUC,SAAWD,MAGnBE,EAAoBH,WCEjBI,EAAS3E,EAAYmB,GACjC,OAAOnB,EAAK4E,WAAazE,KAAK0E,YACtB7E,EAAKf,iBAAmBiC,EAAkBlB,EAAKf,cAAekC,GAChEnB,EAAK4E,WAAazE,KAAK2E,gBACjB5D,EAAkBlB,EAAiBmB,OAGtC4D,EAAcJ,0TChBvBK,EACAhD,EACAG,OADA8C,OAAA,IAAAjD,EAAA,GAAAA,EAACkD,EAAAD,EAAAE,QAAAA,OAAA,IAAAD,GAAAA,EAAiBE,EAAAH,EAAAI,WAAAA,OAAA,IAAAD,GAAAA,EAAoBE,EAAAL,EAAAM,OAAAA,OAAA,IAAAD,EAAA,KAAAA,EAGtC,GAA2B,mBAAhBE,YACP,OAAO,IAAIA,YAAYR,EAAM,CAACG,QAAOA,EAAEE,WAAUA,EAAEE,OAAMA,IAG7D,IAAME,EAActD,EAAYuD,YAAY,eAI5C,OAFAD,EAAYE,gBAAgBX,EAAMG,EAASE,EAAYE,GAEhDE,4LCJwBzD,SAAC4D,EAAA5D,EAAA4D,aAAcC,EAAA7D,EAAA6D,SAC9C,OAAO1B,EAAsB0B,EAASC,eAChCD,EAASC,cAAcC,MAAMC,MACzBH,EAASC,cAAcG,gBAAkB,EACzCJ,EAASC,cAAcI,cAAgB,IAE7B,QAAdjB,EAAAW,WAAc,IAAAX,OAAA,EAAAA,EAAEkB,aAAc,qDCdpCnG,GAEA,QAASA,GAAQ,aAAcA,GAAQA,EAAK4E,WAAazE,KAAK2E,8GCJ7BsB,EAAeC,GAChD,YADiC,IAAAD,IAAAA,EAAA,QAAe,IAAAC,IAAAA,EAAA,GACzC,CACH/D,KAAM8D,EACN1D,MAAO0D,EACP3D,IAAK4D,EACL1D,OAAQ0D,EACRxD,MAAO,EACPE,OAAQ","sourcesContent":["/**\n * @deprecated: use {@link tuiCanScroll} instead\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function canScroll(\n    element: Element,\n    rootElement: Element,\n    vertical: boolean,\n    scrollEnd: boolean,\n): boolean {\n    return vertical\n        ? canScrollVertical(element, rootElement, scrollEnd)\n        : canScrollHorizontal(element, rootElement, scrollEnd);\n}\n\nexport const tuiCanScroll = canScroll;\n\nfunction canScrollVertical(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <\n                currentElement.scrollHeight &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n\nfunction canScrollHorizontal(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <\n                currentElement.scrollWidth &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n","/**\n * @deprecated: use {@link tuiContainsOrAfter} instead\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function containsOrAfter(current: Node, node: Node): boolean {\n    return (\n        current.contains(node) ||\n        !!(node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING)\n    );\n}\n\nexport const tuiContainsOrAfter = containsOrAfter;\n","/**\n * @deprecated: use {@link tuiGetActualTarget} instead\n * Gets actual target from open Shadow DOM if event happened within it\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getActualTarget(event: Event): Node {\n    if (`composedPath` in event) {\n        return (event as any).composedPath()[0];\n    }\n\n    return (event as any).target;\n}\n\nexport const tuiGetActualTarget = getActualTarget;\n","const DEFAULT_FORMAT = `text/plain`;\n\n/**\n * @deprecated: use {@link tuiGetClipboardDataText} instead\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getClipboardDataText(\n    event: ClipboardEvent,\n    format: string = DEFAULT_FORMAT,\n): string {\n    return `clipboardData` in event && event.clipboardData !== null\n        ? event.clipboardData.getData(format) ||\n              event.clipboardData.getData(DEFAULT_FORMAT)\n        : (event as any).target.ownerDocument.defaultView.clipboardData.getData(`text`);\n}\n\nexport const tuiGetClipboardDataText = getClipboardDataText;\n","/**\n * @deprecated only needed for IE, remove in 3.0\n * Gets the closest element by selector i.e. {@link Element.closest}\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getClosestElement(element: Element, selector: string): Element | null {\n    const closest = Element.prototype.closest;\n\n    if (closest) {\n        return closest.call(element, selector);\n    }\n\n    const matchesSelector =\n        Element.prototype.matches || (Element.prototype as any).msMatchesSelector;\n\n    do {\n        if (matchesSelector.call(element, selector)) {\n            return element;\n        }\n\n        element = element.parentElement as Element;\n    } while (element !== null);\n\n    return null;\n}\n","/**\n * @deprecated: use {@link tuiGetDocumentOrShadowRoot} instead\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getDocumentOrShadowRoot(node: Node): DocumentOrShadowRoot {\n    return `getRootNode` in node && node.isConnected\n        ? (node.getRootNode() as Document)\n        : (node.ownerDocument as DocumentOrShadowRoot);\n}\n\nexport const tuiGetDocumentOrShadowRoot = getDocumentOrShadowRoot;\n","import {clamp} from '@taiga-ui/cdk/utils/math';\nimport {isPresent} from '@taiga-ui/cdk/utils/miscellaneous';\n\nimport {getDocumentOrShadowRoot} from './get-document-or-shadow-root';\n\n/**\n * @deprecated: use {@link tuiGetElementObscures} instead\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getElementObscurers(element: Element): readonly Element[] | null {\n    const {ownerDocument} = element;\n\n    if (!ownerDocument?.defaultView) {\n        return null;\n    }\n\n    const {innerWidth, innerHeight} = ownerDocument.defaultView;\n    const documentRef = getDocumentOrShadowRoot(element);\n    const rect = element.getBoundingClientRect();\n    const left = clamp(Math.round(rect.left) + 2, 0, innerWidth);\n    const top = clamp(Math.round(rect.top) + 2, 0, innerHeight);\n    const right = clamp(Math.round(rect.right) - 2, 0, innerWidth);\n    const bottom = clamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n    const horizontalMiddle = clamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n    const verticalMiddle = clamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n    const elements = [\n        documentRef.elementFromPoint(horizontalMiddle, top),\n        documentRef.elementFromPoint(horizontalMiddle, bottom),\n        documentRef.elementFromPoint(left, verticalMiddle),\n        documentRef.elementFromPoint(right, verticalMiddle),\n    ];\n    const nonNull = elements.filter(isPresent);\n\n    if (!nonNull.length) {\n        return nonNull;\n    }\n\n    const filtered = nonNull.filter(el => !element.contains(el));\n\n    return filtered.length === 4 ? filtered : null;\n}\n\nexport const tuiGetElementObscures = getElementObscurers;\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * @deprecated: use {@link tuiGetElementOffset} instead\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getElementOffset(\n    host: Element,\n    element: HTMLElement,\n): {offsetTop: number; offsetLeft: number} {\n    tuiAssert.assert(host.contains(element), `Host must contain element`);\n\n    let {offsetTop, offsetLeft, offsetParent} = element;\n\n    // TODO: iframe warning\n    while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {\n        offsetTop += offsetParent.offsetTop;\n        offsetLeft += offsetParent.offsetLeft;\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return {offsetTop, offsetLeft};\n}\n\nexport const tuiGetElementOffset = getElementOffset;\n","/**\n * @deprecated: use {@link tuiGetScrollParent} instead\n * Finds the nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function getScrollParent(\n    element: Element | null,\n    vertical: boolean = true,\n): Element | null {\n    if (element === null) {\n        return null;\n    }\n\n    if (vertical && element.scrollHeight > element.clientHeight) {\n        return element;\n    }\n\n    if (!vertical && element.scrollWidth > element.clientWidth) {\n        return element;\n    }\n\n    return getScrollParent(element.parentElement, vertical);\n}\n\nexport const tuiGetScrollParent = getScrollParent;\n","export function tuiIsFormFieldElement(\n    element: unknown | null,\n): element is HTMLInputElement | HTMLTextAreaElement {\n    const textfield = element as Record<string, unknown> | null;\n\n    return (\n        !!textfield &&\n        `value` in textfield &&\n        `selectionStart` in textfield &&\n        `selectionEnd` in textfield\n    );\n}\n","/**\n * @deprecated: use {@link tuiIsCurrentTarget} instead\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function isCurrentTarget({target, currentTarget}: Event): boolean {\n    return target === currentTarget;\n}\n\nexport const tuiIsCurrentTarget = isCurrentTarget;\n","/**\n * @deprecated: use {@link tuiIsInsideIframe} instead\n * Checks if an app is running inside <iframe /> tag\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function isInsideIframe(windowRef: Window): boolean {\n    return windowRef.parent !== windowRef;\n}\n\nexport const tuiIsInsideIframe = isInsideIframe;\n","import {getClosestElement} from './get-closest-element';\n\n/**\n * @deprecated: use {@link tuiIsNodeIn} instead\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function isNodeIn(node: Node, selector: string): boolean {\n    return node.nodeType === Node.TEXT_NODE\n        ? !!node.parentElement && !!getClosestElement(node.parentElement, selector)\n        : node.nodeType === Node.ELEMENT_NODE &&\n              !!getClosestElement(node as Element, selector);\n}\n\nexport const tuiIsNodeIn = isNodeIn;\n","/** @deprecated only needed for IE, remove in 3.0 */\nexport function tuiCustomEvent<T = null>(\n    name: string,\n    {bubbles = false, cancelable = false, detail = null}: CustomEventInit<T | null> = {},\n    documentRef: Document,\n): CustomEvent {\n    if (typeof CustomEvent === `function`) {\n        return new CustomEvent(name, {bubbles, cancelable, detail});\n    }\n\n    const customEvent = documentRef.createEvent(`CustomEvent`);\n\n    customEvent.initCustomEvent(name, bubbles, cancelable, detail);\n\n    return customEvent;\n}\n","import {tuiIsFormFieldElement} from './is-form-field';\n\n/**\n * @description:\n * cross browser way to get selected text\n *\n * History:\n * BUG - window.getSelection() fails when text selected in a form field\n * https://bugzilla.mozilla.org/show_bug.cgi?id=85686\n */\nexport function tuiGetSelectedText({getSelection, document}: Window): string | null {\n    return tuiIsFormFieldElement(document.activeElement)\n        ? document.activeElement.value.slice(\n              document.activeElement.selectionStart || 0,\n              document.activeElement.selectionEnd || 0,\n          )\n        : getSelection()?.toString() || null;\n}\n","// TODO: Refactor to use this check everywhere\nexport function tuiIsElement(\n    node?: Element | EventTarget | Node | null,\n): node is Element {\n    return !!node && `nodeType` in node && node.nodeType === Node.ELEMENT_NODE;\n}\n","export function tuiPointToClientRect(x: number = 0, y: number = 0): ClientRect {\n    return {\n        left: x,\n        right: x,\n        top: y,\n        bottom: y,\n        width: 0,\n        height: 0,\n    };\n}\n"]}