import { __extends } from "tslib";
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH } from './date-fillers';
import { RANGE_SEPARATOR_CHAR } from './date-time';
import { TuiDay } from './day';
import { TuiMonthRange } from './month-range';
/**
 * Temporary type guard to satisfy ts-overloading of normalizeParse method
 * @deprecated
 */
export var isDateMode = function (dateMode) {
    return ["DMY", "YMD", "MDY"].includes(dateMode);
};
/**
 * An immutable range of two {@link TuiDay} objects
 */
var TuiDayRange = /** @class */ (function (_super) {
    __extends(TuiDayRange, _super);
    function TuiDayRange(from, to) {
        var _this = _super.call(this, from, to) || this;
        _this.from = from;
        _this.to = to;
        tuiAssert.assert(from.daySameOrBefore(to));
        return _this;
    }
    /**
     * Creates range from two days after sorting them
     *
     * @param day1
     * @param day2
     * @return new range with sorted days
     */
    TuiDayRange.sort = function (day1, day2) {
        return day1.daySameOrBefore(day2)
            ? new TuiDayRange(day1, day2)
            : new TuiDayRange(day2, day1);
    };
    /**
     * Parse and correct a day range in string format
     *
     * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy
     * @param dateMode {@link TuiDateMode}
     * @return normalized day range object
     */
    TuiDayRange.normalizeParse = function (rangeString, dateMode) {
        if (dateMode === void 0) { dateMode = "DMY"; }
        var dateFormat = isDateMode(dateMode) ? dateMode : "DMY";
        var leftDay = TuiDay.normalizeParse(rangeString.slice(0, DATE_FILLER_LENGTH), dateFormat);
        if (rangeString.length < DATE_RANGE_FILLER_LENGTH) {
            return new TuiDayRange(leftDay, leftDay);
        }
        return TuiDayRange.sort(leftDay, TuiDay.normalizeParse(rangeString.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), dateFormat));
    };
    Object.defineProperty(TuiDayRange.prototype, "isSingleDay", {
        get: function () {
            return this.from.daySame(this.to);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDayRange.prototype, "formattedDayRange", {
        /**
         * Human readable format.
         * @deprecated use {@link getFormattedDayRange} instead
         */
        get: function () {
            var from = this.from.getFormattedDay("DMY", ".");
            var to = this.to.getFormattedDay("DMY", ".");
            return "" + from + RANGE_SEPARATOR_CHAR + to;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Tests ranges for identity
     *
     * @param another second range to test against current
     * @return `true` if days are identical
     */
    TuiDayRange.prototype.daySame = function (another) {
        return this.from.daySame(another.from) && this.to.daySame(another.to);
    };
    /**
     * Locks range between two days included, or limits from one side if the other is null
     *
     * @param min
     * @param max
     * @return range â€” clamped range
     */
    TuiDayRange.prototype.dayLimit = function (min, max) {
        return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));
    };
    /**
     * Human readable format.
     */
    TuiDayRange.prototype.getFormattedDayRange = function (dateFormat, dateSeparator) {
        var from = this.from.getFormattedDay(dateFormat, dateSeparator);
        var to = this.to.getFormattedDay(dateFormat, dateSeparator);
        return "" + from + RANGE_SEPARATOR_CHAR + to;
    };
    TuiDayRange.prototype.toString = function (dateFormat, dateSeparator) {
        if (dateFormat === void 0) { dateFormat = "DMY"; }
        if (dateSeparator === void 0) { dateSeparator = "."; }
        var from = this.from.getFormattedDay(dateFormat, dateSeparator);
        var to = this.to.getFormattedDay(dateFormat, dateSeparator);
        return "" + from + RANGE_SEPARATOR_CHAR + to;
    };
    return TuiDayRange;
}(TuiMonthRange));
export { TuiDayRange };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LXJhbmdlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kYXRlLXRpbWUvIiwic291cmNlcyI6WyJkYXktcmFuZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRCxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUM1RSxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDakQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUM3QixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRTVDOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxJQUFNLFVBQVUsR0FBRyxVQUFDLFFBQWdCO0lBQ3ZDLE9BQUEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7QUFBeEMsQ0FBd0MsQ0FBQztBQUU3Qzs7R0FFRztBQUNIO0lBQWlDLCtCQUFhO0lBQzFDLHFCQUFxQixJQUFZLEVBQVcsRUFBVTtRQUF0RCxZQUNJLGtCQUFNLElBQUksRUFBRSxFQUFFLENBQUMsU0FHbEI7UUFKb0IsVUFBSSxHQUFKLElBQUksQ0FBUTtRQUFXLFFBQUUsR0FBRixFQUFFLENBQVE7UUFHbEQsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0lBQy9DLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxnQkFBSSxHQUFYLFVBQVksSUFBWSxFQUFFLElBQVk7UUFDbEMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQztZQUM3QixDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQztZQUM3QixDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMs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QUFPLEtBQUcsSUFBSSxHQUFHLG9CQUFvQixHQUFHLEVBQUksQ0FBQztJQUNqRCxDQUFDO0lBQ0wsa0JBQUM7QUFBRCxDQUFDLEFBakhELENBQWlDLGFBQWEsR0FpSDdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt0dWlBc3NlcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvY2xhc3Nlcyc7XG5pbXBvcnQge1R1aURhdGVNb2RlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3R5cGVzJztcblxuaW1wb3J0IHtEQVRFX0ZJTExFUl9MRU5HVEgsIERBVEVfUkFOR0VfRklMTEVSX0xFTkdUSH0gZnJvbSAnLi9kYXRlLWZpbGxlcnMnO1xuaW1wb3J0IHtSQU5HRV9TRVBBUkFUT1JfQ0hBUn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuaW1wb3J0IHtUdWlEYXl9IGZyb20gJy4vZGF5JztcbmltcG9ydCB7VHVpTW9udGhSYW5nZX0gZnJvbSAnLi9tb250aC1yYW5nZSc7XG5cbi8qKlxuICogVGVtcG9yYXJ5IHR5cGUgZ3VhcmQgdG8gc2F0aXNmeSB0cy1vdmVybG9hZGluZyBvZiBub3JtYWxpemVQYXJzZSBtZXRob2RcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBpc0RhdGVNb2RlID0gKGRhdGVNb2RlOiBzdHJpbmcpOiBkYXRlTW9kZSBpcyBUdWlEYXRlTW9kZSA9PlxuICAgIFtgRE1ZYCwgYFlNRGAsIGBNRFlgXS5pbmNsdWRlcyhkYXRlTW9kZSk7XG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIHJhbmdlIG9mIHR3byB7QGxpbmsgVHVpRGF5fSBvYmplY3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBUdWlEYXlSYW5nZSBleHRlbmRzIFR1aU1vbnRoUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGZyb206IFR1aURheSwgcmVhZG9ubHkgdG86IFR1aURheSkge1xuICAgICAgICBzdXBlcihmcm9tLCB0byk7XG5cbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChmcm9tLmRheVNhbWVPckJlZm9yZSh0bykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcmFuZ2UgZnJvbSB0d28gZGF5cyBhZnRlciBzb3J0aW5nIHRoZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXkxXG4gICAgICogQHBhcmFtIGRheTJcbiAgICAgKiBAcmV0dXJuIG5ldyByYW5nZSB3aXRoIHNvcnRlZCBkYXlzXG4gICAgICovXG4gICAgc3RhdGljIHNvcnQoZGF5MTogVHVpRGF5LCBkYXkyOiBUdWlEYXkpOiBUdWlEYXlSYW5nZSB7XG4gICAgICAgIHJldHVybiBkYXkxLmRheVNhbWVPckJlZm9yZShkYXkyKVxuICAgICAgICAgICAgPyBuZXcgVHVpRGF5UmFuZ2UoZGF5MSwgZGF5MilcbiAgICAgICAgICAgIDogbmV3IFR1aURheVJhbmdlKGRheTIsIGRheTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZVBhcnNlKFxuICAgICAgICByYW5nZVN0cmluZzogc3RyaW5nLFxuICAgICAgICBkYXRlRmlsbGVyOiBzdHJpbmcsXG4gICAgICAgIGRhdGVSYW5nZUZpbGxlcjogc3RyaW5nLFxuICAgICk6IFR1aURheVJhbmdlO1xuICAgIHN0YXRpYyBub3JtYWxpemVQYXJzZShyYW5nZVN0cmluZzogc3RyaW5nLCBkYXRlTW9kZT86IFR1aURhdGVNb2RlKTogVHVpRGF5UmFuZ2U7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhbmQgY29ycmVjdCBhIGRheSByYW5nZSBpbiBzdHJpbmcgZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2VTdHJpbmcgYSBzdHJpbmcgb2YgZGF0ZXMgaW4gYSBmb3JtYXQgZGQubW0ueXl5eSAtIGRkLm1tLnl5eXlcbiAgICAgKiBAcGFyYW0gZGF0ZU1vZGUge0BsaW5rIFR1aURhdGVNb2RlfVxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXkgcmFuZ2Ugb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZVBhcnNlKFxuICAgICAgICByYW5nZVN0cmluZzogc3RyaW5nLFxuICAgICAgICBkYXRlTW9kZTogVHVpRGF0ZU1vZGUgfCBzdHJpbmcgPSBgRE1ZYCxcbiAgICApOiBUdWlEYXlSYW5nZSB7XG4gICAgICAgIGNvbnN0IGRhdGVGb3JtYXQgPSBpc0RhdGVNb2RlKGRhdGVNb2RlKSA/IGRhdGVNb2RlIDogYERNWWA7XG5cbiAgICAgICAgY29uc3QgbGVmdERheSA9IFR1aURheS5ub3JtYWxpemVQYXJzZShcbiAgICAgICAgICAgIHJhbmdlU3RyaW5nLnNsaWNlKDAsIERBVEVfRklMTEVSX0xFTkdUSCksXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChyYW5nZVN0cmluZy5sZW5ndGggPCBEQVRFX1JBTkdFX0ZJTExFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVpRGF5UmFuZ2UobGVmdERheSwgbGVmdERheSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVHVpRGF5UmFuZ2Uuc29ydChcbiAgICAgICAgICAgIGxlZnREYXksXG4gICAgICAgICAgICBUdWlEYXkubm9ybWFsaXplUGFyc2UoXG4gICAgICAgICAgICAgICAgcmFuZ2VTdHJpbmcuc2xpY2UoREFURV9GSUxMRVJfTEVOR1RIICsgUkFOR0VfU0VQQVJBVE9SX0NIQVIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXQgaXNTaW5nbGVEYXkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20uZGF5U2FtZSh0aGlzLnRvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIdW1hbiByZWFkYWJsZSBmb3JtYXQuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBnZXRGb3JtYXR0ZWREYXlSYW5nZX0gaW5zdGVhZFxuICAgICAqL1xuICAgIGdldCBmb3JtYXR0ZWREYXlSYW5nZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBmcm9tID0gdGhpcy5mcm9tLmdldEZvcm1hdHRlZERheShgRE1ZYCwgYC5gKTtcbiAgICAgICAgY29uc3QgdG8gPSB0aGlzLnRvLmdldEZvcm1hdHRlZERheShgRE1ZYCwgYC5gKTtcblxuICAgICAgICByZXR1cm4gYCR7ZnJvbX0ke1JBTkdFX1NFUEFSQVRPUl9DSEFSfSR7dG99YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyByYW5nZXMgZm9yIGlkZW50aXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5vdGhlciBzZWNvbmQgcmFuZ2UgdG8gdGVzdCBhZ2FpbnN0IGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBkYXlzIGFyZSBpZGVudGljYWxcbiAgICAgKi9cbiAgICBkYXlTYW1lKGFub3RoZXI6IFR1aURheVJhbmdlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20uZGF5U2FtZShhbm90aGVyLmZyb20pICYmIHRoaXMudG8uZGF5U2FtZShhbm90aGVyLnRvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2NrcyByYW5nZSBiZXR3ZWVuIHR3byBkYXlzIGluY2x1ZGVkLCBvciBsaW1pdHMgZnJvbSBvbmUgc2lkZSBpZiB0aGUgb3RoZXIgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHBhcmFtIG1pblxuICAgICAqIEBwYXJhbSBtYXhcbiAgICAgKiBAcmV0dXJuIHJhbmdlIOKAlCBjbGFtcGVkIHJhbmdlXG4gICAgICovXG4gICAgZGF5TGltaXQobWluOiBUdWlEYXkgfCBudWxsLCBtYXg6IFR1aURheSB8IG51bGwpOiBUdWlEYXlSYW5nZSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5UmFuZ2UodGhpcy5mcm9tLmRheUxpbWl0KG1pbiwgbWF4KSwgdGhpcy50by5kYXlMaW1pdChtaW4sIG1heCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEh1bWFuIHJlYWRhYmxlIGZvcm1hdC5cbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZWREYXlSYW5nZShkYXRlRm9ybWF0OiBUdWlEYXRlTW9kZSwgZGF0ZVNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbS5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IHRvID0gdGhpcy50by5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcik7XG5cbiAgICAgICAgcmV0dXJuIGAke2Zyb219JHtSQU5HRV9TRVBBUkFUT1JfQ0hBUn0ke3RvfWA7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUgPSBgRE1ZYCwgZGF0ZVNlcGFyYXRvcjogc3RyaW5nID0gYC5gKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMuZnJvbS5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IHRvID0gdGhpcy50by5nZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdCwgZGF0ZVNlcGFyYXRvcik7XG5cbiAgICAgICAgcmV0dXJuIGAke2Zyb219JHtSQU5HRV9TRVBBUkFUT1JfQ0hBUn0ke3RvfWA7XG4gICAgfVxufVxuIl19