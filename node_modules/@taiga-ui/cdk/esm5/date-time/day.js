import { __extends } from "tslib";
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { InvalidDayException, InvalidMonthException, InvalidYearException, } from '@taiga-ui/cdk/exceptions';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DATE_FILLER_LENGTH } from './date-fillers';
import { DAYS_IN_WEEK, MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiMonth } from './month';
import { TuiYear } from './year';
// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
var TuiDay = /** @class */ (function (_super) {
    __extends(TuiDay, _super);
    function TuiDay(year, month, day) {
        var _this = _super.call(this, year, month) || this;
        _this.day = day;
        tuiAssert.assert(TuiDay.isValidDay(year, month, day));
        return _this;
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    TuiDay.fromLocalNativeDate = function (date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    };
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    TuiDay.fromUtcNativeDate = function (date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    };
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    TuiDay.isValidDay = function (year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    };
    /**
     * @deprecated DONT USE IT (will be deleted soon)
     *
     * Calculated day on a calendar grid
     *
     * @param month
     * @param row row in a calendar
     * @param col column in a calendar
     * @return resulting day on these coordinates (could exceed passed month)
     */
    TuiDay.getDayFromMonthRowCol = function (month, row, col) {
        tuiAssert.assert(Number.isInteger(row));
        tuiAssert.assert(inRange(row, 0, 6));
        tuiAssert.assert(Number.isInteger(col));
        tuiAssert.assert(inRange(col, 0, DAYS_IN_WEEK));
        var day = row * DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;
        if (day > month.daysCount) {
            day -= month.daysCount;
            month = month.append({ month: 1 });
        }
        if (day <= 0) {
            month = month.append({ month: -1 });
            day = month.daysCount + day;
        }
        return new TuiDay(month.year, month.month, day);
    };
    /**
     * Current day based on local time zone
     */
    TuiDay.currentLocal = function () {
        var nativeDate = new Date();
        var year = nativeDate.getFullYear();
        var month = nativeDate.getMonth();
        var day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    };
    /**
     * Returns current day based on UTC
     */
    TuiDay.currentUtc = function () {
        var nativeDate = new Date();
        var year = nativeDate.getUTCFullYear();
        var month = nativeDate.getUTCMonth();
        var day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    };
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    TuiDay.normalizeOf = function (year, month, day) {
        var normalizedYear = TuiYear.normalizeYearPart(year);
        var normalizedMonth = TuiMonth.normalizeMonthPart(month);
        var normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    };
    TuiDay.lengthBetween = function (from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    };
    TuiDay.parseRawDateString = function (date, dateMode) {
        if (dateMode === void 0) { dateMode = "DMY"; }
        tuiAssert.assert(date.length === DATE_FILLER_LENGTH, "[parseRawDateString]: wrong date string length");
        switch (dateMode) {
            case "YMD":
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case "MDY":
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            default:
            case "DMY":
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    };
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    TuiDay.normalizeParse = function (rawDate, dateMode) {
        if (dateMode === void 0) { dateMode = "DMY"; }
        var _a = this.parseRawDateString(rawDate, dateMode), day = _a.day, month = _a.month, year = _a.year;
        return TuiDay.normalizeOf(year, month, day);
    };
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    TuiDay.jsonParse = function (yearMonthDayString) {
        var _a = this.parseRawDateString(yearMonthDayString, "YMD"), day = _a.day, month = _a.month, year = _a.year;
        if (!TuiYear.isValidYear(year)) {
            throw new InvalidYearException(year);
        }
        if (!TuiMonth.isValidMonth(year, month)) {
            throw new InvalidMonthException(month);
        }
        if (!Number.isInteger(day) ||
            !inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new InvalidDayException(day);
        }
        return new TuiDay(year, month, day);
    };
    TuiDay.normalizeDayPart = function (day, month, year) {
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        var monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return normalizeToIntNumber(day, 1, monthDaysCount);
    };
    Object.defineProperty(TuiDay.prototype, "formattedDayPart", {
        get: function () {
            return padStart(String(this.day), 2, "0");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDay.prototype, "formattedDay", {
        /**
         * @deprecated use {@link getFormattedDay} instead
         * Formatted whole date
         */
        get: function () {
            return this.formattedDayPart + "." + this.formattedMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDay.prototype, "isWeekend", {
        get: function () {
            var dayOfWeek = this.dayOfWeek(false);
            return dayOfWeek === 6 /* Saturday */ || dayOfWeek === 0 /* Sunday */;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    TuiDay.prototype.dayOfWeek = function (startFromMonday) {
        if (startFromMonday === void 0) { startFromMonday = true; }
        var dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    };
    /**
     * Passed date is after current
     */
    TuiDay.prototype.dayBefore = function (another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    };
    /**
     * Passed date is after or equals to current
     */
    TuiDay.prototype.daySameOrBefore = function (another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    };
    /**
     * Passed date is the same as current
     */
    TuiDay.prototype.daySame = function (another) {
        return this.monthSame(another) && this.day === another.day;
    };
    /**
     * Passed date is either before or the same as current
     */
    TuiDay.prototype.daySameOrAfter = function (another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    };
    /**
     * Passed date is before current
     */
    TuiDay.prototype.dayAfter = function (another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    };
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    TuiDay.prototype.dayLimit = function (min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    };
    // TODO: 3.0 Consider removing `backwards` option
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new date object as a result of offsetting current
     */
    TuiDay.prototype.append = function (_a, backwards) {
        var _b = _a.year, year = _b === void 0 ? 0 : _b, _c = _a.month, month = _c === void 0 ? 0 : _c, _d = _a.day, day = _d === void 0 ? 0 : _d;
        if (backwards === void 0) { backwards = false; }
        if (backwards) {
            year *= -1;
            month *= -1;
            day *= -1;
        }
        var totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        var years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        var months = totalMonths % MONTHS_IN_YEAR;
        var days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === 11 /* December */) {
                years++;
                months = 0 /* January */;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === 0 /* January */) {
                years--;
                months = 11 /* December */;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    };
    /**
     * Returns formatted whole date
     */
    TuiDay.prototype.getFormattedDay = function (dateFormat, separator) {
        tuiAssert.assert(separator.length === 1, "Separator should consist of only 1 symbol");
        var dd = this.formattedDayPart;
        var mm = this.formattedMonthPart;
        var yyyy = this.formattedYear;
        switch (dateFormat) {
            case "YMD":
                return "" + yyyy + separator + mm + separator + dd;
            case "MDY":
                return "" + mm + separator + dd + separator + yyyy;
            case "DMY":
            default:
                return "" + dd + separator + mm + separator + yyyy;
        }
    };
    TuiDay.prototype.toString = function (dateFormat, separator) {
        if (dateFormat === void 0) { dateFormat = "DMY"; }
        if (separator === void 0) { separator = "."; }
        return this.getFormattedDay(dateFormat, separator);
    };
    TuiDay.prototype.toJSON = function () {
        return _super.prototype.toJSON.call(this) + "-" + this.formattedDayPart;
    };
    /**
     * Returns native {@link Date} based on local time zone
     */
    TuiDay.prototype.toLocalNativeDate = function () {
        return new Date(this.year, this.month, this.day);
    };
    /**
     * Returns native {@link Date} based on UTC
     */
    TuiDay.prototype.toUtcNativeDate = function () {
        return new Date(Date.UTC(this.year, this.month, this.day));
    };
    return TuiDay;
}(TuiMonth));
export { TuiDay };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kYXRlLXRpbWUvIiwic291cmNlcyI6WyJkYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRCxPQUFPLEVBQ0gsbUJBQW1CLEVBQ25CLHFCQUFxQixFQUNyQixvQkFBb0IsR0FDdkIsTUFBTSwwQkFBMEIsQ0FBQztBQUdsQyxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDcEQsT0FBTyxFQUFDLE9BQU8sRUFBRSxvQkFBb0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRXZFLE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNsRSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFL0IsNkJBQTZCO0FBQzdCOztHQUVHO0FBQ0g7SUFBNEIsMEJBQVE7SUFDaEMsZ0JBQVksSUFBWSxFQUFFLEtBQWEsRUFBVyxHQUFXO1FBQTdELFlBQ0ksa0JBQU0sSUFBSSxFQUFFLEtBQUssQ0FBQyxTQUVyQjtRQUhpRCxTQUFHLEdBQUgsR0FBRyxDQUFRO1FBRXpELFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7O0lBQzFELENBQUM7SUFFRDs7T0FFRztJQUNJLDBCQUFtQixHQUExQixVQUEyQixJQUFVO1FBQ2pDLE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFF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Q3ZELEtBQUssS0FBSyxDQUFDO1lBQ1g7Z0JBQ0ksT0FBTyxLQUFHLEVBQUUsR0FBRyxTQUFTLEdBQUcsRUFBRSxHQUFHLFNBQVMsR0FBRyxJQUFNLENBQUM7U0FDMUQ7SUFDTCxDQUFDO0lBRUQseUJBQVEsR0FBUixVQUFTLFVBQStCLEVBQUUsU0FBdUI7UUFBeEQsMkJBQUEsRUFBQSxrQkFBK0I7UUFBRSwwQkFBQSxFQUFBLGVBQXVCO1FBQzdELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELHVCQUFNLEdBQU47UUFDSSxPQUFVLGlCQUFNLE1BQU0sV0FBRSxTQUFJLElBQUksQ0FBQyxnQkFBa0IsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxrQ0FBaUIsR0FBakI7UUFDSSxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0NBQWUsR0FBZjtRQUNJLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUNMLGFBQUM7QUFBRCxDQUFDLEFBNVpELENBQTRCLFFBQVEsR0E0Wm5DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt0dWlBc3NlcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvY2xhc3Nlcyc7XG5pbXBvcnQge1R1aURheU9mV2VlaywgVHVpTW9udGhOdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvZW51bXMnO1xuaW1wb3J0IHtcbiAgICBJbnZhbGlkRGF5RXhjZXB0aW9uLFxuICAgIEludmFsaWRNb250aEV4Y2VwdGlvbixcbiAgICBJbnZhbGlkWWVhckV4Y2VwdGlvbixcbn0gZnJvbSAnQHRhaWdhLXVpL2Nkay9leGNlcHRpb25zJztcbmltcG9ydCB7VHVpRGF5TGlrZX0gZnJvbSAnQHRhaWdhLXVpL2Nkay9pbnRlcmZhY2VzJztcbmltcG9ydCB7VHVpRGF0ZU1vZGV9IGZyb20gJ0B0YWlnYS11aS9jZGsvdHlwZXMnO1xuaW1wb3J0IHtwYWRTdGFydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9mb3JtYXQnO1xuaW1wb3J0IHtpblJhbmdlLCBub3JtYWxpemVUb0ludE51bWJlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9tYXRoJztcblxuaW1wb3J0IHtEQVRFX0ZJTExFUl9MRU5HVEh9IGZyb20gJy4vZGF0ZS1maWxsZXJzJztcbmltcG9ydCB7REFZU19JTl9XRUVLLCBNSU5fREFZLCBNT05USFNfSU5fWUVBUn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuaW1wb3J0IHtUdWlNb250aH0gZnJvbSAnLi9tb250aCc7XG5pbXBvcnQge1R1aVllYXJ9IGZyb20gJy4veWVhcic7XG5cbi8vIFRPRE86IExvY2FsaXplZCBmb3JtYXR0aW5nXG4vKipcbiAqIEltbXV0YWJsZSBkYXRlIG9iamVjdCwgY29uc2lzdGluZyBvZiBkYXksIG1vbnRoIGFuZCB5ZWFyXG4gKi9cbmV4cG9ydCBjbGFzcyBUdWlEYXkgZXh0ZW5kcyBUdWlNb250aCB7XG4gICAgY29uc3RydWN0b3IoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCByZWFkb25seSBkYXk6IG51bWJlcikge1xuICAgICAgICBzdXBlcih5ZWFyLCBtb250aCk7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpRGF5LmlzVmFsaWREYXkoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMge0BsaW5rIFR1aURheX0gZnJvbSBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTG9jYWxOYXRpdmVEYXRlKGRhdGU6IERhdGUpOiBUdWlEYXkge1xuICAgICAgICByZXR1cm4gbmV3IFR1aURheShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMge0BsaW5rIFR1aURheX0gZnJvbSBuYXRpdmUge0BsaW5rIERhdGV9IHVzaW5nIFVUQ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVXRjTmF0aXZlRGF0ZShkYXRlOiBEYXRlKTogVHVpRGF5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZGl0eSBvZiB5ZWFyLCBtb250aCBhbmQgZGF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEBwYXJhbSBkYXlcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdmFsaWRpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZERheSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBUdWlNb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpICYmXG4gICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGRheSkgJiZcbiAgICAgICAgICAgIGluUmFuZ2UoXG4gICAgICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgICAgIE1JTl9EQVksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGgsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSkgKyAxLFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERPTlQgVVNFIElUICh3aWxsIGJlIGRlbGV0ZWQgc29vbilcbiAgICAgKlxuICAgICAqIENhbGN1bGF0ZWQgZGF5IG9uIGEgY2FsZW5kYXIgZ3JpZFxuICAgICAqXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHBhcmFtIHJvdyByb3cgaW4gYSBjYWxlbmRhclxuICAgICAqIEBwYXJhbSBjb2wgY29sdW1uIGluIGEgY2FsZW5kYXJcbiAgICAgKiBAcmV0dXJuIHJlc3VsdGluZyBkYXkgb24gdGhlc2UgY29vcmRpbmF0ZXMgKGNvdWxkIGV4Y2VlZCBwYXNzZWQgbW9udGgpXG4gICAgICovXG4gICAgc3RhdGljIGdldERheUZyb21Nb250aFJvd0NvbChtb250aDogVHVpTW9udGgsIHJvdzogbnVtYmVyLCBjb2w6IG51bWJlcik6IFR1aURheSB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihyb3cpKTtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChpblJhbmdlKHJvdywgMCwgNikpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoY29sKSk7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoaW5SYW5nZShjb2wsIDAsIERBWVNfSU5fV0VFSykpO1xuXG4gICAgICAgIGxldCBkYXkgPSByb3cgKiBEQVlTX0lOX1dFRUsgKyBjb2wgLSBtb250aC5tb250aFN0YXJ0RGF5c09mZnNldCArIDE7XG5cbiAgICAgICAgaWYgKGRheSA+IG1vbnRoLmRheXNDb3VudCkge1xuICAgICAgICAgICAgZGF5IC09IG1vbnRoLmRheXNDb3VudDtcbiAgICAgICAgICAgIG1vbnRoID0gbW9udGguYXBwZW5kKHttb250aDogMX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheSA8PSAwKSB7XG4gICAgICAgICAgICBtb250aCA9IG1vbnRoLmFwcGVuZCh7bW9udGg6IC0xfSk7XG4gICAgICAgICAgICBkYXkgPSBtb250aC5kYXlzQ291bnQgKyBkYXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheShtb250aC55ZWFyLCBtb250aC5tb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRheSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VycmVudExvY2FsKCk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB5ZWFyID0gbmF0aXZlRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBtb250aCA9IG5hdGl2ZURhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgY29uc3QgZGF5ID0gbmF0aXZlRGF0ZS5nZXREYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IGRheSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VycmVudFV0YygpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IG5hdGl2ZURhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBuYXRpdmVEYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMge0BsaW5rIFR1aURheX0gbm9ybWFsaXppbmcgeWVhciwgbW9udGggYW5kIGRheS4ge0BsaW5rIE5hTn0gaXMgdHVybmVkIGludG8gbWluaW1hbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyIGFueSB5ZWFyIHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZFxuICAgICAqIEBwYXJhbSBtb250aCBhbnkgbW9udGggdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkIChtb250aHMgc3RhcnQgd2l0aCAwKVxuICAgICAqIEBwYXJhbSBkYXkgYW55IGRheSB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWRcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgZGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVPZih5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFllYXIgPSBUdWlZZWFyLm5vcm1hbGl6ZVllYXJQYXJ0KHllYXIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTW9udGggPSBUdWlNb250aC5ub3JtYWxpemVNb250aFBhcnQobW9udGgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRGF5ID0gVHVpRGF5Lm5vcm1hbGl6ZURheVBhcnQoXG4gICAgICAgICAgICBkYXksXG4gICAgICAgICAgICBub3JtYWxpemVkTW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkWWVhcixcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheShub3JtYWxpemVkWWVhciwgbm9ybWFsaXplZE1vbnRoLCBub3JtYWxpemVkRGF5KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbGVuZ3RoQmV0d2Vlbihmcm9tOiBUdWlEYXksIHRvOiBUdWlEYXkpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICh0by50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldFRpbWUoKSAtIGZyb20udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkpIC9cbiAgICAgICAgICAgICAgICAoMTAwMCAqIDYwICogNjAgKiAyNCksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlUmF3RGF0ZVN0cmluZyhcbiAgICAgICAgZGF0ZTogc3RyaW5nLFxuICAgICAgICBkYXRlTW9kZTogVHVpRGF0ZU1vZGUgPSBgRE1ZYCxcbiAgICApOiB7ZGF5OiBudW1iZXI7IG1vbnRoOiBudW1iZXI7IHllYXI6IG51bWJlcn0ge1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFxuICAgICAgICAgICAgZGF0ZS5sZW5ndGggPT09IERBVEVfRklMTEVSX0xFTkdUSCxcbiAgICAgICAgICAgIGBbcGFyc2VSYXdEYXRlU3RyaW5nXTogd3JvbmcgZGF0ZSBzdHJpbmcgbGVuZ3RoYCxcbiAgICAgICAgKTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGVNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIGBZTURgOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSg4LCAxMCksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoNSwgNyksIDEwKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoMCwgNCksIDEwKSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYXNlIGBNRFlgOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSgzLCA1KSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCAyKSwgMTApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSg2LCAxMCksIDEwKSxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FzZSBgRE1ZYDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXk6IHBhcnNlSW50KGRhdGUuc2xpY2UoMCwgMiksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IHBhcnNlSW50KGRhdGUuc2xpY2UoMywgNSksIDEwKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHBhcnNlSW50KGRhdGUuc2xpY2UoNiwgMTApLCAxMCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IE1vdmUgbW9udGggYW5kIHllYXIgcmVsYXRlZCBjb2RlIGNvcnJlc3BvbmRpbmcgY2xhc3Nlc1xuICAgIC8qKlxuICAgICAqIFBhcnNpbmcgYSBzdHJpbmcgd2l0aCBkYXRlIHdpdGggbm9ybWFsaXphdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHJhd0RhdGUgZGF0ZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGF0ZU1vZGUgZGF0ZSBmb3JtYXQgb2YgdGhlIGRhdGUgc3RyaW5nIChETVkgfCBNRFkgfCBZTUQpXG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplUGFyc2UocmF3RGF0ZTogc3RyaW5nLCBkYXRlTW9kZTogVHVpRGF0ZU1vZGUgPSBgRE1ZYCk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IHtkYXksIG1vbnRoLCB5ZWFyfSA9IHRoaXMucGFyc2VSYXdEYXRlU3RyaW5nKHJhd0RhdGUsIGRhdGVNb2RlKTtcblxuICAgICAgICByZXR1cm4gVHVpRGF5Lm5vcm1hbGl6ZU9mKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNpbmcgYSBkYXRlIHN0cmluZ2lmaWVkIGluIGEgdG9KU09OIGZvcm1hdFxuICAgICAqIEBwYXJhbSB5ZWFyTW9udGhEYXlTdHJpbmcgZGF0ZSBzdHJpbmcgaW4gZm9ybWF0IG9mIFlZWVktTU0tRERcbiAgICAgKiBAcmV0dXJuIGRhdGVcbiAgICAgKiBAdGhyb3dzIGV4Y2VwdGlvbnMgaWYgYW55IHBhcnQgb2YgdGhlIGRhdGUgaXMgaW52YWxpZFxuICAgICAqL1xuICAgIHN0YXRpYyBqc29uUGFyc2UoeWVhck1vbnRoRGF5U3RyaW5nOiBzdHJpbmcpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCB7ZGF5LCBtb250aCwgeWVhcn0gPSB0aGlzLnBhcnNlUmF3RGF0ZVN0cmluZyh5ZWFyTW9udGhEYXlTdHJpbmcsIGBZTURgKTtcblxuICAgICAgICBpZiAoIVR1aVllYXIuaXNWYWxpZFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWWVhckV4Y2VwdGlvbih5ZWFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNb250aEV4Y2VwdGlvbihtb250aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihkYXkpIHx8XG4gICAgICAgICAgICAhaW5SYW5nZShcbiAgICAgICAgICAgICAgICBkYXksXG4gICAgICAgICAgICAgICAgTUlOX0RBWSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aCwgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpKSArIDEsXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWREYXlFeGNlcHRpb24oZGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzdGF0aWMgbm9ybWFsaXplRGF5UGFydChkYXk6IG51bWJlciwgbW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlNb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpKTtcblxuICAgICAgICBjb25zdCBtb250aERheXNDb3VudCA9IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KFxuICAgICAgICAgICAgbW9udGgsXG4gICAgICAgICAgICBUdWlZZWFyLmlzTGVhcFllYXIoeWVhciksXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVRvSW50TnVtYmVyKGRheSwgMSwgbW9udGhEYXlzQ291bnQpO1xuICAgIH1cblxuICAgIGdldCBmb3JtYXR0ZWREYXlQYXJ0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwYWRTdGFydChTdHJpbmcodGhpcy5kYXkpLCAyLCBgMGApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgZ2V0Rm9ybWF0dGVkRGF5fSBpbnN0ZWFkXG4gICAgICogRm9ybWF0dGVkIHdob2xlIGRhdGVcbiAgICAgKi9cbiAgICBnZXQgZm9ybWF0dGVkRGF5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdHRlZERheVBhcnR9LiR7dGhpcy5mb3JtYXR0ZWRNb250aH1gO1xuICAgIH1cblxuICAgIGdldCBpc1dlZWtlbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IHRoaXMuZGF5T2ZXZWVrKGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZGF5T2ZXZWVrID09PSBUdWlEYXlPZldlZWsuU2F0dXJkYXkgfHwgZGF5T2ZXZWVrID09PSBUdWlEYXlPZldlZWsuU3VuZGF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF5IG9mIHdlZWtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydEZyb21Nb25kYXkgd2hldGhlciB3ZWVrIHN0YXJ0cyBmcm9tIE1vbmRheSBhbmQgbm90IGZyb20gU3VuZGF5XG4gICAgICogQHJldHVybiBkYXkgb2Ygd2VlayAoZnJvbSAwIHRvIDYpXG4gICAgICovXG4gICAgZGF5T2ZXZWVrKHN0YXJ0RnJvbU1vbmRheTogYm9vbGVhbiA9IHRydWUpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSBzdGFydEZyb21Nb25kYXlcbiAgICAgICAgICAgID8gdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpIC0gMVxuICAgICAgICAgICAgOiB0aGlzLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0RGF5KCk7XG5cbiAgICAgICAgcmV0dXJuIGRheU9mV2VlayA8IDAgPyA2IDogZGF5T2ZXZWVrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGFmdGVyIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlCZWZvcmUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQmVmb3JlKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPCBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBhZnRlciBvciBlcXVhbHMgdG8gY3VycmVudFxuICAgICAqL1xuICAgIGRheVNhbWVPckJlZm9yZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA8PSBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgZGF5U2FtZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID09PSBhbm90aGVyLmRheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBlaXRoZXIgYmVmb3JlIG9yIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlTYW1lT3JBZnRlcihhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhBZnRlcihhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5ID49IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGJlZm9yZSBjdXJyZW50XG4gICAgICovXG4gICAgZGF5QWZ0ZXIoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA+IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1waW5nIGRhdGUgYmV0d2VlbiB0d28gbGltaXRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluXG4gICAgICogQHBhcmFtIG1heFxuICAgICAqIEByZXR1cm4gY2xhbXBlZCBkYXRlXG4gICAgICovXG4gICAgZGF5TGltaXQobWluOiBUdWlEYXkgfCBudWxsLCBtYXg6IFR1aURheSB8IG51bGwpOiBUdWlEYXkge1xuICAgICAgICBpZiAobWluICE9PSBudWxsICYmIHRoaXMuZGF5QmVmb3JlKG1pbikpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICE9PSBudWxsICYmIHRoaXMuZGF5QWZ0ZXIobWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IDMuMCBDb25zaWRlciByZW1vdmluZyBgYmFja3dhcmRzYCBvcHRpb25cbiAgICAvKipcbiAgICAgKiBJbW11dGFibHkgYWx0ZXJzIGN1cnJlbnQgZGF5IGJ5IHBhc3NlZCBvZmZzZXRcbiAgICAgKlxuICAgICAqIElmIHJlc3VsdGluZyBtb250aCBoYXMgbW9yZSBkYXlzIHRoYW4gb3JpZ2luYWwgb25lLCBkYXRlIGlzIHJvdW5kZWQgdG8gdGhlIG1heGltdW0gZGF5XG4gICAgICogaW4gdGhlIHJlc3VsdGluZyBtb250aC4gT2Zmc2V0IG9mIGRheXMgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSByZXN1bHRlZCB5ZWFyIGFuZCBtb250aFxuICAgICAqIHRvIG5vdCBpbnRlcmZlcmUgd2l0aCBwYXJlbnQgY2xhc3NlcyBtZXRob2RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHBhcmFtIGJhY2t3YXJkcyBzaGlmdCBkYXRlIGJhY2t3YXJkc1xuICAgICAqIEByZXR1cm4gbmV3IGRhdGUgb2JqZWN0IGFzIGEgcmVzdWx0IG9mIG9mZnNldHRpbmcgY3VycmVudFxuICAgICAqL1xuICAgIGFwcGVuZChcbiAgICAgICAge3llYXIgPSAwLCBtb250aCA9IDAsIGRheSA9IDB9OiBUdWlEYXlMaWtlLFxuICAgICAgICBiYWNrd2FyZHM6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICApOiBUdWlEYXkge1xuICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICB5ZWFyICo9IC0xO1xuICAgICAgICAgICAgbW9udGggKj0gLTE7XG4gICAgICAgICAgICBkYXkgKj0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3RhbE1vbnRocyA9ICh0aGlzLnllYXIgKyB5ZWFyKSAqIE1PTlRIU19JTl9ZRUFSICsgdGhpcy5tb250aCArIG1vbnRoO1xuICAgICAgICBsZXQgeWVhcnMgPSBNYXRoLmZsb29yKHRvdGFsTW9udGhzIC8gTU9OVEhTX0lOX1lFQVIpO1xuICAgICAgICBsZXQgbW9udGhzID0gdG90YWxNb250aHMgJSBNT05USFNfSU5fWUVBUjtcblxuICAgICAgICBsZXQgZGF5cyA9XG4gICAgICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpLFxuICAgICAgICAgICAgKSArIGRheTtcblxuICAgICAgICB3aGlsZSAoZGF5cyA+IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSkpIHtcbiAgICAgICAgICAgIGRheXMgLT0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcblxuICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gVHVpTW9udGhOdW1iZXIuRGVjZW1iZXIpIHtcbiAgICAgICAgICAgICAgICB5ZWFycysrO1xuICAgICAgICAgICAgICAgIG1vbnRocyA9IFR1aU1vbnRoTnVtYmVyLkphbnVhcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRocysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRheXMgPCBNSU5fREFZKSB7XG4gICAgICAgICAgICBpZiAobW9udGhzID09PSBUdWlNb250aE51bWJlci5KYW51YXJ5KSB7XG4gICAgICAgICAgICAgICAgeWVhcnMtLTtcbiAgICAgICAgICAgICAgICBtb250aHMgPSBUdWlNb250aE51bWJlci5EZWNlbWJlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhzLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRheXMgKz0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXJzLCBtb250aHMsIGRheXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZm9ybWF0dGVkIHdob2xlIGRhdGVcbiAgICAgKi9cbiAgICBnZXRGb3JtYXR0ZWREYXkoZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUsIHNlcGFyYXRvcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChcbiAgICAgICAgICAgIHNlcGFyYXRvci5sZW5ndGggPT09IDEsXG4gICAgICAgICAgICBgU2VwYXJhdG9yIHNob3VsZCBjb25zaXN0IG9mIG9ubHkgMSBzeW1ib2xgLFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGRkID0gdGhpcy5mb3JtYXR0ZWREYXlQYXJ0O1xuICAgICAgICBjb25zdCBtbSA9IHRoaXMuZm9ybWF0dGVkTW9udGhQYXJ0O1xuICAgICAgICBjb25zdCB5eXl5ID0gdGhpcy5mb3JtYXR0ZWRZZWFyO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0ZUZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBgWU1EYDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7eXl5eX0ke3NlcGFyYXRvcn0ke21tfSR7c2VwYXJhdG9yfSR7ZGR9YDtcbiAgICAgICAgICAgIGNhc2UgYE1EWWA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke21tfSR7c2VwYXJhdG9yfSR7ZGR9JHtzZXBhcmF0b3J9JHt5eXl5fWA7XG4gICAgICAgICAgICBjYXNlIGBETVlgOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGR9JHtzZXBhcmF0b3J9JHttbX0ke3NlcGFyYXRvcn0ke3l5eXl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKGRhdGVGb3JtYXQ6IFR1aURhdGVNb2RlID0gYERNWWAsIHNlcGFyYXRvcjogc3RyaW5nID0gYC5gKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci50b0pTT04oKX0tJHt0aGlzLmZvcm1hdHRlZERheVBhcnR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgdG9Mb2NhbE5hdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gVVRDXG4gICAgICovXG4gICAgdG9VdGNOYXRpdmVEYXRlKCk6IERhdGUge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEModGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSkpO1xuICAgIH1cbn1cbiJdfQ==