import { __decorate, __extends, __param } from "tslib";
import { ChangeDetectorRef, Directive, Inject, TemplateRef } from '@angular/core';
import { PolymorpheusTemplate } from '@tinkoff/ng-polymorpheus';
import { EMPTY, Subject } from 'rxjs';
import { endWith, ignoreElements, switchMap } from 'rxjs/operators';
import { AbstractTuiDialogService } from './dialog.service';
var AbstractTuiDialogDirective = /** @class */ (function (_super) {
    __extends(AbstractTuiDialogDirective, _super);
    function AbstractTuiDialogDirective(templateRef, changeDetectorRef, service) {
        var _this = _super.call(this, templateRef, changeDetectorRef) || this;
        _this.service = service;
        _this.open$ = new Subject();
        _this.options = {};
        _this.openChange = _this.open$.pipe(switchMap(function (open) {
            return open
                ? _this.service
                    .open(_this, _this.options)
                    .pipe(ignoreElements(), endWith(false))
                : EMPTY;
        }));
        return _this;
    }
    Object.defineProperty(AbstractTuiDialogDirective.prototype, "open", {
        set: function (open) {
            this.open$.next(open);
        },
        enumerable: true,
        configurable: true
    });
    AbstractTuiDialogDirective.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Inject, args: [TemplateRef,] }] },
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: AbstractTuiDialogService, decorators: [{ type: Inject, args: [AbstractTuiDialogService,] }] }
    ]; };
    AbstractTuiDialogDirective = __decorate([
        Directive(),
        __param(0, Inject(TemplateRef)),
        __param(1, Inject(ChangeDetectorRef)),
        __param(2, Inject(AbstractTuiDialogService))
    ], AbstractTuiDialogDirective);
    return AbstractTuiDialogDirective;
}(PolymorpheusTemplate));
export { AbstractTuiDialogDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvYWJzdHJhY3QvIiwic291cmNlcyI6WyJkaWFsb2cuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFaEYsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDOUQsT0FBTyxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFDLE9BQU8sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFbEUsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFHMUQ7SUFBNEQsOENBRTNEO0lBbUJHLG9DQUVJLFdBQTRDLEVBQ2pCLGlCQUFvQyxFQUU5QyxPQUFvQztRQUx6RCxZQU9JLGtCQUFNLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxTQUN4QztRQUhvQixhQUFPLEdBQVAsT0FBTyxDQUE2QjtRQXZCeEMsV0FBSyxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFFaEQsYUFBTyxHQUFlLEVBQUUsQ0FBQztRQU16QixnQkFBVSxHQUFHLEtBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN4QixTQUFTLENBQUMsVUFBQSxJQUFJO1lBQ1YsT0FBQSxJQUFJO2dCQUNBLENBQUMsQ0FBQyxLQUFJLENBQUMsT0FBTztxQkFDUCxJQUFJLENBQUMsS0FBSSxFQUFFLEtBQUksQ0FBQyxPQUFPLENBQUM7cUJBQ3hCLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzdDLENBQUMsQ0FBQyxLQUFLO1FBSlgsQ0FJVyxDQUNkLENBQ0osQ0FBQzs7SUFVRixDQUFDO0lBdEJELHNCQUFJLDRDQUFJO2FBQVIsVUFBUyxJQUFhO1lBQ2xCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFCLENBQUM7OztPQUFBOztnQkFjZ0IsV0FBVyx1QkFEdkIsTUFBTSxTQUFDLFdBQVc7Z0JBRTJCLGlCQUFpQix1QkFBOUQsTUFBTSxTQUFDLGlCQUFpQjtnQkFFQyx3QkFBd0IsdUJBRGpELE1BQU0sU0FBQyx3QkFBd0I7O0lBekJsQiwwQkFBMEI7UUFEL0MsU0FBUyxFQUFFO1FBdUJILFdBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO1FBRW5CLFdBQUEsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUE7UUFDekIsV0FBQSxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FBQTtPQXpCbkIsMEJBQTBCLENBOEIvQztJQUFELGlDQUFDO0NBQUEsQUE5QkQsQ0FBNEQsb0JBQW9CLEdBOEIvRTtTQTlCcUIsMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBJbmplY3QsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7VHVpRGlhbG9nfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3R5cGVzJztcbmltcG9ydCB7UG9seW1vcnBoZXVzVGVtcGxhdGV9IGZyb20gJ0B0aW5rb2ZmL25nLXBvbHltb3JwaGV1cyc7XG5pbXBvcnQge0VNUFRZLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZW5kV2l0aCwgaWdub3JlRWxlbWVudHMsIHN3aXRjaE1hcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge0Fic3RyYWN0VHVpRGlhbG9nU2VydmljZX0gZnJvbSAnLi9kaWFsb2cuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0VHVpRGlhbG9nRGlyZWN0aXZlPFQ+IGV4dGVuZHMgUG9seW1vcnBoZXVzVGVtcGxhdGU8XG4gICAgVHVpRGlhbG9nPFQsIHZvaWQ+XG4+IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wZW4kID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIG9wdGlvbnM6IFBhcnRpYWw8VD4gPSB7fTtcblxuICAgIHNldCBvcGVuKG9wZW46IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KG9wZW4pO1xuICAgIH1cblxuICAgIG9wZW5DaGFuZ2UgPSB0aGlzLm9wZW4kLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcChvcGVuID0+XG4gICAgICAgICAgICBvcGVuXG4gICAgICAgICAgICAgICAgPyB0aGlzLnNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAub3Blbih0aGlzLCB0aGlzLm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgLnBpcGUoaWdub3JlRWxlbWVudHMoKSwgZW5kV2l0aChmYWxzZSkpXG4gICAgICAgICAgICAgICAgOiBFTVBUWSxcbiAgICAgICAgKSxcbiAgICApO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoVGVtcGxhdGVSZWYpXG4gICAgICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxUdWlEaWFsb2c8VCwgdm9pZD4+LFxuICAgICAgICBASW5qZWN0KENoYW5nZURldGVjdG9yUmVmKSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoQWJzdHJhY3RUdWlEaWFsb2dTZXJ2aWNlKVxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2U6IEFic3RyYWN0VHVpRGlhbG9nU2VydmljZTxUPixcbiAgICApIHtcbiAgICAgICAgc3VwZXIodGVtcGxhdGVSZWYsIGNoYW5nZURldGVjdG9yUmVmKTtcbiAgICB9XG59XG4iXX0=