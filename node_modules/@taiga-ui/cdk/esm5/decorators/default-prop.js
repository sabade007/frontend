import { __read, __spread } from "tslib";
import { tuiAssert } from '@taiga-ui/cdk/classes';
/**
 * Decorator for checking input values for undefined. You can also pass
 * optional assertion to check input against.
 *
 * CAUTION: This decorator overwrites other getters and setters.
 */
export function tuiDefaultProp(assertion) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return function (target, key) {
        var name = target.constructor.name;
        var errorGetDefaultMessage = errorGetDefault(key, name);
        var errorSetDefaultMessage = errorSetDefault(key, name);
        Object.defineProperty(target, key, {
            configurable: true,
            get: function () {
                tuiAssert.assert(false, errorGetDefaultMessage);
                return undefined;
            },
            set: function (initialValue) {
                var isValid = initialValue !== undefined;
                var errorMessage = errorSetDefaultInitial(key, name);
                var currentValue = initialValue;
                tuiAssert.assert(isValid, errorMessage);
                if (isValid && assertion) {
                    tuiAssert.assert.apply(tuiAssert, __spread([assertion.call(this, initialValue),
                        String(key) + " in " + name + " received:",
                        initialValue], args));
                }
                Object.defineProperty(this, key, {
                    configurable: true,
                    get: function () {
                        return currentValue;
                    },
                    set: function (value) {
                        var isValid = value !== undefined;
                        var backupValue = initialValue;
                        tuiAssert.assert(isValid, errorSetDefaultMessage, String(backupValue));
                        if (isValid && assertion) {
                            tuiAssert.assert.apply(tuiAssert, __spread([assertion.call(this, value),
                                String(key) + " in " + name + " received:",
                                value], args));
                        }
                        currentValue = isValid ? value : backupValue;
                    },
                });
            },
        });
    };
}
function errorGetDefault(key, component) {
    return "Default value for " + String(key) + " was not provided in " + component + ", error in Taiga UI Angular Kit";
}
function errorSetDefault(key, component) {
    return "Undefined was passed as " + String(key) + " to " + component + ", which is invalid input, using default value:";
}
function errorSetDefaultInitial(key, component) {
    return "Undefined was passed as default value for " + String(key) + " to " + component + ", error in Taiga UI Angular Kit";
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1wcm9wLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kZWNvcmF0b3JzLyIsInNvdXJjZXMiOlsiZGVmYXVsdC1wcm9wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHaEQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsY0FBYyxDQUMxQixTQUFtQztJQUNuQyxjQUFrQjtTQUFsQixVQUFrQixFQUFsQixxQkFBa0IsRUFBbEIsSUFBa0I7UUFBbEIsNkJBQWtCOztJQUVsQixPQUFPLFVBQUMsTUFBTSxFQUFFLEdBQUc7UUFDUixJQUFBLDhCQUFJLENBQXVCO1FBQ2xDLElBQU0sc0JBQXNCLEdBQUcsZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMxRCxJQUFNLHNCQUFzQixHQUFHLGVBQWUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFMUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQy9CLFlBQVksRUFBRSxJQUFJO1lBQ2xCLEdBQUcsRUFBSDtnQkFDSSxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO2dCQUVoRCxPQUFPLFNBQVMsQ0FBQztZQUNyQixDQUFDO1lBQ0QsR0FBRyxFQUFILFVBQWEsWUFBa0I7Z0JBQzNCLElBQU0sT0FBTyxHQUFHLFlBQVksS0FBSyxTQUFTLENBQUM7Z0JBQzNDLElBQU0sWUFBWSxHQUFHLHNCQUFzQixDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDdkQsSUFBSSxZQUFZLEdBQUcsWUFBWSxDQUFDO2dCQUVoQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFFeEMsSUFBSSxPQUFPLElBQUksU0FBUyxFQUFFO29CQUN0QixTQUFTLENBQUMsTUFBTSxPQUFoQixTQUFTLFlBQ0wsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDO3dCQUMvQixNQUFNLENBQUMsR0FBRyxDQUFDLFlBQU8sSUFBSSxlQUFZO3dCQUNyQyxZQUFZLEdBQ1QsSUFBSSxHQUNUO2lCQUNMO2dCQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTtvQkFDN0IsWUFBWSxFQUFFLElBQUk7b0JBQ2xCLEdBQUcsRUFBSDt3QkFDSSxPQUFPLFlBQVksQ0FBQztvQkFDeEIsQ0FBQztvQkFDRCxHQUFHLEVBQUgsVUFBYSxLQUFXO3dCQUNwQixJQUFNLE9BQU8sR0FBRyxLQUFLLEtBQUssU0FBUyxDQUFDO3dCQUNwQyxJQUFNLFdBQVcsR0FBRyxZQUFZLENBQUM7d0JBRWpDLFNBQVMsQ0FBQyxNQUFNLENBQ1osT0FBTyxFQUNQLHNCQUFzQixFQUN0QixNQUFNLENBQUMsV0FBVyxDQUFDLENBQ3RCLENBQUM7d0JBRUYsSUFBSSxPQUFPLElBQUksU0FBUyxFQUFFOzRCQUN0QixTQUFTLENBQUMsTUFBTSxPQUFoQixTQUFTLFlBQ0wsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDO2dDQUN4QixNQUFNLENBQUMsR0FBRyxDQUFDLFlBQU8sSUFBSSxlQUFZO2dDQUNyQyxLQUFLLEdBQ0YsSUFBSSxHQUNUO3lCQUNMO3dCQUVELFlBQVksR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO29CQUNqRCxDQUFDO2lCQUNKLENBQUMsQ0FBQztZQUNQLENBQUM7U0FDSixDQUFDLENBQUM7SUFDUCxDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxlQUFlLENBQUMsR0FBb0IsRUFBRSxTQUFpQjtJQUM1RCxPQUFPLHVCQUFxQixNQUFNLENBQzlCLEdBQUcsQ0FDTiw2QkFBd0IsU0FBUyxvQ0FBaUMsQ0FBQztBQUN4RSxDQUFDO0FBRUQsU0FBUyxlQUFlLENBQUMsR0FBb0IsRUFBRSxTQUFpQjtJQUM1RCxPQUFPLDZCQUEyQixNQUFNLENBQ3BDLEdBQUcsQ0FDTixZQUFPLFNBQVMsbURBQWdELENBQUM7QUFDdEUsQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQUMsR0FBb0IsRUFBRSxTQUFpQjtJQUNuRSxPQUFPLCtDQUE2QyxNQUFNLENBQ3RELEdBQUcsQ0FDTixZQUFPLFNBQVMsb0NBQWlDLENBQUM7QUFDdkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dHVpQXNzZXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NsYXNzZXMnO1xuaW1wb3J0IHtUdWlCb29sZWFuSGFuZGxlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay90eXBlcyc7XG5cbi8qKlxuICogRGVjb3JhdG9yIGZvciBjaGVja2luZyBpbnB1dCB2YWx1ZXMgZm9yIHVuZGVmaW5lZC4gWW91IGNhbiBhbHNvIHBhc3NcbiAqIG9wdGlvbmFsIGFzc2VydGlvbiB0byBjaGVjayBpbnB1dCBhZ2FpbnN0LlxuICpcbiAqIENBVVRJT046IFRoaXMgZGVjb3JhdG9yIG92ZXJ3cml0ZXMgb3RoZXIgZ2V0dGVycyBhbmQgc2V0dGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1aURlZmF1bHRQcm9wPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBLIGV4dGVuZHMga2V5b2YgVD4oXG4gICAgYXNzZXJ0aW9uPzogVHVpQm9vbGVhbkhhbmRsZXI8VFtLXT4sXG4gICAgLi4uYXJnczogdW5rbm93bltdXG4pOiBQcm9wZXJ0eURlY29yYXRvciB7XG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB7bmFtZX0gPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGVycm9yR2V0RGVmYXVsdE1lc3NhZ2UgPSBlcnJvckdldERlZmF1bHQoa2V5LCBuYW1lKTtcbiAgICAgICAgY29uc3QgZXJyb3JTZXREZWZhdWx0TWVzc2FnZSA9IGVycm9yU2V0RGVmYXVsdChrZXksIG5hbWUpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0KCk6IHVuZGVmaW5lZCB7XG4gICAgICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChmYWxzZSwgZXJyb3JHZXREZWZhdWx0TWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh0aGlzOiBULCBpbml0aWFsVmFsdWU6IFRbS10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JTZXREZWZhdWx0SW5pdGlhbChrZXksIG5hbWUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cbiAgICAgICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KGlzVmFsaWQsIGVycm9yTWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCAmJiBhc3NlcnRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydGlvbi5jYWxsKHRoaXMsIGluaXRpYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtTdHJpbmcoa2V5KX0gaW4gJHtuYW1lfSByZWNlaXZlZDpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCk6IFRbS10ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0KHRoaXM6IFQsIHZhbHVlOiBUW0tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2t1cFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTZXREZWZhdWx0TWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcoYmFja3VwVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgYXNzZXJ0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0aW9uLmNhbGwodGhpcywgdmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtTdHJpbmcoa2V5KX0gaW4gJHtuYW1lfSByZWNlaXZlZDpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpc1ZhbGlkID8gdmFsdWUgOiBiYWNrdXBWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGVycm9yR2V0RGVmYXVsdChrZXk6IHN0cmluZyB8IHN5bWJvbCwgY29tcG9uZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgRGVmYXVsdCB2YWx1ZSBmb3IgJHtTdHJpbmcoXG4gICAgICAgIGtleSxcbiAgICApfSB3YXMgbm90IHByb3ZpZGVkIGluICR7Y29tcG9uZW50fSwgZXJyb3IgaW4gVGFpZ2EgVUkgQW5ndWxhciBLaXRgO1xufVxuXG5mdW5jdGlvbiBlcnJvclNldERlZmF1bHQoa2V5OiBzdHJpbmcgfCBzeW1ib2wsIGNvbXBvbmVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFVuZGVmaW5lZCB3YXMgcGFzc2VkIGFzICR7U3RyaW5nKFxuICAgICAgICBrZXksXG4gICAgKX0gdG8gJHtjb21wb25lbnR9LCB3aGljaCBpcyBpbnZhbGlkIGlucHV0LCB1c2luZyBkZWZhdWx0IHZhbHVlOmA7XG59XG5cbmZ1bmN0aW9uIGVycm9yU2V0RGVmYXVsdEluaXRpYWwoa2V5OiBzdHJpbmcgfCBzeW1ib2wsIGNvbXBvbmVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFVuZGVmaW5lZCB3YXMgcGFzc2VkIGFzIGRlZmF1bHQgdmFsdWUgZm9yICR7U3RyaW5nKFxuICAgICAgICBrZXksXG4gICAgKX0gdG8gJHtjb21wb25lbnR9LCBlcnJvciBpbiBUYWlnYSBVSSBBbmd1bGFyIEtpdGA7XG59XG4iXX0=