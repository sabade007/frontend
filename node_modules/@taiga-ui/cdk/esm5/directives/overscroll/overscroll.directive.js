import { __decorate, __param } from "tslib";
import { Directive, ElementRef, HostBinding, Inject, Input, NgZone } from '@angular/core';
import { tuiZonefree, typedFromEvent } from '@taiga-ui/cdk/observables';
import { TuiDestroyService } from '@taiga-ui/cdk/services';
import { canScroll, getScrollParent } from '@taiga-ui/cdk/utils/dom';
import { Observable } from 'rxjs';
import { filter, switchMap, takeUntil, tap } from 'rxjs/operators';
/**
 * Directive to isolate scrolling, i.e. prevent body scroll behind modal dialog
 * @dynamic
 */
var TuiOverscrollDirective = /** @class */ (function () {
    function TuiOverscrollDirective(_a, ngZone, destroy$) {
        var _this = this;
        var nativeElement = _a.nativeElement;
        this.mode = 'scroll';
        typedFromEvent(nativeElement, 'wheel', { passive: false })
            .pipe(filter(function () { return _this.enabled; }), tuiZonefree(ngZone), takeUntil(destroy$))
            .subscribe(function (event) {
            _this.processEvent(event, !!event.deltaY, event.deltaY ? event.deltaY < 0 : event.deltaX < 0);
        });
        typedFromEvent(nativeElement, 'touchstart', { passive: true })
            .pipe(switchMap(function (_a) {
            var touches = _a.touches;
            var _b = touches[0], clientX = _b.clientX, clientY = _b.clientY;
            var deltaX = 0;
            var deltaY = 0;
            var vertical;
            return typedFromEvent(nativeElement, 'touchmove', {
                passive: false,
            }).pipe(filter(function () { return _this.enabled; }), tap(function (event) {
                // We have to have it in tap instead of subscribe due to variables in closure
                var changedTouch = event.changedTouches[0];
                deltaX = clientX - changedTouch.clientX;
                deltaY = clientY - changedTouch.clientY;
                clientX = changedTouch.clientX;
                clientY = changedTouch.clientY;
                if (vertical === undefined) {
                    vertical = Math.abs(deltaY) > Math.abs(deltaX);
                }
                _this.processEvent(event, vertical, vertical ? deltaY < 0 : deltaX < 0);
            }));
        }), tuiZonefree(ngZone), takeUntil(destroy$))
            .subscribe();
    }
    Object.defineProperty(TuiOverscrollDirective.prototype, "enabled", {
        get: function () {
            return this.mode !== 'none';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiOverscrollDirective.prototype, "overscrollBehavior", {
        get: function () {
            return this.enabled ? 'contain' : null;
        },
        enumerable: true,
        configurable: true
    });
    TuiOverscrollDirective.prototype.processEvent = function (event, vertical, negative) {
        var _a;
        var target = event.target, currentTarget = event.currentTarget, cancelable = event.cancelable;
        // TODO: iframe warning
        if (!cancelable ||
            !(target instanceof Element) ||
            ((_a = target) === null || _a === void 0 ? void 0 : _a.type) === 'range') {
            return;
        }
        // This is all what's needed in Chrome/Firefox thanks to CSS overscroll-behavior
        if (this.mode === 'all' &&
            ((vertical && !currentTarget.contains(getScrollParent(target))) ||
                (!vertical && !currentTarget.contains(getScrollParent(target, false))))) {
            event.preventDefault();
            return;
        }
        // This is Safari/IE/Edge fallback
        if (vertical &&
            ((negative && !canScroll(target, currentTarget, true, false)) ||
                (!negative && !canScroll(target, currentTarget, true, true)))) {
            event.preventDefault();
            return;
        }
        if (!vertical &&
            ((negative && !canScroll(target, currentTarget, false, false)) ||
                (!negative && !canScroll(target, currentTarget, false, true)))) {
            event.preventDefault();
        }
    };
    TuiOverscrollDirective.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
    ]; };
    __decorate([
        Input('tuiOverscroll')
    ], TuiOverscrollDirective.prototype, "mode", void 0);
    __decorate([
        HostBinding('style.overscrollBehavior')
    ], TuiOverscrollDirective.prototype, "overscrollBehavior", null);
    TuiOverscrollDirective = __decorate([
        Directive({
            selector: '[tuiOverscroll]',
            providers: [TuiDestroyService],
        }),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(NgZone)),
        __param(2, Inject(TuiDestroyService))
    ], TuiOverscrollDirective);
    return TuiOverscrollDirective;
}());
export { TuiOverscrollDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcnNjcm9sbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkvY2RrL2RpcmVjdGl2ZXMvb3ZlcnNjcm9sbC8iLCJzb3VyY2VzIjpbIm92ZXJzY3JvbGwuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDeEYsT0FBTyxFQUFDLFdBQVcsRUFBRSxjQUFjLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUN0RSxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUV6RCxPQUFPLEVBQUMsU0FBUyxFQUFFLGVBQWUsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ25FLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDaEMsT0FBTyxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRWpFOzs7R0FHRztBQUtIO0lBSUksZ0NBQ3dCLEVBQXdDLEVBQzVDLE1BQWMsRUFDSCxRQUEwQjtRQUh6RCxpQkF3REM7WUF2RHdCLGdDQUFhO1FBSHRDLFNBQUksR0FBNEIsUUFBUSxDQUFDO1FBT3JDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsT0FBTyxFQUFFLEVBQUMsT0FBTyxFQUFFLEtBQUssRUFBQyxDQUFDO2FBQ25ELElBQUksQ0FDRCxNQUFNLENBQUMsY0FBTSxPQUFBLEtBQUksQ0FBQyxPQUFPLEVBQVosQ0FBWSxDQUFDLEVBQzFCLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFDbkIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUN0QjthQUNBLFNBQVMsQ0FBQyxVQUFBLEtBQUs7WUFDWixLQUFJLENBQUMsWUFBWSxDQUNiLEtBQUssRUFDTCxDQUFDLENBQUMsS0FBSyxDQUFD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QyxDQUFBO1FBQ2QsV0FBQSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtPQVByQixzQkFBc0IsQ0FxSGxDO0lBQUQsNkJBQUM7Q0FBQSxBQXJIRCxJQXFIQztTQXJIWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE5nWm9uZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3R1aVpvbmVmcmVlLCB0eXBlZEZyb21FdmVudH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9vYnNlcnZhYmxlcyc7XG5pbXBvcnQge1R1aURlc3Ryb3lTZXJ2aWNlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3NlcnZpY2VzJztcbmltcG9ydCB7VHVpRXZlbnRXaXRoLCBUdWlPdmVyc2Nyb2xsTW9kZVR9IGZyb20gJ0B0YWlnYS11aS9jZGsvdHlwZXMnO1xuaW1wb3J0IHtjYW5TY3JvbGwsIGdldFNjcm9sbFBhcmVudH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9kb20nO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZmlsdGVyLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCwgdGFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGlzb2xhdGUgc2Nyb2xsaW5nLCBpLmUuIHByZXZlbnQgYm9keSBzY3JvbGwgYmVoaW5kIG1vZGFsIGRpYWxvZ1xuICogQGR5bmFtaWNcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdHVpT3ZlcnNjcm9sbF0nLFxuICAgIHByb3ZpZGVyczogW1R1aURlc3Ryb3lTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHVpT3ZlcnNjcm9sbERpcmVjdGl2ZSB7XG4gICAgQElucHV0KCd0dWlPdmVyc2Nyb2xsJylcbiAgICBtb2RlOiBUdWlPdmVyc2Nyb2xsTW9kZVQgfCAnJyA9ICdzY3JvbGwnO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoRWxlbWVudFJlZikge25hdGl2ZUVsZW1lbnR9OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgQEluamVjdChOZ1pvbmUpIG5nWm9uZTogTmdab25lLFxuICAgICAgICBASW5qZWN0KFR1aURlc3Ryb3lTZXJ2aWNlKSBkZXN0cm95JDogT2JzZXJ2YWJsZTx2b2lkPixcbiAgICApIHtcbiAgICAgICAgdHlwZWRGcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ3doZWVsJywge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLmVuYWJsZWQpLFxuICAgICAgICAgICAgICAgIHR1aVpvbmVmcmVlKG5nWm9uZSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKGRlc3Ryb3kkKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgISFldmVudC5kZWx0YVksXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlbHRhWSA/IGV2ZW50LmRlbHRhWSA8IDAgOiBldmVudC5kZWx0YVggPCAwLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0eXBlZEZyb21FdmVudChuYXRpdmVFbGVtZW50LCAndG91Y2hzdGFydCcsIHtwYXNzaXZlOiB0cnVlfSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIHN3aXRjaE1hcCgoe3RvdWNoZXN9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSB0b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2ZXJ0aWNhbDogYm9vbGVhbjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRGcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ3RvdWNobW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuZW5hYmxlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gaGF2ZSBpdCBpbiB0YXAgaW5zdGVhZCBvZiBzdWJzY3JpYmUgZHVlIHRvIHZhcmlhYmxlcyBpbiBjbG9zdXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZFRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVggPSBjbGllbnRYIC0gY2hhbmdlZFRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gY2xpZW50WSAtIGNoYW5nZWRUb3VjaC5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFggPSBjaGFuZ2VkVG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZID0gY2hhbmdlZFRvdWNoLmNsaWVudFk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGljYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbCA9IE1hdGguYWJzKGRlbHRhWSkgPiBNYXRoLmFicyhkZWx0YVgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsID8gZGVsdGFZIDwgMCA6IGRlbHRhWCA8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHR1aVpvbmVmcmVlKG5nWm9uZSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKGRlc3Ryb3kkKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBnZXQgZW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSAhPT0gJ25vbmUnO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3ZlcnNjcm9sbEJlaGF2aW9yJylcbiAgICBnZXQgb3ZlcnNjcm9sbEJlaGF2aW9yKCk6ICdjb250YWluJyB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkID8gJ2NvbnRhaW4nIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByb2Nlc3NFdmVudChcbiAgICAgICAgZXZlbnQ6IFR1aUV2ZW50V2l0aDxFdmVudCwgSFRNTEVsZW1lbnQ+LFxuICAgICAgICB2ZXJ0aWNhbDogYm9vbGVhbixcbiAgICAgICAgbmVnYXRpdmU6IGJvb2xlYW4sXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHt0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIGNhbmNlbGFibGV9ID0gZXZlbnQ7XG5cbiAgICAgICAgLy8gVE9ETzogaWZyYW1lIHdhcm5pbmdcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWNhbmNlbGFibGUgfHxcbiAgICAgICAgICAgICEodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkgfHxcbiAgICAgICAgICAgICh0YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCk/LnR5cGUgPT09ICdyYW5nZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGFsbCB3aGF0J3MgbmVlZGVkIGluIENocm9tZS9GaXJlZm94IHRoYW5rcyB0byBDU1Mgb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLm1vZGUgPT09ICdhbGwnICYmXG4gICAgICAgICAgICAoKHZlcnRpY2FsICYmICFjdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGdldFNjcm9sbFBhcmVudCh0YXJnZXQpKSkgfHxcbiAgICAgICAgICAgICAgICAoIXZlcnRpY2FsICYmICFjdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGdldFNjcm9sbFBhcmVudCh0YXJnZXQsIGZhbHNlKSkpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgU2FmYXJpL0lFL0VkZ2UgZmFsbGJhY2tcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdmVydGljYWwgJiZcbiAgICAgICAgICAgICgobmVnYXRpdmUgJiYgIWNhblNjcm9sbCh0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIHRydWUsIGZhbHNlKSkgfHxcbiAgICAgICAgICAgICAgICAoIW5lZ2F0aXZlICYmICFjYW5TY3JvbGwodGFyZ2V0LCBjdXJyZW50VGFyZ2V0LCB0cnVlLCB0cnVlKSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXZlcnRpY2FsICYmXG4gICAgICAgICAgICAoKG5lZ2F0aXZlICYmICFjYW5TY3JvbGwodGFyZ2V0LCBjdXJyZW50VGFyZ2V0LCBmYWxzZSwgZmFsc2UpKSB8fFxuICAgICAgICAgICAgICAgICghbmVnYXRpdmUgJiYgIWNhblNjcm9sbCh0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIGZhbHNlLCB0cnVlKSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==