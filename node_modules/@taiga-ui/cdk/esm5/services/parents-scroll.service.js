import { __decorate, __extends, __param, __read, __spread } from "tslib";
import { ElementRef, Inject, Injectable } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { typedFromEvent } from '@taiga-ui/cdk/observables';
import { defer, merge, Observable } from 'rxjs';
/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiParentsScrollService = /** @class */ (function (_super) {
    __extends(TuiParentsScrollService, _super);
    function TuiParentsScrollService(elementRef, windowRef) {
        var _this = _super.call(this, function (subscriber) { return _this.callback$.subscribe(subscriber); }) || this;
        _this.callback$ = defer(function () {
            var nativeElement = elementRef.nativeElement;
            var eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge.apply(void 0, __spread(eventTargets.map(function (element) {
                return typedFromEvent(element, "scroll");
            })));
        });
        return _this;
    }
    TuiParentsScrollService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    TuiParentsScrollService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(WINDOW))
    ], TuiParentsScrollService);
    return TuiParentsScrollService;
}(Observable));
export { TuiParentsScrollService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyZW50cy1zY3JvbGwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvc2VydmljZXMvIiwic291cmNlcyI6WyJwYXJlbnRzLXNjcm9sbC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFOUM7O0dBRUc7QUFDSCw4RkFBOEY7QUFDOUYsV0FBVztBQUVYO0lBQTZDLDJDQUFpQjtJQUcxRCxpQ0FDd0IsVUFBK0IsRUFDbkMsU0FBaUI7UUFGckMsWUFJSSxrQkFBTSxVQUFBLFVBQVUsSUFBSSxPQUFBLEtBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFwQyxDQUFvQyxDQUFDLFNBaUI1RDtRQWZHLEtBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1lBQ2QsSUFBQSx3Q0FBYSxDQUFlO1lBQ2pDLElBQU0sWUFBWSxHQUE0QixDQUFDLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUV6RSxPQUFPLGFBQWEsQ0FBQyxhQUFhLEVBQUU7Z0JBQ2hDLGFBQWEsR0FBRyxhQUFhLENBQUMsYUFBYSxDQUFDO2dCQUM1QyxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3BDO1lBRUQsT0FBTyxLQUFLLHdCQUNMLFlBQVksQ0FBQyxHQUFHLENBQW9CLFVBQUEsT0FBTztnQkFDMUMsT0FBQSxjQUFjLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQztZQUFqQyxDQUFpQyxDQUNwQyxHQUNIO1FBQ04sQ0FBQyxDQUFDLENBQUM7O0lBQ1AsQ0FBQzs7Z0JBcEJtQyxVQUFVLHVCQUF6QyxNQUFNLFNBQUMsVUFBVTtnQkFDUyxNQUFNLHVCQUFoQyxNQUFNLFNBQUMsTUFBTTs7SUFMVCx1QkFBdUI7UUFEbkMsVUFBVSxFQUFFO1FBS0osV0FBQSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDbEIsV0FBQSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7T0FMVix1QkFBdUIsQ0F5Qm5DO0lBQUQsOEJBQUM7Q0FBQSxBQXpCRCxDQUE2QyxVQUFVLEdBeUJ0RDtTQXpCWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0VsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1dJTkRPV30gZnJvbSAnQG5nLXdlYi1hcGlzL2NvbW1vbic7XG5pbXBvcnQge3R5cGVkRnJvbUV2ZW50fSBmcm9tICdAdGFpZ2EtdWkvY2RrL29ic2VydmFibGVzJztcbmltcG9ydCB7ZGVmZXIsIG1lcmdlLCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcblxuLyoqXG4gKiBTZXJ2aWNlIHRoYXQgc3Vic2NyaWJlcyB0byBzY3JvbGwgZXZlbnRzIG9mIGFsbCBwYXJlbnQgZWxlbWVudHNcbiAqL1xuLy8gQW1iaWVudCB0eXBlIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgZHluYW1pYyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMzM5NVxuLy8gQGR5bmFtaWNcbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUdWlQYXJlbnRzU2Nyb2xsU2VydmljZSBleHRlbmRzIE9ic2VydmFibGU8RXZlbnQ+IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhbGxiYWNrJDogT2JzZXJ2YWJsZTxFdmVudD47XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChFbGVtZW50UmVmKSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KFdJTkRPVykgd2luZG93UmVmOiBXaW5kb3csXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHN1YnNjcmliZXIgPT4gdGhpcy5jYWxsYmFjayQuc3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcblxuICAgICAgICB0aGlzLmNhbGxiYWNrJCA9IGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB7bmF0aXZlRWxlbWVudH0gPSBlbGVtZW50UmVmO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUYXJnZXRzOiBBcnJheTxFbGVtZW50IHwgV2luZG93PiA9IFt3aW5kb3dSZWYsIG5hdGl2ZUVsZW1lbnRdO1xuXG4gICAgICAgICAgICB3aGlsZSAobmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldHMucHVzaChuYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlPEV2ZW50PihcbiAgICAgICAgICAgICAgICAuLi5ldmVudFRhcmdldHMubWFwPE9ic2VydmFibGU8RXZlbnQ+PihlbGVtZW50ID0+XG4gICAgICAgICAgICAgICAgICAgIHR5cGVkRnJvbUV2ZW50KGVsZW1lbnQsIGBzY3JvbGxgKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19