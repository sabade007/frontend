import { svgNodeFilter } from '@taiga-ui/cdk/constants';
import { isNativeKeyboardFocusable } from './is-native-keyboard-focusable';
import { isNativeMouseFocusable } from './is-native-mouse-focusable';
/**
 * @deprecated: use {@link tuiGetClosestFocusable} instead
 * Finds the closest element that can be focused with a keyboard or mouse in theory
 *
 * @param initial current HTML element
 * @param prev should it look backwards instead (find item that will be focused with Shift + Tab)
 * @param root top Node limiting the search area
 * @param keyboard determine if only keyboard focus is of interest
 *
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
export function getClosestFocusable(initial, prev, root, keyboard) {
    if (prev === void 0) { prev = false; }
    if (keyboard === void 0) { keyboard = true; }
    if (!root.ownerDocument) {
        return null;
    }
    var check = keyboard ? isNativeKeyboardFocusable : isNativeMouseFocusable;
    // Deprecated but ony this overload works in IE
    // Filter must be a function in IE, other modern browsers are compliant to this format
    var treeWalker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, svgNodeFilter, false);
    treeWalker.currentNode = initial;
    while (prev ? treeWalker.previousNode() : treeWalker.nextNode()) {
        // TODO: iframe warning
        if (treeWalker.currentNode instanceof HTMLElement) {
            initial = treeWalker.currentNode;
        }
        if (check(initial)) {
            return initial;
        }
    }
    return null;
}
/**
 * @deprecated: use {@link tuiGetClosestFocusable} instead
 */
export var getClosestKeyboardFocusable = getClosestFocusable;
export var tuiGetClosestFocusable = getClosestFocusable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWNsb3Nlc3Qta2V5Ym9hcmQtZm9jdXNhYmxlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay91dGlscy9mb2N1cy8iLCJzb3VyY2VzIjpbImdldC1jbG9zZXN0LWtleWJvYXJkLWZvY3VzYWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFFdEQsT0FBTyxFQUFDLHlCQUF5QixFQUFDLE1BQU0sZ0NBQWdDLENBQUM7QUFDekUsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFFbkU7Ozs7Ozs7OztHQVNHO0FBQ0gsZ0VBQWdFO0FBQ2hFLE1BQU0sVUFBVSxtQkFBbUIsQ0FDL0IsT0FBb0IsRUFDcEIsSUFBcUIsRUFDckIsSUFBVSxFQUNWLFFBQXdCO0lBRnhCLHFCQUFBLEVBQUEsWUFBcUI7SUFFckIseUJBQUEsRUFBQSxlQUF3QjtJQUV4QixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtRQUNyQixPQUFPLElBQUksQ0FBQztLQUNmO0lBRUQsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsc0JBQXNCLENBQUM7SUFFNUUsK0NBQStDO0lBQy9DLHNGQUFzRjtJQUN0RixJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUNsRCxJQUFJLEVBQ0osVUFBVSxDQUFDLFlBQVksRUFDdkIsYUFBYSxFQUNiLEtBQUssQ0FDUixDQUFDO0lBRUYsVUFBVSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7SUFFakMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxFQUFFO1FBQzdELHVCQUF1QjtRQUN2QixJQUFJLFVBQVUsQ0FBQyxXQUFXLFlBQVksV0FBVyxFQUFFO1lBQy9DLE9BQU8sR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDO1NBQ3BDO1FBRUQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDaEIsT0FBTyxPQUFPLENBQUM7U0FDbEI7S0FDSjtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sQ0FBQyxJQUFNLDJCQUEyQixHQUFHLG1CQUFtQixDQUFDO0FBRS9ELE1BQU0sQ0FBQyxJQUFNLHNCQUFzQixHQUFHLG1CQUFtQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzdmdOb2RlRmlsdGVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7aXNOYXRpdmVLZXlib2FyZEZvY3VzYWJsZX0gZnJvbSAnLi9pcy1uYXRpdmUta2V5Ym9hcmQtZm9jdXNhYmxlJztcbmltcG9ydCB7aXNOYXRpdmVNb3VzZUZvY3VzYWJsZX0gZnJvbSAnLi9pcy1uYXRpdmUtbW91c2UtZm9jdXNhYmxlJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZDogdXNlIHtAbGluayB0dWlHZXRDbG9zZXN0Rm9jdXNhYmxlfSBpbnN0ZWFkXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBlbGVtZW50IHRoYXQgY2FuIGJlIGZvY3VzZWQgd2l0aCBhIGtleWJvYXJkIG9yIG1vdXNlIGluIHRoZW9yeVxuICpcbiAqIEBwYXJhbSBpbml0aWFsIGN1cnJlbnQgSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0gcHJldiBzaG91bGQgaXQgbG9vayBiYWNrd2FyZHMgaW5zdGVhZCAoZmluZCBpdGVtIHRoYXQgd2lsbCBiZSBmb2N1c2VkIHdpdGggU2hpZnQgKyBUYWIpXG4gKiBAcGFyYW0gcm9vdCB0b3AgTm9kZSBsaW1pdGluZyB0aGUgc2VhcmNoIGFyZWFcbiAqIEBwYXJhbSBrZXlib2FyZCBkZXRlcm1pbmUgaWYgb25seSBrZXlib2FyZCBmb2N1cyBpcyBvZiBpbnRlcmVzdFxuICpcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsb3Nlc3RGb2N1c2FibGUoXG4gICAgaW5pdGlhbDogSFRNTEVsZW1lbnQsXG4gICAgcHJldjogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHJvb3Q6IE5vZGUsXG4gICAga2V5Ym9hcmQ6IGJvb2xlYW4gPSB0cnVlLFxuKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgICBpZiAoIXJvb3Qub3duZXJEb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjaGVjayA9IGtleWJvYXJkID8gaXNOYXRpdmVLZXlib2FyZEZvY3VzYWJsZSA6IGlzTmF0aXZlTW91c2VGb2N1c2FibGU7XG5cbiAgICAvLyBEZXByZWNhdGVkIGJ1dCBvbnkgdGhpcyBvdmVybG9hZCB3b3JrcyBpbiBJRVxuICAgIC8vIEZpbHRlciBtdXN0IGJlIGEgZnVuY3Rpb24gaW4gSUUsIG90aGVyIG1vZGVybiBicm93c2VycyBhcmUgY29tcGxpYW50IHRvIHRoaXMgZm9ybWF0XG4gICAgY29uc3QgdHJlZVdhbGtlciA9IHJvb3Qub3duZXJEb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgICAgICByb290LFxuICAgICAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcbiAgICAgICAgc3ZnTm9kZUZpbHRlcixcbiAgICAgICAgZmFsc2UsXG4gICAgKTtcblxuICAgIHRyZWVXYWxrZXIuY3VycmVudE5vZGUgPSBpbml0aWFsO1xuXG4gICAgd2hpbGUgKHByZXYgPyB0cmVlV2Fsa2VyLnByZXZpb3VzTm9kZSgpIDogdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8vIFRPRE86IGlmcmFtZSB3YXJuaW5nXG4gICAgICAgIGlmICh0cmVlV2Fsa2VyLmN1cnJlbnROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSB0cmVlV2Fsa2VyLmN1cnJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoZWNrKGluaXRpYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkOiB1c2Uge0BsaW5rIHR1aUdldENsb3Nlc3RGb2N1c2FibGV9IGluc3RlYWRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldENsb3Nlc3RLZXlib2FyZEZvY3VzYWJsZSA9IGdldENsb3Nlc3RGb2N1c2FibGU7XG5cbmV4cG9ydCBjb25zdCB0dWlHZXRDbG9zZXN0Rm9jdXNhYmxlID0gZ2V0Q2xvc2VzdEZvY3VzYWJsZTtcbiJdfQ==