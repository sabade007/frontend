import { CHAR_NO_BREAK_SPACE, tuiAssert, isSafari, CHAR_HYPHEN, isNativeFocused, getDocumentOrShadowRoot, CHAR_EN_DASH } from '@taiga-ui/cdk';
import { __spread, __read } from 'tslib';
import { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP, TUI_LEADING_ZEROES_REGEXP, TUI_DECIMAL_SYMBOLS } from '@taiga-ui/core/constants';
import { otherDecimalSymbol } from '@taiga-ui/core/utils/format';

/**
 * Used to finish a number with zeros to a given precision
 */
function tuiCreateAutoCorrectedNumberPipe(decimalLimit, decimalSymbol, thousandSymbol, nativeInput, allowNegative, isIOS) {
    if (decimalLimit === void 0) { decimalLimit = 0; }
    if (decimalSymbol === void 0) { decimalSymbol = ","; }
    if (thousandSymbol === void 0) { thousandSymbol = CHAR_NO_BREAK_SPACE; }
    if (isIOS === void 0) { isIOS = false; }
    tuiAssert.assert(Number.isInteger(decimalLimit));
    tuiAssert.assert(decimalLimit >= 0);
    // Guess for which browser I need this :)
    var previousCaret = -1;
    var unlucky = (!!nativeInput && isSafari(nativeInput)) || isIOS;
    if (nativeInput && unlucky) {
        nativeInput.addEventListener("beforeinput", function () {
            previousCaret = nativeInput.selectionStart || 0;
        });
    }
    return function (conformedValue, config) {
        // Removing everything by selecting and pressing '-'
        if (!conformedValue && config.rawValue === CHAR_HYPHEN && allowNegative) {
            return CHAR_HYPHEN;
        }
        // remove these hacks after text mask library has changed
        if (nativeInput && unlucky && isNativeFocused(nativeInput)) {
            var caret_1 = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);
            setTimeout(function () {
                nativeInput.setSelectionRange(caret_1, caret_1);
            });
        }
        if (nativeInput &&
            nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) &&
            isNativeFocused(nativeInput) &&
            config.currentCaretPosition) {
            var realCaretPosition_1 = config.currentCaretPosition +
                calculateCaretGap(config.previousConformedValue, conformedValue, thousandSymbol);
            setTimeout(function () {
                nativeInput.setSelectionRange(realCaretPosition_1, realCaretPosition_1);
            });
        }
        if (conformedValue === "" || !decimalLimit) {
            return { value: conformedValue };
        }
        var withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);
        var decimalPart = withDecimalSymbol.split(decimalSymbol)[1];
        var zeroPaddingSize = decimalLimit - decimalPart.length;
        return {
            value: withDecimalSymbol + "0".repeat(zeroPaddingSize),
        };
    };
}
function addDecimalSymbolIfNeeded(value, decimalSymbol) {
    if (decimalSymbol === void 0) { decimalSymbol = ","; }
    return !value.includes(decimalSymbol) ? value + decimalSymbol : value;
}
function calculateSafariCaret(previousValue, current, previousCaret, decimalSymbol) {
    if (previousValue === void 0) { previousValue = ""; }
    if (decimalSymbol === void 0) { decimalSymbol = ","; }
    var tailRegex = new RegExp(decimalSymbol + ".+");
    var previousWithoutTail = previousValue.replace(tailRegex, "");
    var currentWithoutTail = current.replace(tailRegex, "");
    var pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;
    if (pasteOrCutOperation) {
        return current.length;
    }
    if (previousValue.length === current.length) {
        if (previousValue.indexOf(decimalSymbol) <= previousCaret) {
            return calculateChangedTailIndex(previousValue, current);
        }
        return previousWithoutTail === currentWithoutTail
            ? previousCaret - 1
            : previousCaret + 1;
    }
    if (previousValue.length === 0) {
        return 1;
    }
    var changeLength = current.length - previousValue.length;
    return previousCaret + changeLength;
}
function calculateChangedTailIndex(previous, current) {
    for (var i = 0; i < current.length; i++) {
        if (previous[i] !== current[i]) {
            return current[i] === "0" ? i : i + 1;
        }
    }
    return current.length;
}
function calculateCaretGap(previousValue, current, thousandSymbol) {
    if (previousValue === void 0) { previousValue = ""; }
    var pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;
    if (pasteOrCutOperation) {
        return 0;
    }
    var wereSpaces = previousValue.split(thousandSymbol).length;
    var nowSpaces = current.split(thousandSymbol).length;
    return nowSpaces - wereSpaces;
}

var ASSERTION = "Correction function must return single char or null";
function tuiCreateCorrectionMask(allowed, correctionHandler) {
    return function (rawValue) {
        var mask = rawValue.split("").reduce(function (result, char, index) {
            var corrected = correctionHandler(char, index);
            tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);
            if (!allowed.test(char) && !corrected) {
                return result;
            }
            if (allowed.test(char)) {
                return __spread(result, [allowed]);
            }
            if (corrected) {
                return __spread(result, [corrected, MASK_CARET_TRAP]);
            }
            return result;
        }, []);
        var lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);
        var filtered = mask.filter(function (item, index) { return item !== MASK_CARET_TRAP || index === lastIndex; });
        return filtered.some(function (item) { return item !== allowed; })
            ? __spread(filtered, [allowed]) : filtered;
    };
}

var NON_ZERO_DIGIT = /[1-9]/;
/**
 * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}
 */
function tuiCreateNumberMask(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.allowDecimal, allowDecimal = _c === void 0 ? false : _c, _d = _b.decimalSymbol, decimalSymbol = _d === void 0 ? "," : _d, _e = _b.thousandSymbol, thousandSymbol = _e === void 0 ? CHAR_NO_BREAK_SPACE : _e, _f = _b.autoCorrectDecimalSymbol, autoCorrectDecimalSymbol = _f === void 0 ? true : _f, _g = _b.decimalLimit, decimalLimit = _g === void 0 ? 2 : _g, _h = _b.requireDecimal, requireDecimal = _h === void 0 ? false : _h, _j = _b.allowNegative, allowNegative = _j === void 0 ? false : _j, _k = _b.integerLimit, integerLimit = _k === void 0 ? 0 : _k;
    tuiAssert.assert(Number.isInteger(decimalLimit));
    tuiAssert.assert(decimalLimit >= 0);
    tuiAssert.assert(Number.isInteger(integerLimit));
    tuiAssert.assert(integerLimit >= 0);
    return function (rawValue, _a) {
        var previousConformedValue = _a.previousConformedValue;
        if (previousConformedValue && requireDecimal) {
            var conformedWithoutSeparator = rawValue.split(thousandSymbol).join("");
            var previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue
                .split(thousandSymbol)
                .join("")
                .split(decimalSymbol)
                .join("");
            // Forbid removal of decimal separator if decimal part is required
            if (conformedWithoutSeparator ===
                previousConformedValueWithoutDecimalSymbolAndSeparator) {
                rawValue = previousConformedValue;
            }
        }
        var isNegative = (rawValue[0] === CHAR_HYPHEN || rawValue[0] === CHAR_EN_DASH) &&
            allowNegative;
        if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) &&
            allowDecimal) {
            return ["0", decimalSymbol, TUI_DIGIT_REGEXP];
        }
        if (isNegative) {
            rawValue = rawValue.slice(1);
        }
        var decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);
        var hasDecimal = decimalIndex !== -1;
        var integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;
        var thousandSeparators = integer.match(new RegExp(thousandSymbol, "g")) || [];
        var integerCapped = integerLimit
            ? integer.slice(0, integerLimit + thousandSeparators.length)
            : integer;
        var integerCappedClean = integerCapped.replace(TUI_NON_DIGITS_REGEXP, "");
        var _b = __read(integerCappedClean.match(TUI_LEADING_ZEROES_REGEXP) || [""], 1), leadingZerosMatch = _b[0];
        var leadingZerosAmount = leadingZerosMatch.length;
        var integerCappedZerosClean = integerCappedClean
            .replace(/^0+(?!\.|$)/, "")
            .trim();
        var withSeparator = addThousandsSeparator(integerCappedZerosClean, thousandSymbol);
        var mask = convertToMask(withSeparator);
        if ((hasDecimal && allowDecimal) || requireDecimal) {
            var fraction = hasDecimal
                ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ""))
                : [];
            var fractionCapped = decimalLimit
                ? fraction.slice(0, decimalLimit)
                : fraction;
            if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {
                mask.push(MASK_CARET_TRAP);
            }
            mask.push.apply(mask, __spread([decimalSymbol, MASK_CARET_TRAP], fractionCapped));
            for (var i = 0; i < decimalLimit - fractionCapped.length; i++) {
                mask.push(TUI_DIGIT_REGEXP);
            }
        }
        var isOnlyZeroDigit = mask.length === 1 && integerCappedZerosClean === "0";
        if (isNegative) {
            if (mask.length === 0) {
                mask.push(TUI_DIGIT_REGEXP);
            }
            mask.unshift(CHAR_HYPHEN);
        }
        return preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount);
    };
}
function preventLeadingZeroes(mask, isOnlyZeroDigit, leadingZerosAmount) {
    if (isOnlyZeroDigit === void 0) { isOnlyZeroDigit = false; }
    if (leadingZerosAmount === void 0) { leadingZerosAmount = 0; }
    if (isOnlyZeroDigit || leadingZerosAmount === 0) {
        return mask;
    }
    var firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);
    if (firstDigitIndex === -1) {
        return mask;
    }
    var secondMaskDigit = mask[firstDigitIndex + 1];
    var isCaretTrap = secondMaskDigit === MASK_CARET_TRAP;
    if (isCaretTrap && leadingZerosAmount === 1) {
        return mask;
    }
    if (isCaretTrap) {
        mask.unshift(NON_ZERO_DIGIT);
        return mask;
    }
    mask[firstDigitIndex] = NON_ZERO_DIGIT;
    return mask;
}
function getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {
    if (!autoCorrectDecimalSymbol) {
        return str.lastIndexOf(decimalSymbol);
    }
    return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(otherDecimalSymbol(decimalSymbol)));
}
function isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {
    if (autoCorrectDecimalSymbol) {
        return /^[,.]$/.test(str);
    }
    return str === decimalSymbol;
}
function convertToMask(strNumber) {
    return strNumber
        .split("")
        .map(function (char) { return (TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char); });
}
function addThousandsSeparator(strNumber, thousandSymbol) {
    return strNumber.length > 3
        ? // TODO: investigate to disallow potentially catastrophic exponential-time regular expressions.
            // eslint-disable-next-line unicorn/no-unsafe-regex
            strNumber.replace(/\B(?=(\d{3})+(?!\d))/g, thousandSymbol)
        : strNumber;
}

function tuiEnableAutoCorrectDecimalSymbol(_a) {
    var thousandSeparator = _a.thousandSeparator;
    return !TUI_DECIMAL_SYMBOLS.includes(thousandSeparator);
}

/**
 * @deprecated: use {@link tuiMaskedMoneyValueIsEmpty} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function maskedMoneyValueIsEmpty(value) {
    switch (value) {
        case "":
        case CHAR_HYPHEN:
        case ",":
        case CHAR_HYPHEN + ",":
            return true;
        default:
            return false;
    }
}
var tuiMaskedMoneyValueIsEmpty = maskedMoneyValueIsEmpty;

/**
 * @deprecated: use {@link tuiMaskedNumberStringToNumber} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function maskedNumberStringToNumber(value, decimalsSymbol, thousandSymbol) {
    return parseFloat(value.split(thousandSymbol).join("").split(decimalsSymbol).join("."));
}
var tuiMaskedNumberStringToNumber = maskedNumberStringToNumber;

/**
 * Generated bundle index. Do not edit.
 */

export { maskedMoneyValueIsEmpty, maskedNumberStringToNumber, tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask, tuiEnableAutoCorrectDecimalSymbol, tuiMaskedMoneyValueIsEmpty, tuiMaskedNumberStringToNumber };
//# sourceMappingURL=taiga-ui-core-utils-mask.js.map
