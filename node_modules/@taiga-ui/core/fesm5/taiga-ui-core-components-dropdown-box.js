import { __assign, __decorate, __param } from 'tslib';
import { Inject, NgZone, ElementRef, HostBinding, ViewChild, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { WINDOW, ANIMATION_FRAME } from '@ng-web-apis/common';
import { POLLING_TIME, tuiZonefree, inRange, px, tuiAssertIsHTMLElement, getClosestFocusable, TuiDestroyService, TuiDropdownHostComponent, AbstractTuiPortalHostComponent, tuiPure, TuiActiveZoneModule, TuiOverscrollModule } from '@taiga-ui/cdk';
import { tuiDropdownAnimation } from '@taiga-ui/core/animations';
import { DEFAULT_MARGIN, DEFAULT_MAX_WIDTH } from '@taiga-ui/core/constants';
import { TUI_DROPDOWN_DIRECTIVE, TUI_ANIMATION_OPTIONS } from '@taiga-ui/core/tokens';
import { getScreenWidth, tuiGetViewportWidth } from '@taiga-ui/core/utils/dom';
import { merge, fromEvent, Observable } from 'rxjs';
import { throttleTime, takeUntil } from 'rxjs/operators';
import { TuiScrollbarModule } from '@taiga-ui/core/components/scrollbar';
import { TuiModeModule } from '@taiga-ui/core/directives/mode';
import { PolymorpheusModule } from '@tinkoff/ng-polymorpheus';

/**
 *  This component is used to show template in a portal using default style of white rounded box with a shadow
 */
// @bad TODO: OnPush
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiDropdownBoxComponent = /** @class */ (function () {
    function TuiDropdownBoxComponent(destroy$, ngZone, directive, windowRef, elementRef, portalHost, options, animationFrame$) {
        var _this = this;
        this.directive = directive;
        this.windowRef = windowRef;
        this.elementRef = elementRef;
        this.portalHost = portalHost;
        this.options = options;
        this.animationTop = __assign({ value: "fadeInTop" /* FadeInTop */ }, this.options);
        this.animationBottom = __assign({ value: "fadeInBottom" /* FadeInBottom */ }, this.options);
        /**
         * Is previous position on top (to prevent jumping up and down on scroll)
         */
        this.prevDirectionIsTop = false;
        merge(animationFrame$.pipe(throttleTime(POLLING_TIME)), this.directive.refresh$, fromEvent(this.windowRef, 'resize'))
            .pipe(tuiZonefree(ngZone), takeUntil(destroy$))
            .subscribe(function () {
            _this.calculatePositionAndSize();
        });
    }
    Object.defineProperty(TuiDropdownBoxComponent.prototype, "overscroll", {
        get: function () {
            return this.inModal ? 'all' : 'scroll';
        },
        enumerable: true,
        configurable: true
    });
    TuiDropdownBoxComponent.prototype.getContext = function (context, activeZone) {
        return __assign(__assign({}, context), { activeZone: activeZone });
    };
    TuiDropdownBoxComponent.prototype.ngAfterViewChecked = function () {
        this.calculatePositionAndSize();
    };
    TuiDropdownBoxComponent.prototype.onTopFocus = function () {
        this.moveFocusOutside(true);
    };
    TuiDropdownBoxComponent.prototype.onBottomFocus = function () {
        this.moveFocusOutside(false);
    };
    Object.defineProperty(TuiDropdownBoxComponent.prototype, "inModal", {
        get: function () {
            // @awful TODO: get rid of component tag name dependency
            return !!this.directive.host.closest('tui-dialog-host');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiDropdownBoxComponent.prototype, "inOption", {
        get: function () {
            // @awful TODO: get rid of component tag name dependency
            return !!this.directive.host.closest('[tuiOption]');
        },
        enumerable: true,
        configurable: true
    });
    TuiDropdownBoxComponent.prototype.calculatePositionAndSize = function () {
        var clientRect = this.directive.clientRect;
        var style = this.elementRef.nativeElement.style;
        var hostRect = this.directive.fixed
            ? this.portalHost.fixedPositionOffset()
            : this.portalHost.clientRect;
        style.position = this.directive.fixed ? 'fixed' : 'absolute';
        this.calculateVerticalPosition(style, clientRect, hostRect);
        this.calculateHorizontalPosition(style, clientRect, hostRect);
        this.calculateWidth(style, clientRect);
    };
    TuiDropdownBoxComponent.prototype.getFinalAlign = function (style, directiveRect) {
        var dropdownRect = this.elementRef.nativeElement.getBoundingClientRect();
        var dropdownWidth = this.elementRef.nativeElement.offsetWidth;
        var screenWidth = getScreenWidth(this.windowRef.document);
        var isDropdownSizeHypotheticallyFitsViewport = directiveRect.left + dropdownWidth < screenWidth ||
            directiveRect.right - dropdownWidth > 0;
        var isDropdownSizeActuallyFitsViewport = dropdownRect.right <= screenWidth && dropdownRect.left >= 0;
        var finalAlign = this.directive.align;
        switch (this.directive.align) {
            case 'left':
                if (isDropdownSizeHypotheticallyFitsViewport &&
                    dropdownRect.right > screenWidth) {
                    finalAlign = 'right';
                }
                break;
            case 'right':
                if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.left < 0) {
                    finalAlign = 'left';
                }
                break;
        }
        if (style.right === 'auto' && isDropdownSizeActuallyFitsViewport) {
            finalAlign = 'left';
        }
        if (style.left === 'auto' && isDropdownSizeActuallyFitsViewport) {
            finalAlign = 'right';
        }
        return finalAlign;
    };
    /**
     * Calculates horizontal position
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    TuiDropdownBoxComponent.prototype.calculateHorizontalPosition = function (style, directiveRect, hostRect) {
        var offset = this.directive.sided
            ? this.elementRef.nativeElement.getBoundingClientRect().width + DEFAULT_MARGIN
            : 0;
        var left = Math.ceil(directiveRect.left - hostRect.left - offset);
        var right = Math.floor(hostRect.right - directiveRect.right - offset);
        var viewportWidth = tuiGetViewportWidth(this.windowRef);
        switch (this.getFinalAlign(style, directiveRect)) {
            case 'left':
                if (right + DEFAULT_MARGIN > viewportWidth ||
                    inRange(left + DEFAULT_MARGIN, 0, viewportWidth)) {
                    style.left = px(left);
                    style.right = 'auto';
                }
                else {
                    style.left = 'auto';
                    style.right = px(right);
                }
                break;
            case 'right':
                if (inRange(right + DEFAULT_MARGIN, 0, viewportWidth) ||
                    left + DEFAULT_MARGIN > viewportWidth) {
                    style.left = 'auto';
                    style.right = px(right);
                }
                else {
                    style.left = px(left);
                    style.right = 'auto';
                }
                break;
        }
    };
    /**
     * Calculates vertical position and height
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    TuiDropdownBoxComponent.prototype.calculateVerticalPosition = function (style, directiveRect, hostRect) {
        var windowHeight = this.windowRef.innerHeight;
        // Maximum height of the box
        var boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);
        var offset = this.directive.sided
            ? DEFAULT_MARGIN - directiveRect.height
            : DEFAULT_MARGIN * 2;
        var topAvailableHeight = directiveRect.top - offset;
        var bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
        var finalDirection = this.getFinalDirection(directiveRect);
        var optionOffset = this.inOption ? DEFAULT_MARGIN * 2 : 0;
        this.prevDirectionIsTop = finalDirection === 'top';
        if (finalDirection === 'top') {
            this.dropdownAnimation = this.animationBottom;
            style.maxHeight = px(Math.min(boxHeightLimit, topAvailableHeight));
            style.top = 'auto';
            style.bottom = px(hostRect.bottom -
                directiveRect.top -
                DEFAULT_MARGIN +
                offset -
                optionOffset);
        }
        else {
            this.dropdownAnimation = this.animationTop;
            style.maxHeight = px(Math.min(boxHeightLimit, bottomAvailableHeight));
            style.top = px(directiveRect.bottom -
                hostRect.top -
                DEFAULT_MARGIN +
                offset -
                optionOffset);
            style.bottom = 'auto';
        }
    };
    TuiDropdownBoxComponent.prototype.getFinalDirection = function (directiveRect) {
        var windowHeight = this.windowRef.innerHeight;
        var offset = this.directive.sided
            ? DEFAULT_MARGIN - directiveRect.height
            : DEFAULT_MARGIN * 2;
        // Maximum space available on top and on the bottom in the viewport
        var topAvailableHeight = directiveRect.top - offset;
        var bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
        var finalDirection = null;
        // Given direction is applied if we can fit the box in the limits that way
        switch (this.directive.direction) {
            case 'top':
                if (topAvailableHeight >= this.directive.minHeight) {
                    finalDirection = 'top';
                }
                break;
            case 'bottom':
                if (bottomAvailableHeight >= this.directive.minHeight) {
                    finalDirection = 'bottom';
                }
                break;
        }
        // Maximum height of the box
        var boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);
        // Choose direction if given direction did not fit
        if (finalDirection === null && this.contentElementRef) {
            // Box height if it fits without scroll
            var visualHeight = Math.min(this.contentElementRef.nativeElement.getBoundingClientRect().height +
                (this.elementRef.nativeElement.offsetHeight -
                    this.elementRef.nativeElement.clientHeight), boxHeightLimit);
            // If there is enough space to fit below without scroll,
            // choose 'bottom', unless it was previously on the top
            if (this.prevDirectionIsTop && topAvailableHeight >= visualHeight) {
                finalDirection = 'top';
            }
            else if (bottomAvailableHeight >= visualHeight) {
                finalDirection = 'bottom';
            }
            else {
                // Corner case — select direction with more space
                finalDirection =
                    bottomAvailableHeight >= topAvailableHeight ? 'bottom' : 'top';
            }
        }
        return finalDirection;
    };
    /**
     * Calculates width
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     */
    TuiDropdownBoxComponent.prototype.calculateWidth = function (style, directiveRect) {
        style.width =
            this.directive.limitMinWidth === 'fixed' && !this.directive.sided
                ? px(directiveRect.width)
                : '';
        if (this.directive.limitMinWidth === 'min' && !this.directive.sided) {
            style.minWidth = px(directiveRect.width);
            style.maxWidth = px(DEFAULT_MAX_WIDTH);
            return;
        }
        style.minWidth = '';
        style.maxWidth = '';
    };
    TuiDropdownBoxComponent.prototype.moveFocusOutside = function (previous) {
        var host = this.directive.host;
        var ownerDocument = host.ownerDocument;
        var root = ownerDocument ? ownerDocument.body : host;
        tuiAssertIsHTMLElement(host);
        var focusable = getClosestFocusable(host, previous, root);
        while (focusable !== null && host.contains(focusable)) {
            focusable = getClosestFocusable(focusable, previous, root);
        }
        focusable === null || focusable === void 0 ? void 0 : focusable.focus();
    };
    TuiDropdownBoxComponent.ctorParameters = function () { return [
        { type: TuiDestroyService, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_DROPDOWN_DIRECTIVE,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: TuiDropdownHostComponent, decorators: [{ type: Inject, args: [AbstractTuiPortalHostComponent,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_ANIMATION_OPTIONS,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
    ]; };
    __decorate([
        HostBinding('@tuiDropdownAnimation')
    ], TuiDropdownBoxComponent.prototype, "dropdownAnimation", void 0);
    __decorate([
        ViewChild('content', { read: ElementRef })
    ], TuiDropdownBoxComponent.prototype, "contentElementRef", void 0);
    __decorate([
        tuiPure
    ], TuiDropdownBoxComponent.prototype, "getContext", null);
    __decorate([
        tuiPure
    ], TuiDropdownBoxComponent.prototype, "inModal", null);
    __decorate([
        tuiPure
    ], TuiDropdownBoxComponent.prototype, "inOption", null);
    TuiDropdownBoxComponent = __decorate([
        Component({
            selector: 'tui-dropdown-box',
            template: "<div\n    #activeZone=\"tuiActiveZone\"\n    class=\"t-wrapper\"\n    [tuiOverscroll]=\"overscroll\"\n    [tuiMode]=\"null\"\n    [tuiActiveZoneParent]=\"directive.activeZone || null\"\n>\n    <tui-scrollbar class=\"t-scroll\">\n        <div\n            tabindex=\"0\"\n            (focus)=\"onTopFocus()\"\n        ></div>\n        <div\n            #content\n            polymorpheus-outlet\n            class=\"t-content\"\n            [content]=\"directive.content\"\n            [context]=\"getContext(directive.context, activeZone)\"\n        ></div>\n        <div\n            tabindex=\"0\"\n            (focus)=\"onBottomFocus()\"\n        ></div>\n    </tui-scrollbar>\n</div>\n",
            changeDetection: ChangeDetectionStrategy.Default,
            providers: [TuiDestroyService],
            animations: [tuiDropdownAnimation],
            styles: [":host{z-index:0;box-shadow:0 .5rem 1rem rgba(0,0,0,.16);position:absolute;top:0;left:0;display:flex;background-color:#fff;background-color:var(--tui-elevation-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-03);box-sizing:border-box}:host.ng-animating{pointer-events:none}.t-content{display:flex;flex-direction:column;max-height:100%}.t-wrapper{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.t-scroll{height:100%}"]
        }),
        __param(0, Inject(TuiDestroyService)),
        __param(1, Inject(NgZone)),
        __param(2, Inject(TUI_DROPDOWN_DIRECTIVE)),
        __param(3, Inject(WINDOW)),
        __param(4, Inject(ElementRef)),
        __param(5, Inject(AbstractTuiPortalHostComponent)),
        __param(6, Inject(TUI_ANIMATION_OPTIONS)),
        __param(7, Inject(ANIMATION_FRAME))
    ], TuiDropdownBoxComponent);
    return TuiDropdownBoxComponent;
}());

var TuiDropdownBoxModule = /** @class */ (function () {
    function TuiDropdownBoxModule() {
    }
    TuiDropdownBoxModule = __decorate([
        NgModule({
            imports: [
                TuiActiveZoneModule,
                PolymorpheusModule,
                TuiOverscrollModule,
                TuiScrollbarModule,
                TuiModeModule,
            ],
            entryComponents: [TuiDropdownBoxComponent],
            declarations: [TuiDropdownBoxComponent],
            exports: [TuiDropdownBoxComponent],
        })
    ], TuiDropdownBoxModule);
    return TuiDropdownBoxModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDropdownBoxComponent, TuiDropdownBoxModule };
//# sourceMappingURL=taiga-ui-core-components-dropdown-box.js.map
