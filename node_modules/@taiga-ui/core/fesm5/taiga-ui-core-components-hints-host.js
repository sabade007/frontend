import { __decorate, __param, __assign } from 'tslib';
import { ElementRef, Inject, Component, ChangeDetectionStrategy, NgZone, forwardRef, ViewChild, HostBinding, NgModule } from '@angular/core';
import { ANIMATION_FRAME, WINDOW } from '@ng-web-apis/common';
import { TUI_PARENT_ANIMATION, tuiZonefree, px, TuiDestroyService, tuiPure, TuiHoveredModule, TuiActiveZoneModule } from '@taiga-ui/cdk';
import { tuiFadeIn } from '@taiga-ui/core/animations';
import { TuiHintDirective } from '@taiga-ui/core/directives';
import { TuiPointerHintDirective } from '@taiga-ui/core/directives/pointer-hint';
import { TUI_ANIMATION_OPTIONS, TUI_MEDIA } from '@taiga-ui/core/tokens';
import { tuiIsMobile } from '@taiga-ui/core/utils';
import { PolymorpheusComponent, POLYMORPHEUS_CONTEXT, PolymorpheusModule } from '@tinkoff/ng-polymorpheus';
import { Observable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { TuiHintService } from '@taiga-ui/core/services';
import { CommonModule } from '@angular/common';

var TuiHintsHostComponent = /** @class */ (function () {
    function TuiHintsHostComponent(elementRef, hints$) {
        this.elementRef = elementRef;
        this.hints$ = hints$;
        this.component = new PolymorpheusComponent(TuiHintBoxComponent);
    }
    Object.defineProperty(TuiHintsHostComponent.prototype, "clientRect", {
        get: function () {
            return this.elementRef.nativeElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    TuiHintsHostComponent.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiHintService,] }] }
    ]; };
    TuiHintsHostComponent = __decorate([
        Component({
            selector: 'tui-hints-host',
            template: "<div\n    *ngFor=\"let hint of hints$ | async\"\n    role=\"tooltip\"\n    polymorpheus-outlet\n    @tuiParentAnimation\n    [attr.id]=\"hint.id\"\n    [content]=\"hint.component || component\"\n    [context]=\"{$implicit: hint}\"\n    [tuiActiveZoneParent]=\"hint.activeZone\"\n></div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            animations: [TUI_PARENT_ANIMATION],
            host: {
                'aria-live': 'polite',
            },
            styles: [":host{position:fixed;bottom:0;left:0;width:100%;height:0}"]
        }),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(TuiHintService))
    ], TuiHintsHostComponent);
    return TuiHintsHostComponent;
}());

var SPACE = 8;
var BORDER_WIDTH = 1;
var LEFT_PADDING = 16;
var TOP_PADDING = 12;
var ARROW_SIZE = 8;
var ARROW_OFFSET = 16;
var ARROWHEAD_OFFSET = ARROW_OFFSET + (ARROW_SIZE * Math.sqrt(2)) / 2;
var reverseDirectionsVertical = {
    'top-left': 'bottom-left',
    'top-right': 'bottom-right',
    'bottom-left': 'top-left',
    'bottom-right': 'top-right',
    left: 'right',
    right: 'left',
    'top-middle': 'bottom-middle',
    'bottom-middle': 'top-middle',
};
var reverseDirectionsHorizontal = {
    'top-left': 'top-right',
    'top-right': 'top-left',
    'bottom-left': 'bottom-right',
    'bottom-right': 'bottom-left',
    left: 'right',
    right: 'left',
    'top-middle': 'top-middle',
    'bottom-middle': 'bottom-middle',
};
// TODO: consider abstracting UI and move to CDK, split hint and overflow
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiHintBoxComponent = /** @class */ (function () {
    function TuiHintBoxComponent(animationFrame$, destroy$, ngZone, options, elementRef, windowRef, media, hintsHost, context) {
        var _this = this;
        this.options = options;
        this.elementRef = elementRef;
        this.windowRef = windowRef;
        this.media = media;
        this.hintsHost = hintsHost;
        this.context = context;
        this.animation = __assign({ value: '' }, this.options);
        animationFrame$
            .pipe(tuiZonefree(ngZone), takeUntil(destroy$))
            .subscribe(function () { return _this.calculatePosition(); });
    }
    Object.defineProperty(TuiHintBoxComponent.prototype, "hint", {
        get: function () {
            return this.context.$implicit;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiHintBoxComponent.prototype, "isUntouchable", {
        get: function () {
            return this.hint instanceof TuiPointerHintDirective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiHintBoxComponent.prototype, "mode", {
        get: function () {
            return this.hint.mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiHintBoxComponent.prototype, "isMobile", {
        get: function () {
            return tuiIsMobile(this.windowRef, this.media);
        },
        enumerable: true,
        configurable: true
    });
    TuiHintBoxComponent.prototype.onHovered = function (hovered) {
        if (this.hint instanceof TuiHintDirective) {
            this.hint.componentHovered$.next(hovered);
        }
    };
    /**
     * Calculates wrapper position.
     * Styles are set directly to avoid visual shake of element
     */
    TuiHintBoxComponent.prototype.calculatePosition = function () {
        if (this.mode !== 'overflow') {
            this.calculateCoordinates();
        }
        else {
            this.setOverflowStyles();
        }
    };
    TuiHintBoxComponent.prototype.calculateCoordinates = function () {
        if (this.isMobile) {
            this.calculateMobileCoordinates();
            return;
        }
        var hostRect = this.hint.getElementClientRect();
        var portalRect = this.hintsHost.clientRect;
        var tooltip = this.elementRef.nativeElement;
        var style = tooltip.style;
        var tooltipRect = tooltip.getBoundingClientRect();
        var isHostLong = hostRect.width > ARROWHEAD_OFFSET * 2;
        var directions = [
            'left',
            'right',
            'bottom-left',
            'bottom-right',
            'bottom-middle',
            'top-left',
            'top-right',
            'top-middle',
        ];
        var top = 0;
        var left = 0;
        var direction = this.hint.direction;
        var horizontalTop = hostRect.top + hostRect.height / 2 - tooltipRect.height / 2 - portalRect.top;
        var horizontalLeft = hostRect.left - tooltipRect.width - SPACE - portalRect.left;
        var horizontalRight = hostRect.left + hostRect.width + SPACE - portalRect.left;
        var verticalBottom = hostRect.bottom + SPACE - portalRect.top;
        var verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
        var verticalRight = isHostLong
            ? hostRect.left - portalRect.left
            : hostRect.left + hostRect.width / 2 - ARROWHEAD_OFFSET - portalRect.left;
        var verticalLeft = isHostLong
            ? hostRect.left - tooltipRect.width + hostRect.width - portalRect.left
            : hostRect.left -
                tooltipRect.width +
                hostRect.width / 2 +
                ARROWHEAD_OFFSET -
                portalRect.left;
        var verticalMiddle = hostRect.left - tooltipRect.width / 2 + hostRect.width / 2 - portalRect.left;
        directions.splice(directions.indexOf(direction), 1);
        // eslint-disable-next-line no-constant-condition
        while (true) {
            switch (direction) {
                case 'left':
                    top = horizontalTop;
                    left = horizontalLeft;
                    break;
                case 'right':
                    top = horizontalTop;
                    left = horizontalRight;
                    break;
                case 'top-right':
                    top = verticalTop;
                    left = verticalRight;
                    break;
                case 'top-left':
                    top = verticalTop;
                    left = verticalLeft;
                    break;
                case 'bottom-right':
                    top = verticalBottom;
                    left = verticalRight;
                    break;
                case 'bottom-left':
                    top = verticalBottom;
                    left = verticalLeft;
                    break;
                case 'bottom-middle':
                    top = verticalBottom;
                    left = verticalMiddle;
                    break;
                case 'top-middle':
                    top = verticalTop;
                    left = verticalMiddle;
                    break;
            }
            var verticalFit = top + portalRect.top > SPACE &&
                top + tooltipRect.height + SPACE + portalRect.top <
                    this.windowRef.innerHeight;
            var horizontalFit = left > SPACE &&
                left + tooltipRect.width + SPACE + portalRect.left < portalRect.width;
            if (directions.length === 0 || (verticalFit && horizontalFit)) {
                break;
            }
            direction = verticalFit
                ? reverseDirectionsHorizontal[direction]
                : reverseDirectionsVertical[direction];
            direction =
                directions.splice(directions.indexOf(direction), 1)[0] || direction;
        }
        style.top = px(top);
        style.left = px(left);
        tooltip.setAttribute('data-tui-host-direction', direction);
    };
    TuiHintBoxComponent.prototype.calculateMobileCoordinates = function () {
        var hostRect = this.hint.getElementClientRect();
        var portalRect = this.hintsHost.clientRect;
        var tooltip = this.elementRef.nativeElement;
        var style = tooltip.style;
        var tooltipRect = tooltip.getBoundingClientRect();
        var verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
        var verticalBottom = hostRect.bottom + SPACE - portalRect.top;
        var verticalTopFit = verticalTop + portalRect.top > SPACE &&
            hostRect.top < this.windowRef.innerHeight;
        var verticalBottomFit = hostRect.bottom > 0 &&
            hostRect.bottom + 2 * SPACE + tooltipRect.height < this.windowRef.innerHeight;
        var direction = (this.hint.direction.includes('top') && verticalTopFit) || !verticalBottomFit
            ? 'top'
            : 'bottom';
        var attemptedLeft = portalRect.left + hostRect.left + hostRect.width / 2 - tooltipRect.width / 2;
        var left = Math.max(attemptedLeft + tooltipRect.width + SPACE > portalRect.right
            ? portalRect.right - SPACE - tooltipRect.width
            : attemptedLeft, SPACE * 2);
        style.left = px(left);
        style.top = direction === 'top' ? px(verticalTop) : px(verticalBottom);
        if (this.arrow) {
            this.arrow.nativeElement.style.left = px(hostRect.left <= SPACE * 2 && hostRect.width > ARROW_OFFSET * 2
                ? ARROW_OFFSET
                : hostRect.left + hostRect.width / 2 - left - ARROW_SIZE / 2);
        }
        tooltip.setAttribute('data-tui-host-direction', direction);
    };
    TuiHintBoxComponent.prototype.setOverflowStyles = function () {
        var hostRect = this.hint.getElementClientRect();
        var style = this.elementRef.nativeElement.style;
        style.top = px(hostRect.top - window.innerHeight - TOP_PADDING - BORDER_WIDTH);
        style.left = px(hostRect.left - LEFT_PADDING - BORDER_WIDTH);
        style.width = px(hostRect.width + LEFT_PADDING * 2 + BORDER_WIDTH * 2);
    };
    TuiHintBoxComponent.ctorParameters = function () { return [
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_ANIMATION_OPTIONS,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_MEDIA,] }] },
        { type: TuiHintsHostComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return TuiHintsHostComponent; }),] }] },
        { type: undefined, decorators: [{ type: Inject, args: [POLYMORPHEUS_CONTEXT,] }] }
    ]; };
    __decorate([
        ViewChild('arrow')
    ], TuiHintBoxComponent.prototype, "arrow", void 0);
    __decorate([
        HostBinding('@tuiFadeIn')
    ], TuiHintBoxComponent.prototype, "animation", void 0);
    __decorate([
        tuiPure,
        HostBinding('class._untouchable')
    ], TuiHintBoxComponent.prototype, "isUntouchable", null);
    __decorate([
        HostBinding('attr.data-mode')
    ], TuiHintBoxComponent.prototype, "mode", null);
    TuiHintBoxComponent = __decorate([
        Component({
            selector: 'tui-hint-box[hint]',
            template: "<!-- @bad TODO: Refactor to use this arrow in all cases -->\n<div\n    *ngIf=\"isMobile && mode !== 'overflow'\"\n    #arrow\n    class=\"t-arrow\"\n></div>\n<div\n    automation-id=\"tui-hint-box__tooltip\"\n    polymorpheus-outlet\n    class=\"t-tooltip\"\n    [content]=\"hint.content\"\n    (tuiHoveredChange)=\"onHovered($event)\"\n>\n    <ng-template let-text>\n        <span class=\"t-text\">{{ text }}</span>\n    </ng-template>\n</div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [TuiDestroyService],
            animations: [tuiFadeIn],
            styles: [":host{position:absolute;top:0;left:0;max-width:18rem;min-height:var(--tui-height-m);padding:.75rem 1rem;background:var(--tui-primary);border-radius:var(--tui-radius-l);color:var(--tui-primary-text);box-sizing:border-box}:host .t-arrow,:host:not([data-mode=overflow]):before{content:'';position:absolute;width:.5rem;height:.5rem;border-radius:.125rem;box-sizing:border-box;background-color:inherit;transform:rotate(45deg)}:host[data-tui-host-direction=top] .t-arrow{bottom:-.25rem}:host[data-tui-host-direction=bottom] .t-arrow{top:-.25rem}:host[data-tui-host-direction=bottom]:before,:host[data-tui-host-direction=top]:before{display:none}:host[data-tui-host-direction=top-left]:before,:host[data-tui-host-direction=top-middle]:before,:host[data-tui-host-direction=top-right]:before{bottom:-.25rem}:host[data-tui-host-direction=bottom-left]:before,:host[data-tui-host-direction=bottom-middle]:before,:host[data-tui-host-direction=bottom-right]:before{top:-.25rem}:host[data-tui-host-direction=bottom-middle]:before,:host[data-tui-host-direction=top-middle]:before{left:calc(50% - .2rem)}:host[data-tui-host-direction=bottom-left]:before,:host[data-tui-host-direction=top-left]:before{right:1.075rem}:host[data-tui-host-direction=bottom-right]:before,:host[data-tui-host-direction=top-right]:before{left:1.075rem}:host[data-tui-host-direction=left]:before,:host[data-tui-host-direction=right]:before{top:50%;margin-top:-.25rem}:host[data-tui-host-direction=left]:before{right:-.25rem}:host[data-tui-host-direction=right]:before{left:-.25rem}:host[data-mode=error]{background-color:var(--tui-error-fill)}:host[data-mode=onDark],:host[data-mode=overflow]{box-shadow:0 .5rem 1rem rgba(0,0,0,.16);border:1px solid var(--tui-base-03);background-color:var(--tui-base-01);color:var(--tui-text-01)}:host[data-mode=onDark]:before,:host[data-mode=overflow]:before{border:1px solid var(--tui-base-03)}:host[data-mode=onDark][data-tui-host-direction=left]:before,:host[data-mode=overflow][data-tui-host-direction=left]:before{border-left-color:transparent;border-bottom-color:transparent}:host[data-mode=onDark][data-tui-host-direction=right]:before,:host[data-mode=overflow][data-tui-host-direction=right]:before{border-right-color:transparent;border-top-color:transparent}:host[data-mode=onDark][data-tui-host-direction=top-left]:before,:host[data-mode=onDark][data-tui-host-direction=top-middle]:before,:host[data-mode=onDark][data-tui-host-direction=top-right]:before,:host[data-mode=overflow][data-tui-host-direction=top-left]:before,:host[data-mode=overflow][data-tui-host-direction=top-middle]:before,:host[data-mode=overflow][data-tui-host-direction=top-right]:before{border-left-color:transparent;border-top-color:transparent}:host[data-mode=onDark][data-tui-host-direction=bottom-left]:before,:host[data-mode=onDark][data-tui-host-direction=bottom-middle]:before,:host[data-mode=onDark][data-tui-host-direction=bottom-right]:before,:host[data-mode=overflow][data-tui-host-direction=bottom-left]:before,:host[data-mode=overflow][data-tui-host-direction=bottom-middle]:before,:host[data-mode=overflow][data-tui-host-direction=bottom-right]:before{border-right-color:transparent;border-bottom-color:transparent}:host[data-mode=overflow]{max-width:none}:host._untouchable{pointer-events:none}.t-tooltip{font:var(--tui-font-text-s);word-wrap:break-word}:host[data-mode=overflow] .t-tooltip{font:inherit}.t-text{white-space:pre-wrap}"]
        }),
        __param(0, Inject(ANIMATION_FRAME)),
        __param(1, Inject(TuiDestroyService)),
        __param(2, Inject(NgZone)),
        __param(3, Inject(TUI_ANIMATION_OPTIONS)),
        __param(4, Inject(ElementRef)),
        __param(5, Inject(WINDOW)),
        __param(6, Inject(TUI_MEDIA)),
        __param(7, Inject(forwardRef(function () { return TuiHintsHostComponent; }))),
        __param(8, Inject(POLYMORPHEUS_CONTEXT))
    ], TuiHintBoxComponent);
    return TuiHintBoxComponent;
}());

var TuiHintBoxModule = /** @class */ (function () {
    function TuiHintBoxModule() {
    }
    TuiHintBoxModule = __decorate([
        NgModule({
            imports: [CommonModule, PolymorpheusModule, TuiHoveredModule],
            declarations: [TuiHintBoxComponent],
            exports: [TuiHintBoxComponent],
            entryComponents: [TuiHintBoxComponent],
        })
    ], TuiHintBoxModule);
    return TuiHintBoxModule;
}());

var TuiHintsHostModule = /** @class */ (function () {
    function TuiHintsHostModule() {
    }
    TuiHintsHostModule = __decorate([
        NgModule({
            imports: [CommonModule, PolymorpheusModule, TuiHintBoxModule, TuiActiveZoneModule],
            declarations: [TuiHintsHostComponent],
            exports: [TuiHintsHostComponent],
        })
    ], TuiHintsHostModule);
    return TuiHintsHostModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TuiHintBoxComponent, TuiHintBoxModule, TuiHintsHostComponent, TuiHintsHostModule };
//# sourceMappingURL=taiga-ui-core-components-hints-host.js.map
