import { __decorate, __param } from 'tslib';
import { Inject, NgZone, ElementRef, HostBinding, ViewChild, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { WINDOW, ANIMATION_FRAME } from '@ng-web-apis/common';
import { POLLING_TIME, tuiZonefree, inRange, px, tuiAssertIsHTMLElement, getClosestFocusable, TuiDestroyService, TuiDropdownHostComponent, AbstractTuiPortalHostComponent, tuiPure, TuiActiveZoneModule, TuiOverscrollModule } from '@taiga-ui/cdk';
import { tuiDropdownAnimation } from '@taiga-ui/core/animations';
import { DEFAULT_MARGIN, DEFAULT_MAX_WIDTH } from '@taiga-ui/core/constants';
import { TUI_DROPDOWN_DIRECTIVE, TUI_ANIMATION_OPTIONS } from '@taiga-ui/core/tokens';
import { getScreenWidth, tuiGetViewportWidth } from '@taiga-ui/core/utils/dom';
import { merge, fromEvent, Observable } from 'rxjs';
import { throttleTime, takeUntil } from 'rxjs/operators';
import { TuiScrollbarModule } from '@taiga-ui/core/components/scrollbar';
import { TuiModeModule } from '@taiga-ui/core/directives/mode';
import { PolymorpheusModule } from '@tinkoff/ng-polymorpheus';

/**
 *  This component is used to show template in a portal using default style of white rounded box with a shadow
 */
// @bad TODO: OnPush
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiDropdownBoxComponent = class TuiDropdownBoxComponent {
    constructor(destroy$, ngZone, directive, windowRef, elementRef, portalHost, options, animationFrame$) {
        this.directive = directive;
        this.windowRef = windowRef;
        this.elementRef = elementRef;
        this.portalHost = portalHost;
        this.options = options;
        this.animationTop = Object.assign({ value: "fadeInTop" /* FadeInTop */ }, this.options);
        this.animationBottom = Object.assign({ value: "fadeInBottom" /* FadeInBottom */ }, this.options);
        /**
         * Is previous position on top (to prevent jumping up and down on scroll)
         */
        this.prevDirectionIsTop = false;
        merge(animationFrame$.pipe(throttleTime(POLLING_TIME)), this.directive.refresh$, fromEvent(this.windowRef, 'resize'))
            .pipe(tuiZonefree(ngZone), takeUntil(destroy$))
            .subscribe(() => {
            this.calculatePositionAndSize();
        });
    }
    get overscroll() {
        return this.inModal ? 'all' : 'scroll';
    }
    getContext(context, activeZone) {
        return Object.assign(Object.assign({}, context), { activeZone });
    }
    ngAfterViewChecked() {
        this.calculatePositionAndSize();
    }
    onTopFocus() {
        this.moveFocusOutside(true);
    }
    onBottomFocus() {
        this.moveFocusOutside(false);
    }
    get inModal() {
        // @awful TODO: get rid of component tag name dependency
        return !!this.directive.host.closest('tui-dialog-host');
    }
    get inOption() {
        // @awful TODO: get rid of component tag name dependency
        return !!this.directive.host.closest('[tuiOption]');
    }
    calculatePositionAndSize() {
        const { clientRect } = this.directive;
        const { style } = this.elementRef.nativeElement;
        const hostRect = this.directive.fixed
            ? this.portalHost.fixedPositionOffset()
            : this.portalHost.clientRect;
        style.position = this.directive.fixed ? 'fixed' : 'absolute';
        this.calculateVerticalPosition(style, clientRect, hostRect);
        this.calculateHorizontalPosition(style, clientRect, hostRect);
        this.calculateWidth(style, clientRect);
    }
    getFinalAlign(style, directiveRect) {
        const dropdownRect = this.elementRef.nativeElement.getBoundingClientRect();
        const dropdownWidth = this.elementRef.nativeElement.offsetWidth;
        const screenWidth = getScreenWidth(this.windowRef.document);
        const isDropdownSizeHypotheticallyFitsViewport = directiveRect.left + dropdownWidth < screenWidth ||
            directiveRect.right - dropdownWidth > 0;
        const isDropdownSizeActuallyFitsViewport = dropdownRect.right <= screenWidth && dropdownRect.left >= 0;
        let finalAlign = this.directive.align;
        switch (this.directive.align) {
            case 'left':
                if (isDropdownSizeHypotheticallyFitsViewport &&
                    dropdownRect.right > screenWidth) {
                    finalAlign = 'right';
                }
                break;
            case 'right':
                if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.left < 0) {
                    finalAlign = 'left';
                }
                break;
        }
        if (style.right === 'auto' && isDropdownSizeActuallyFitsViewport) {
            finalAlign = 'left';
        }
        if (style.left === 'auto' && isDropdownSizeActuallyFitsViewport) {
            finalAlign = 'right';
        }
        return finalAlign;
    }
    /**
     * Calculates horizontal position
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateHorizontalPosition(style, directiveRect, hostRect) {
        const offset = this.directive.sided
            ? this.elementRef.nativeElement.getBoundingClientRect().width + DEFAULT_MARGIN
            : 0;
        const left = Math.ceil(directiveRect.left - hostRect.left - offset);
        const right = Math.floor(hostRect.right - directiveRect.right - offset);
        const viewportWidth = tuiGetViewportWidth(this.windowRef);
        switch (this.getFinalAlign(style, directiveRect)) {
            case 'left':
                if (right + DEFAULT_MARGIN > viewportWidth ||
                    inRange(left + DEFAULT_MARGIN, 0, viewportWidth)) {
                    style.left = px(left);
                    style.right = 'auto';
                }
                else {
                    style.left = 'auto';
                    style.right = px(right);
                }
                break;
            case 'right':
                if (inRange(right + DEFAULT_MARGIN, 0, viewportWidth) ||
                    left + DEFAULT_MARGIN > viewportWidth) {
                    style.left = 'auto';
                    style.right = px(right);
                }
                else {
                    style.left = px(left);
                    style.right = 'auto';
                }
                break;
        }
    }
    /**
     * Calculates vertical position and height
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateVerticalPosition(style, directiveRect, hostRect) {
        const windowHeight = this.windowRef.innerHeight;
        // Maximum height of the box
        const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);
        const offset = this.directive.sided
            ? DEFAULT_MARGIN - directiveRect.height
            : DEFAULT_MARGIN * 2;
        const topAvailableHeight = directiveRect.top - offset;
        const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
        const finalDirection = this.getFinalDirection(directiveRect);
        const optionOffset = this.inOption ? DEFAULT_MARGIN * 2 : 0;
        this.prevDirectionIsTop = finalDirection === 'top';
        if (finalDirection === 'top') {
            this.dropdownAnimation = this.animationBottom;
            style.maxHeight = px(Math.min(boxHeightLimit, topAvailableHeight));
            style.top = 'auto';
            style.bottom = px(hostRect.bottom -
                directiveRect.top -
                DEFAULT_MARGIN +
                offset -
                optionOffset);
        }
        else {
            this.dropdownAnimation = this.animationTop;
            style.maxHeight = px(Math.min(boxHeightLimit, bottomAvailableHeight));
            style.top = px(directiveRect.bottom -
                hostRect.top -
                DEFAULT_MARGIN +
                offset -
                optionOffset);
            style.bottom = 'auto';
        }
    }
    getFinalDirection(directiveRect) {
        const windowHeight = this.windowRef.innerHeight;
        const offset = this.directive.sided
            ? DEFAULT_MARGIN - directiveRect.height
            : DEFAULT_MARGIN * 2;
        // Maximum space available on top and on the bottom in the viewport
        const topAvailableHeight = directiveRect.top - offset;
        const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
        let finalDirection = null;
        // Given direction is applied if we can fit the box in the limits that way
        switch (this.directive.direction) {
            case 'top':
                if (topAvailableHeight >= this.directive.minHeight) {
                    finalDirection = 'top';
                }
                break;
            case 'bottom':
                if (bottomAvailableHeight >= this.directive.minHeight) {
                    finalDirection = 'bottom';
                }
                break;
        }
        // Maximum height of the box
        const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);
        // Choose direction if given direction did not fit
        if (finalDirection === null && this.contentElementRef) {
            // Box height if it fits without scroll
            const visualHeight = Math.min(this.contentElementRef.nativeElement.getBoundingClientRect().height +
                (this.elementRef.nativeElement.offsetHeight -
                    this.elementRef.nativeElement.clientHeight), boxHeightLimit);
            // If there is enough space to fit below without scroll,
            // choose 'bottom', unless it was previously on the top
            if (this.prevDirectionIsTop && topAvailableHeight >= visualHeight) {
                finalDirection = 'top';
            }
            else if (bottomAvailableHeight >= visualHeight) {
                finalDirection = 'bottom';
            }
            else {
                // Corner case — select direction with more space
                finalDirection =
                    bottomAvailableHeight >= topAvailableHeight ? 'bottom' : 'top';
            }
        }
        return finalDirection;
    }
    /**
     * Calculates width
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     */
    calculateWidth(style, directiveRect) {
        style.width =
            this.directive.limitMinWidth === 'fixed' && !this.directive.sided
                ? px(directiveRect.width)
                : '';
        if (this.directive.limitMinWidth === 'min' && !this.directive.sided) {
            style.minWidth = px(directiveRect.width);
            style.maxWidth = px(DEFAULT_MAX_WIDTH);
            return;
        }
        style.minWidth = '';
        style.maxWidth = '';
    }
    moveFocusOutside(previous) {
        const { host } = this.directive;
        const { ownerDocument } = host;
        const root = ownerDocument ? ownerDocument.body : host;
        tuiAssertIsHTMLElement(host);
        let focusable = getClosestFocusable(host, previous, root);
        while (focusable !== null && host.contains(focusable)) {
            focusable = getClosestFocusable(focusable, previous, root);
        }
        focusable === null || focusable === void 0 ? void 0 : focusable.focus();
    }
};
TuiDropdownBoxComponent.ctorParameters = () => [
    { type: TuiDestroyService, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_DROPDOWN_DIRECTIVE,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: TuiDropdownHostComponent, decorators: [{ type: Inject, args: [AbstractTuiPortalHostComponent,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_ANIMATION_OPTIONS,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
];
__decorate([
    HostBinding('@tuiDropdownAnimation')
], TuiDropdownBoxComponent.prototype, "dropdownAnimation", void 0);
__decorate([
    ViewChild('content', { read: ElementRef })
], TuiDropdownBoxComponent.prototype, "contentElementRef", void 0);
__decorate([
    tuiPure
], TuiDropdownBoxComponent.prototype, "getContext", null);
__decorate([
    tuiPure
], TuiDropdownBoxComponent.prototype, "inModal", null);
__decorate([
    tuiPure
], TuiDropdownBoxComponent.prototype, "inOption", null);
TuiDropdownBoxComponent = __decorate([
    Component({
        selector: 'tui-dropdown-box',
        template: "<div\n    #activeZone=\"tuiActiveZone\"\n    class=\"t-wrapper\"\n    [tuiOverscroll]=\"overscroll\"\n    [tuiMode]=\"null\"\n    [tuiActiveZoneParent]=\"directive.activeZone || null\"\n>\n    <tui-scrollbar class=\"t-scroll\">\n        <div\n            tabindex=\"0\"\n            (focus)=\"onTopFocus()\"\n        ></div>\n        <div\n            #content\n            polymorpheus-outlet\n            class=\"t-content\"\n            [content]=\"directive.content\"\n            [context]=\"getContext(directive.context, activeZone)\"\n        ></div>\n        <div\n            tabindex=\"0\"\n            (focus)=\"onBottomFocus()\"\n        ></div>\n    </tui-scrollbar>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.Default,
        providers: [TuiDestroyService],
        animations: [tuiDropdownAnimation],
        styles: [":host{z-index:0;box-shadow:0 .5rem 1rem rgba(0,0,0,.16);position:absolute;top:0;left:0;display:flex;background-color:#fff;background-color:var(--tui-elevation-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-03);box-sizing:border-box}:host.ng-animating{pointer-events:none}.t-content{display:flex;flex-direction:column;max-height:100%}.t-wrapper{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.t-scroll{height:100%}"]
    }),
    __param(0, Inject(TuiDestroyService)),
    __param(1, Inject(NgZone)),
    __param(2, Inject(TUI_DROPDOWN_DIRECTIVE)),
    __param(3, Inject(WINDOW)),
    __param(4, Inject(ElementRef)),
    __param(5, Inject(AbstractTuiPortalHostComponent)),
    __param(6, Inject(TUI_ANIMATION_OPTIONS)),
    __param(7, Inject(ANIMATION_FRAME))
], TuiDropdownBoxComponent);

let TuiDropdownBoxModule = class TuiDropdownBoxModule {
};
TuiDropdownBoxModule = __decorate([
    NgModule({
        imports: [
            TuiActiveZoneModule,
            PolymorpheusModule,
            TuiOverscrollModule,
            TuiScrollbarModule,
            TuiModeModule,
        ],
        entryComponents: [TuiDropdownBoxComponent],
        declarations: [TuiDropdownBoxComponent],
        exports: [TuiDropdownBoxComponent],
    })
], TuiDropdownBoxModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDropdownBoxComponent, TuiDropdownBoxModule };
//# sourceMappingURL=taiga-ui-core-components-dropdown-box.js.map
