import { __decorate, __param } from "tslib";
import { Inject, Pipe } from '@angular/core';
import { TUI_NUMBER_FORMAT } from '@taiga-ui/core/tokens';
import { formatNumber } from '@taiga-ui/core/utils/format';
var TuiFormatNumberPipe = /** @class */ (function () {
    function TuiFormatNumberPipe(numberFormat) {
        this.numberFormat = numberFormat;
    }
    /**
     * Formats number adding thousand separators and correct decimal separator
     * padding decimal part with zeroes to given length
     * @param value number
     * @param decimalSeparator
     * @param thousandSeparator
     * @param decimalLimit number of digits of decimal part, null to keep untouched
     * @param zeroPadding enable zeros at the end of decimal part
     */
    TuiFormatNumberPipe.prototype.transform = function (value, decimalLimit, decimalSeparator, thousandSeparator, zeroPadding) {
        if (decimalLimit === void 0) { decimalLimit = null; }
        if (decimalSeparator === void 0) { decimalSeparator = this.numberFormat.decimalSeparator; }
        if (thousandSeparator === void 0) { thousandSeparator = this.numberFormat.thousandSeparator; }
        if (zeroPadding === void 0) { zeroPadding = this.numberFormat.zeroPadding; }
        return formatNumber(value, decimalLimit, decimalSeparator, thousandSeparator, zeroPadding);
    };
    TuiFormatNumberPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [TUI_NUMBER_FORMAT,] }] }
    ]; };
    TuiFormatNumberPipe = __decorate([
        Pipe({ name: "tuiFormatNumber" }),
        __param(0, Inject(TUI_NUMBER_FORMAT))
    ], TuiFormatNumberPipe);
    return TuiFormatNumberPipe;
}());
export { TuiFormatNumberPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LW51bWJlci5waXBlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2NvcmUvcGlwZXMvZm9ybWF0LW51bWJlci8iLCJzb3VyY2VzIjpbImZvcm1hdC1udW1iZXIucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQWdCLE1BQU0sZUFBZSxDQUFDO0FBRTFELE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3hELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUd6RDtJQUNJLDZCQUVxQixZQUFxQztRQUFyQyxpQkFBWSxHQUFaLFlBQVksQ0FBeUI7SUFDdkQsQ0FBQztJQUVKOzs7Ozs7OztPQVFHO0lBQ0gsdUNBQVMsR0FBVCxVQUNJLEtBQWEsRUFDYixZQUFrQyxFQUNsQyxnQkFBNkQsRUFDN0QsaUJBQStELEVBQy9ELFdBQW9EO1FBSHBELDZCQUFBLEVBQUEsbUJBQWtDO1FBQ2xDLGlDQUFBLEVBQUEsbUJBQTJCLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCO1FBQzdELGtDQUFBLEVBQUEsb0JBQTRCLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCO1FBQy9ELDRCQUFBLEVBQUEsY0FBdUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXO1FBRXBELE9BQU8sWUFBWSxDQUNmLEtBQUssRUFDTCxZQUFZLEVBQ1osZ0JBQWdCLEVBQ2hCLGlCQUFpQixFQUNqQixXQUFXLENBQ2QsQ0FBQztJQUNOLENBQUM7O2dEQTNCSSxNQUFNLFNBQUMsaUJBQWlCOztJQUZwQixtQkFBbUI7UUFEL0IsSUFBSSxDQUFDLEVBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFDLENBQUM7UUFHdkIsV0FBQSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtPQUZyQixtQkFBbUIsQ0E4Qi9CO0lBQUQsMEJBQUM7Q0FBQSxBQTlCRCxJQThCQztTQTlCWSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdCwgUGlwZSwgUGlwZVRyYW5zZm9ybX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1R1aU51bWJlckZvcm1hdFNldHRpbmdzfSBmcm9tICdAdGFpZ2EtdWkvY29yZS9pbnRlcmZhY2VzJztcbmltcG9ydCB7VFVJX05VTUJFUl9GT1JNQVR9IGZyb20gJ0B0YWlnYS11aS9jb3JlL3Rva2Vucyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnQHRhaWdhLXVpL2NvcmUvdXRpbHMvZm9ybWF0JztcblxuQFBpcGUoe25hbWU6IGB0dWlGb3JtYXROdW1iZXJgfSlcbmV4cG9ydCBjbGFzcyBUdWlGb3JtYXROdW1iZXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoVFVJX05VTUJFUl9GT1JNQVQpXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgbnVtYmVyRm9ybWF0OiBUdWlOdW1iZXJGb3JtYXRTZXR0aW5ncyxcbiAgICApIHt9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIG51bWJlciBhZGRpbmcgdGhvdXNhbmQgc2VwYXJhdG9ycyBhbmQgY29ycmVjdCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAqIHBhZGRpbmcgZGVjaW1hbCBwYXJ0IHdpdGggemVyb2VzIHRvIGdpdmVuIGxlbmd0aFxuICAgICAqIEBwYXJhbSB2YWx1ZSBudW1iZXJcbiAgICAgKiBAcGFyYW0gZGVjaW1hbFNlcGFyYXRvclxuICAgICAqIEBwYXJhbSB0aG91c2FuZFNlcGFyYXRvclxuICAgICAqIEBwYXJhbSBkZWNpbWFsTGltaXQgbnVtYmVyIG9mIGRpZ2l0cyBvZiBkZWNpbWFsIHBhcnQsIG51bGwgdG8ga2VlcCB1bnRvdWNoZWRcbiAgICAgKiBAcGFyYW0gemVyb1BhZGRpbmcgZW5hYmxlIHplcm9zIGF0IHRoZSBlbmQgb2YgZGVjaW1hbCBwYXJ0XG4gICAgICovXG4gICAgdHJhbnNmb3JtKFxuICAgICAgICB2YWx1ZTogbnVtYmVyLFxuICAgICAgICBkZWNpbWFsTGltaXQ6IG51bWJlciB8IG51bGwgPSBudWxsLFxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiBzdHJpbmcgPSB0aGlzLm51bWJlckZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgICB0aG91c2FuZFNlcGFyYXRvcjogc3RyaW5nID0gdGhpcy5udW1iZXJGb3JtYXQudGhvdXNhbmRTZXBhcmF0b3IsXG4gICAgICAgIHplcm9QYWRkaW5nOiBib29sZWFuID0gdGhpcy5udW1iZXJGb3JtYXQuemVyb1BhZGRpbmcsXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGVjaW1hbExpbWl0LFxuICAgICAgICAgICAgZGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgICAgIHRob3VzYW5kU2VwYXJhdG9yLFxuICAgICAgICAgICAgemVyb1BhZGRpbmcsXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19