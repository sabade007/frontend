import { __decorate, __param } from "tslib";
import { ChangeDetectorRef, Directive, ElementRef, forwardRef, HostListener, Inject, Input, Optional, Output, Pipe, PipeTransform, Self, } from '@angular/core';
import { NgControl } from '@angular/forms';
import { AbstractTuiControl, clamp, isNativeFocused, tuiAssert, tuiDefaultProp, typedFromEvent, } from '@taiga-ui/cdk';
import { tuiCheckKeyStepsHaveMinMaxPercents, tuiKeyStepValueToPercentage, tuiPercentageToKeyStepValue, } from '@taiga-ui/kit/utils';
import { map } from 'rxjs/operators';
import { TuiSliderComponent } from '../slider.component';
// @dynamic
let TuiSliderKeyStepsDirective = class TuiSliderKeyStepsDirective extends AbstractTuiControl {
    constructor(control, changeDetectorRef, elementRef, slider) {
        super(control, changeDetectorRef);
        this.elementRef = elementRef;
        this.slider = slider;
        this.keySteps = [];
        this.keyStepsInput = typedFromEvent(this.elementRef.nativeElement, 'input').pipe(map(() => this.controlValue));
    }
    get nativeFocusableElement() {
        return this.computedDisabled ? null : this.elementRef.nativeElement;
    }
    get focused() {
        return isNativeFocused(this.nativeFocusableElement);
    }
    get min() {
        var _a;
        return ((_a = this.keySteps[0]) === null || _a === void 0 ? void 0 : _a[1]) || 0;
    }
    get max() {
        var _a;
        return ((_a = this.keySteps[this.keySteps.length - 1]) === null || _a === void 0 ? void 0 : _a[1]) || 100;
    }
    get controlValue() {
        return tuiPercentageToKeyStepValue(this.slider.valuePercentage, this.keySteps);
    }
    /**
     * TODO: 3.0
     * ___
     * Also add @HostListener(`input`): to be similar to
     * {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/range_value_accessor.ts#L47-L48 RangeValueAccessor}
     * ___
     * Remove {@link keyStepsInput}
     */
    updateControlValue() {
        this.updateValue(this.controlValue);
    }
    writeValue(controlValue) {
        if (controlValue === null) {
            return;
        }
        const clampedControlValue = clamp(controlValue, this.min, this.max);
        tuiAssert.assert(controlValue === clampedControlValue, '\n[SliderKeySteps]: You cannot programmatically set value which is less/more than min/max');
        this.slider.value = this.transformToNativeValue(clampedControlValue);
    }
    getFallbackValue() {
        return 0;
    }
    transformToNativeValue(controlValue) {
        const { min, max } = this.slider;
        const newValuePercentage = tuiKeyStepValueToPercentage(controlValue, this.keySteps);
        return (newValuePercentage * (max - min)) / 100 + min;
    }
};
TuiSliderKeyStepsDirective.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: TuiSliderComponent, decorators: [{ type: Inject, args: [forwardRef(() => TuiSliderComponent),] }] }
];
__decorate([
    Input(),
    tuiDefaultProp(tuiCheckKeyStepsHaveMinMaxPercents, 'Should contain min and max values')
], TuiSliderKeyStepsDirective.prototype, "keySteps", void 0);
__decorate([
    Output()
], TuiSliderKeyStepsDirective.prototype, "keyStepsInput", void 0);
__decorate([
    HostListener('change')
], TuiSliderKeyStepsDirective.prototype, "updateControlValue", null);
TuiSliderKeyStepsDirective = __decorate([
    Directive({
        selector: 'input[tuiSlider][keySteps]',
        host: {
            '[attr.aria-valuenow]': 'safeCurrentValue',
            '[attr.aria-valuemin]': 'min',
            '[attr.aria-valuemax]': 'max',
        },
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(ElementRef)),
    __param(3, Inject(forwardRef(() => TuiSliderComponent)))
], TuiSliderKeyStepsDirective);
export { TuiSliderKeyStepsDirective };
/**
 * @deprecated DONT USE IT! It is just temporary solution for internal purposes only. We will delete it in next major release.
 * TODO delete it in v3.0
 *
 */
let TuiSliderTickLabelPipe = class TuiSliderTickLabelPipe {
    transform(tickIndex, totalSegments, keySteps) {
        const percentage = (100 / totalSegments) * tickIndex;
        return tuiPercentageToKeyStepValue(percentage, keySteps);
    }
};
TuiSliderTickLabelPipe = __decorate([
    Pipe({ name: 'tuiSliderTickLabel' })
], TuiSliderTickLabelPipe);
export { TuiSliderTickLabelPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLWtleS1zdGVwcy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkva2l0L2NvbXBvbmVudHMvc2xpZGVyLyIsInNvdXJjZXMiOlsiaGVscGVycy9zbGlkZXIta2V5LXN0ZXBzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNILGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFVBQVUsRUFDVixZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksRUFDSixhQUFhLEVBQ2IsSUFBSSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6QyxPQUFPLEVBQ0gsa0JBQWtCLEVBQ2xCLEtBQUssRUFDTCxlQUFlLEVBQ2YsU0FBUyxFQUNULGNBQWMsRUFFZCxjQUFjLEdBQ2pCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFDSCxrQ0FBa0MsRUFDbEMsMkJBQTJCLEVBQzNCLDJCQUEyQixHQUM5QixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBQyxHQUFHLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUVuQyxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUV2RCxXQUFXO0FBU1gsSUFBYSwwQkFBMEIsR0FBdkMsTUFBYSwwQkFDVCxTQUFRLGtCQUEwQjtJQW1DbEMsWUFJSSxPQUF5QixFQUNFLGlCQUFvQyxFQUMxQixVQUF3QyxFQUU1RCxNQUEwQjtRQUUzQyxLQUFLLENBQUMsT0FBTyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFKRyxlQUFVLEdBQVYsVUFBVSxDQUE4QjtRQUU1RCxXQUFNLEdBQU4sTUFBTSxDQUFvQjtRQW5DL0MsYUFBUSxHQUFnQixFQUFFLENBQUM7UUFHM0Isa0JBQWEsR0FBRyxjQUFjLENBQUMsSUFBSSxD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QUs7U0FDaEM7S0FDSixDQUFDO0lBc0NPLFdBQUEsUUFBUSxFQUFFLENBQUE7SUFDVixXQUFBLElBQUksRUFBRSxDQUFBO0lBQ04sV0FBQSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7SUFFakIsV0FBQSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtJQUN6QixXQUFBLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUNsQixXQUFBLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFBO0dBM0N4QywwQkFBMEIsQ0EwRnRDO1NBMUZZLDBCQUEwQjtBQTRGdkM7Ozs7R0FJRztBQUVILElBQWEsc0JBQXNCLEdBQW5DLE1BQWEsc0JBQXNCO0lBQy9CLFNBQVMsQ0FBQyxTQUFpQixFQUFFLGFBQXFCLEVBQUUsUUFBcUI7UUFDckUsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEdBQUcsYUFBYSxDQUFDLEdBQUcsU0FBUyxDQUFDO1FBRXJELE9BQU8sMkJBQTJCLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzdELENBQUM7Q0FDSixDQUFBO0FBTlksc0JBQXNCO0lBRGxDLElBQUksQ0FBQyxFQUFDLElBQUksRUFBRSxvQkFBb0IsRUFBQyxDQUFDO0dBQ3RCLHNCQUFzQixDQU1sQztTQU5ZLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgZm9yd2FyZFJlZixcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBQaXBlLFxuICAgIFBpcGVUcmFuc2Zvcm0sXG4gICAgU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05nQ29udHJvbH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgICBBYnN0cmFjdFR1aUNvbnRyb2wsXG4gICAgY2xhbXAsXG4gICAgaXNOYXRpdmVGb2N1c2VkLFxuICAgIHR1aUFzc2VydCxcbiAgICB0dWlEZWZhdWx0UHJvcCxcbiAgICBUdWlGb2N1c2FibGVFbGVtZW50QWNjZXNzb3IsXG4gICAgdHlwZWRGcm9tRXZlbnQsXG59IGZyb20gJ0B0YWlnYS11aS9jZGsnO1xuaW1wb3J0IHtUdWlLZXlTdGVwc30gZnJvbSAnQHRhaWdhLXVpL2tpdC90eXBlcyc7XG5pbXBvcnQge1xuICAgIHR1aUNoZWNrS2V5U3RlcHNIYXZlTWluTWF4UGVyY2VudHMsXG4gICAgdHVpS2V5U3RlcFZhbHVlVG9QZXJjZW50YWdlLFxuICAgIHR1aVBlcmNlbnRhZ2VUb0tleVN0ZXBWYWx1ZSxcbn0gZnJvbSAnQHRhaWdhLXVpL2tpdC91dGlscyc7XG5pbXBvcnQge21hcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1R1aVNsaWRlckNvbXBvbmVudH0gZnJvbSAnLi4vc2xpZGVyLmNvbXBvbmVudCc7XG5cbi8vIEBkeW5hbWljXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2lucHV0W3R1aVNsaWRlcl1ba2V5U3RlcHNdJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbm93XSc6ICdzYWZlQ3VycmVudFZhbHVlJyxcbiAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtaW5dJzogJ21pbicsXG4gICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIFR1aVNsaWRlcktleVN0ZXBzRGlyZWN0aXZlXG4gICAgZXh0ZW5kcyBBYnN0cmFjdFR1aUNvbnRyb2w8bnVtYmVyPlxuICAgIGltcGxlbWVudHMgVHVpRm9jdXNhYmxlRWxlbWVudEFjY2Vzc29yXG57XG4gICAgQElucHV0KClcbiAgICBAdHVpRGVmYXVsdFByb3AoXG4gICAgICAgIHR1aUNoZWNrS2V5U3RlcHNIYXZlTWluTWF4UGVyY2VudHMsXG4gICAgICAgICdTaG91bGQgY29udGFpbiBtaW4gYW5kIG1heCB2YWx1ZXMnLFxuICAgIClcbiAgICBrZXlTdGVwczogVHVpS2V5U3RlcHMgPSBbXTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGtleVN0ZXBzSW5wdXQgPSB0eXBlZEZyb21FdmVudCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2lucHV0JykucGlwZShcbiAgICAgICAgbWFwKCgpID0+IHRoaXMuY29udHJvbFZhbHVlKSxcbiAgICApO1xuXG4gICAgZ2V0IG5hdGl2ZUZvY3VzYWJsZUVsZW1lbnQoKTogSFRNTElucHV0RWxlbWVudCB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZERpc2FibGVkID8gbnVsbCA6IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIGdldCBmb2N1c2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNOYXRpdmVGb2N1c2VkKHRoaXMubmF0aXZlRm9jdXNhYmxlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgZ2V0IG1pbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlTdGVwc1swXT8uWzFdIHx8IDA7XG4gICAgfVxuXG4gICAgZ2V0IG1heCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlTdGVwc1t0aGlzLmtleVN0ZXBzLmxlbmd0aCAtIDFdPy5bMV0gfHwgMTAwO1xuICAgIH1cblxuICAgIGdldCBjb250cm9sVmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHR1aVBlcmNlbnRhZ2VUb0tleVN0ZXBWYWx1ZSh0aGlzLnNsaWRlci52YWx1ZVBlcmNlbnRhZ2UsIHRoaXMua2V5U3RlcHMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBAT3B0aW9uYWwoKVxuICAgICAgICBAU2VsZigpXG4gICAgICAgIEBJbmplY3QoTmdDb250cm9sKVxuICAgICAgICBjb250cm9sOiBOZ0NvbnRyb2wgfCBudWxsLFxuICAgICAgICBASW5qZWN0KENoYW5nZURldGVjdG9yUmVmKSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoRWxlbWVudFJlZikgcHJpdmF0ZSByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxJbnB1dEVsZW1lbnQ+LFxuICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gVHVpU2xpZGVyQ29tcG9uZW50KSlcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzbGlkZXI6IFR1aVNsaWRlckNvbXBvbmVudCxcbiAgICApIHtcbiAgICAgICAgc3VwZXIoY29udHJvbCwgY2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRPRE86IDMuMFxuICAgICAqIF9fX1xuICAgICAqIEFsc28gYWRkIEBIb3N0TGlzdGVuZXIoYGlucHV0YCk6IHRvIGJlIHNpbWlsYXIgdG9cbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iL21haW4vcGFja2FnZXMvZm9ybXMvc3JjL2RpcmVjdGl2ZXMvcmFuZ2VfdmFsdWVfYWNjZXNzb3IudHMjTDQ3LUw0OCBSYW5nZVZhbHVlQWNjZXNzb3J9XG4gICAgICogX19fXG4gICAgICogUmVtb3ZlIHtAbGluayBrZXlTdGVwc0lucHV0fVxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2NoYW5nZScpXG4gICAgdXBkYXRlQ29udHJvbFZhbHVlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuY29udHJvbFZhbHVlKTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKGNvbnRyb2xWYWx1ZTogbnVtYmVyIHwgbnVsbCk6IHZvaWQge1xuICAgICAgICBpZiAoY29udHJvbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGFtcGVkQ29udHJvbFZhbHVlID0gY2xhbXAoY29udHJvbFZhbHVlLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoXG4gICAgICAgICAgICBjb250cm9sVmFsdWUgPT09IGNsYW1wZWRDb250cm9sVmFsdWUsXG4gICAgICAgICAgICAnXFxuW1NsaWRlcktleVN0ZXBzXTogWW91IGNhbm5vdCBwcm9ncmFtbWF0aWNhbGx5IHNldCB2YWx1ZSB3aGljaCBpcyBsZXNzL21vcmUgdGhhbiBtaW4vbWF4JyxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnNsaWRlci52YWx1ZSA9IHRoaXMudHJhbnNmb3JtVG9OYXRpdmVWYWx1ZShjbGFtcGVkQ29udHJvbFZhbHVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0RmFsbGJhY2tWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRyYW5zZm9ybVRvTmF0aXZlVmFsdWUoY29udHJvbFZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5zbGlkZXI7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlUGVyY2VudGFnZSA9IHR1aUtleVN0ZXBWYWx1ZVRvUGVyY2VudGFnZShcbiAgICAgICAgICAgIGNvbnRyb2xWYWx1ZSxcbiAgICAgICAgICAgIHRoaXMua2V5U3RlcHMsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIChuZXdWYWx1ZVBlcmNlbnRhZ2UgKiAobWF4IC0gbWluKSkgLyAxMDAgKyBtaW47XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIERPTlQgVVNFIElUISBJdCBpcyBqdXN0IHRlbXBvcmFyeSBzb2x1dGlvbiBmb3IgaW50ZXJuYWwgcHVycG9zZXMgb25seS4gV2Ugd2lsbCBkZWxldGUgaXQgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICogVE9ETyBkZWxldGUgaXQgaW4gdjMuMFxuICpcbiAqL1xuQFBpcGUoe25hbWU6ICd0dWlTbGlkZXJUaWNrTGFiZWwnfSlcbmV4cG9ydCBjbGFzcyBUdWlTbGlkZXJUaWNrTGFiZWxQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtKHRpY2tJbmRleDogbnVtYmVyLCB0b3RhbFNlZ21lbnRzOiBudW1iZXIsIGtleVN0ZXBzOiBUdWlLZXlTdGVwcyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAoMTAwIC8gdG90YWxTZWdtZW50cykgKiB0aWNrSW5kZXg7XG5cbiAgICAgICAgcmV0dXJuIHR1aVBlcmNlbnRhZ2VUb0tleVN0ZXBWYWx1ZShwZXJjZW50YWdlLCBrZXlTdGVwcyk7XG4gICAgfVxufVxuIl19