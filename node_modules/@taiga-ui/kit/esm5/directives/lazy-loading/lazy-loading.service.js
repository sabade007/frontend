import { __decorate, __extends, __param, __read } from "tslib";
import { ChangeDetectorRef, Inject, Injectable } from '@angular/core';
import { IntersectionObserverService } from '@ng-web-apis/intersection-observer';
import { TuiDestroyService, watch } from '@taiga-ui/cdk';
import { Observable, of, Subject } from 'rxjs';
import { catchError, filter, mapTo, switchMap, take, takeUntil } from 'rxjs/operators';
var TuiLazyLoadingService = /** @class */ (function (_super) {
    __extends(TuiLazyLoadingService, _super);
    function TuiLazyLoadingService(changeDetectorRef, destroy$, intersections$) {
        var _this = _super.call(this, function (subscriber) {
            return _this.src$
                .pipe(switchMap(function (src) {
                return intersections$.pipe(filter(function (_a) {
                    var _b = __read(_a, 1), isIntersecting = _b[0].isIntersecting;
                    return isIntersecting;
                }), mapTo(src), catchError(function () { return of(src); }), watch(changeDetectorRef), take(1));
            }), takeUntil(destroy$))
                .subscribe(subscriber);
        }) || this;
        _this.src$ = new Subject();
        return _this;
    }
    TuiLazyLoadingService.prototype.next = function (src) {
        this.src$.next(src);
    };
    TuiLazyLoadingService.ctorParameters = function () { return [
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [IntersectionObserverService,] }] }
    ]; };
    TuiLazyLoadingService = __decorate([
        Injectable(),
        __param(0, Inject(ChangeDetectorRef)),
        __param(1, Inject(TuiDestroyService)),
        __param(2, Inject(IntersectionObserverService))
    ], TuiLazyLoadingService);
    return TuiLazyLoadingService;
}(Observable));
export { TuiLazyLoadingService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1sb2FkaW5nLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkva2l0L2RpcmVjdGl2ZXMvbGF6eS1sb2FkaW5nLyIsInNvdXJjZXMiOlsibGF6eS1sb2FkaW5nLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRXBFLE9BQU8sRUFBQywyQkFBMkIsRUFBQyxNQUFNLG9DQUFvQyxDQUFDO0FBQy9FLE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDdkQsT0FBTyxFQUFDLFVBQVUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBR3JGO0lBQTJDLHlDQUFvQztJQUczRSwrQkFDK0IsaUJBQW9DLEVBQ3BDLFFBQTBCLEVBRXJELGNBQXVEO1FBSjNELFlBTUksa0JBQU0sVUFBQSxVQUFVO1lBQ1osT0FBQSxLQUFJLENBQUMsSUFBSTtpQkFDSixJQUFJLENBQ0QsU0FBUyxDQUFDLFVBQUEsR0FBRztnQkFDVCxPQUFBLGNBQWMsQ0FBQyxJQUFJLENBQ2YsTUFBTSxDQUFDLFVBQUMsRUFBa0I7d0JBQWxCLGtCQUFrQixFQUFoQixxQ0FBYztvQkFBTyxPQUFBLGNBQWM7Z0JBQWQsQ0FBYyxDQUFDLEVBQzlDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFDVixVQUFVLENBQUMsY0FBTSxPQUFBLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBUCxDQUFPLENBQUMsRUFDekIsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQ3hCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FDVjtZQU5ELENBTUMsQ0FDSixFQUNELFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDdEI7aUJBQ0EsU0FBUyxDQUFDLFVBQVUsQ0FBQztRQWIxQixDQWEwQixDQUM3QixTQUNKO1FBeEJnQixVQUFJLEdBQUcsSUFBSSxPQUFPLEVBQTRCLENBQUM7O0lBd0JoRSxDQUFDO0lBRUQsb0NBQUksR0FBSixVQUFLLEdBQTZCO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7O2dCQXpCaUQsaUJBQWlCLHVCQUE5RCxNQUFNLFNBQUMsaUJBQWlCO2dCQUNZLFVBQVUsdUJBQTlDLE1BQU0sU0FBQyxpQkFBaUI7Z0JBRVQsVUFBVSx1QkFEekIsTUFBTSxTQUFDLDJCQUEyQjs7SUFOOUIscUJBQXFCO1FBRGpDLFVBQVUsRUFBRTtRQUtKLFdBQUEsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUE7UUFDekIsV0FBQSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtRQUN6QixXQUFBLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxDQUFBO09BTi9CLHFCQUFxQixDQThCakM7SUFBRCw0QkFBQztDQUFBLEFBOUJELENBQTJDLFVBQVUsR0E4QnBEO1NBOUJZLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q2hhbmdlRGV0ZWN0b3JSZWYsIEluamVjdCwgSW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1NhZmVSZXNvdXJjZVVybH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQge0ludGVyc2VjdGlvbk9ic2VydmVyU2VydmljZX0gZnJvbSAnQG5nLXdlYi1hcGlzL2ludGVyc2VjdGlvbi1vYnNlcnZlcic7XG5pbXBvcnQge1R1aURlc3Ryb3lTZXJ2aWNlLCB3YXRjaH0gZnJvbSAnQHRhaWdhLXVpL2Nkayc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mLCBTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7Y2F0Y2hFcnJvciwgZmlsdGVyLCBtYXBUbywgc3dpdGNoTWFwLCB0YWtlLCB0YWtlVW50aWx9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR1aUxhenlMb2FkaW5nU2VydmljZSBleHRlbmRzIE9ic2VydmFibGU8U2FmZVJlc291cmNlVXJsIHwgc3RyaW5nPiB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzcmMkID0gbmV3IFN1YmplY3Q8U2FmZVJlc291cmNlVXJsIHwgc3RyaW5nPigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoQ2hhbmdlRGV0ZWN0b3JSZWYpIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgQEluamVjdChUdWlEZXN0cm95U2VydmljZSkgZGVzdHJveSQ6IE9ic2VydmFibGU8dm9pZD4sXG4gICAgICAgIEBJbmplY3QoSW50ZXJzZWN0aW9uT2JzZXJ2ZXJTZXJ2aWNlKVxuICAgICAgICBpbnRlcnNlY3Rpb25zJDogT2JzZXJ2YWJsZTxJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5W10+LFxuICAgICkge1xuICAgICAgICBzdXBlcihzdWJzY3JpYmVyID0+XG4gICAgICAgICAgICB0aGlzLnNyYyRcbiAgICAgICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoTWFwKHNyYyA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucyQucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIoKFt7aXNJbnRlcnNlY3Rpbmd9XSkgPT4gaXNJbnRlcnNlY3RpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFRvKHNyYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoKSA9PiBvZihzcmMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXRjaChjaGFuZ2VEZXRlY3RvclJlZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChkZXN0cm95JCksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoc3Vic2NyaWJlciksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbmV4dChzcmM6IFNhZmVSZXNvdXJjZVVybCB8IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnNyYyQubmV4dChzcmMpO1xuICAgIH1cbn1cbiJdfQ==