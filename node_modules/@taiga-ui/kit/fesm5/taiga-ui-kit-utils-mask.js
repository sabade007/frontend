import { TuiDay, DATE_FILLER_LENGTH, DATE_RANGE_FILLER_LENGTH, TuiDayRange, RANGE_SEPARATOR_CHAR, tuiAssert, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';
import { __assign, __read, __spread } from 'tslib';
import { MAX_TIME_VALUES, DATE_TIME_SEPARATOR } from '@taiga-ui/kit/constants';
import { TUI_DIGIT_REGEXP } from '@taiga-ui/core';

/**
 * @deprecated: use {@link tuiNormalizeDateValue} instead
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function normalizeDateValue(dateValue, _a) {
    var value = _a.value, min = _a.min, max = _a.max, dateFormat = _a.dateFormat, dateSeparator = _a.dateSeparator;
    return value && value.toString(dateFormat, dateSeparator) === dateValue
        ? dateValue
        : TuiDay.normalizeParse(dateValue, dateFormat)
            .dayLimit(min, max)
            .toString(dateFormat, dateSeparator);
}
function tuiCreateAutoCorrectedDatePipe(config) {
    return function (value) {
        if (value.length !== DATE_FILLER_LENGTH) {
            return { value: value };
        }
        return {
            value: normalizeDateValue(value, config),
        };
    };
}
var tuiNormalizeDateValue = normalizeDateValue;

function parseWithLimit(value, config) {
    return TuiDay.normalizeParse(value.slice(0, DATE_FILLER_LENGTH), config.dateFormat).dayLimit(config.min, config.max);
}
function processRawValue(value, config) {
    var dateFormat = config.dateFormat, dateSeparator = config.dateSeparator;
    switch (value.length) {
        case DATE_FILLER_LENGTH:
            return parseWithLimit(value, config).toString(dateFormat, dateSeparator);
        case DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length:
            return (parseWithLimit(value, config).toString(dateFormat, dateSeparator) +
                RANGE_SEPARATOR_CHAR);
        case DATE_RANGE_FILLER_LENGTH:
            return config.value &&
                config.value.toString(dateFormat, dateSeparator) === value
                ? value
                : TuiDayRange.sort(parseWithLimit(value.slice(0, DATE_FILLER_LENGTH), config), parseWithLimit(value.slice(DATE_FILLER_LENGTH + RANGE_SEPARATOR_CHAR.length), config)).toString(dateFormat, dateSeparator);
        default:
            return value;
    }
}
/**
 * Normalizes date in formatted string
 *
 * Normalizes when:
 *
 * 1. It is a single date
 * 2. It is a single date and a separator
 * 3. It is two dates and a separator between them
 *
 * In **other** cases, the value does not change.
 *
 * @param config with min and max date
 * @return mask pipe handler that handles `min` and `max`
 */
function tuiCreateAutoCorrectedDateRangePipe(config) {
    return function (value) { return ({ value: processRawValue(value, config) }); };
}

/**
 * Adjusts the entered time by omitting only suitable values for hours and minutes
 * @returns time as a string
 */
function tuiCreateAutoCorrectedTimePipe(timeMode, maxValues) {
    if (timeMode === void 0) { timeMode = "HH:MM"; }
    if (maxValues === void 0) { maxValues = {}; }
    var timeFormatArray = ["HH", "MM", "SS", "MS"];
    var safeValues = __assign(__assign({}, MAX_TIME_VALUES), maxValues);
    return function (conformedValue) {
        var indexesOfPipedChars = [];
        var conformedValueArr = conformedValue.split("");
        timeFormatArray.forEach(function (format) {
            var position = timeMode.indexOf(format);
            var maxFirstDigit = parseInt(String(safeValues[format]).slice(0, 1), 10);
            if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
                conformedValueArr[position + 1] = conformedValueArr[position];
                conformedValueArr[position] = "0";
                indexesOfPipedChars.push(position);
            }
        });
        var isInvalid = timeFormatArray.some(function (format) {
            return parseInt(conformedValue.slice(timeMode.indexOf(format), 2), 10) >
                safeValues[format];
        });
        return isInvalid
            ? false
            : {
                value: conformedValueArr.join(""),
                indexesOfPipedChars: indexesOfPipedChars,
            };
    };
}

function tuiCreateAutoCorrectedDateTimePipe(configs) {
    var timePipe = tuiCreateAutoCorrectedTimePipe(configs.timeMode);
    return function (value) {
        if (value.length < DATE_FILLER_LENGTH) {
            return { value: value };
        }
        var _a = __read(value.split(DATE_TIME_SEPARATOR), 2), date = _a[0], time = _a[1];
        var formattedDate = normalizeDateValue(date, configs);
        if (!time) {
            return { value: formattedDate };
        }
        var pipedTime = timePipe(time, {});
        if (!pipedTime || typeof pipedTime === "string") {
            return false;
        }
        return {
            value: "" + formattedDate + DATE_TIME_SEPARATOR + pipedTime.value,
            indexesOfPipedChars: pipedTime.indexesOfPipedChars
                ? pipedTime.indexesOfPipedChars.map(function (i) { return i + date.length + 2; })
                : undefined,
        };
    };
}

var TWO_DIGITS = new Array(2).fill(TUI_DIGIT_REGEXP);
var FOUR_DIGITS = new Array(4).fill(TUI_DIGIT_REGEXP);
function tuiCreateDateMask(mode, separator) {
    tuiAssert.assert(separator.length === 1, "Separator should consist of only 1 symbol");
    switch (mode) {
        case "YMD":
            return __spread(FOUR_DIGITS, [separator], TWO_DIGITS, [separator], TWO_DIGITS);
        case "MDY":
        case "DMY":
        default:
            return __spread(TWO_DIGITS, [separator], TWO_DIGITS, [separator], FOUR_DIGITS);
    }
}

function tuiCreateDateRangeMask(dateMode, dateSeparator) {
    tuiAssert.assert(dateSeparator.length === 1, "Separator should consist of only 1 symbol");
    var dateMask = tuiCreateDateMask(dateMode, dateSeparator);
    return __spread(dateMask, [
        CHAR_NO_BREAK_SPACE,
        CHAR_EN_DASH,
        CHAR_NO_BREAK_SPACE
    ], dateMask);
}

function tuiCreateTimePartMask(maxPartValue, prefix) {
    var length = String(maxPartValue).length;
    var regExp = new Array(length).fill(TUI_DIGIT_REGEXP);
    if (prefix) {
        regExp.unshift(prefix);
    }
    return regExp;
}
function tuiCreateTimeMask(mode, maxValues) {
    if (maxValues === void 0) { maxValues = {}; }
    var _a = __assign(__assign({}, MAX_TIME_VALUES), maxValues), HH = _a.HH, MM = _a.MM, SS = _a.SS, MS = _a.MS;
    return __spread(tuiCreateTimePartMask(HH), tuiCreateTimePartMask(MM, ":"), (mode.includes("HH:MM:SS") ? tuiCreateTimePartMask(SS, ":") : []), (mode === "HH:MM:SS.MSS" ? tuiCreateTimePartMask(MS, ".") : []));
}

/**
 * Generated bundle index. Do not edit.
 */

export { normalizeDateValue, tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateDateMask, tuiCreateDateRangeMask, tuiCreateTimeMask, tuiNormalizeDateValue };
//# sourceMappingURL=taiga-ui-kit-utils-mask.js.map
