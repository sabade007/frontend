import { __extends, __spread, __decorate, __param } from 'tslib';
import { Input, HostBinding, Directive, ChangeDetectorRef, Inject, ViewChild, ElementRef } from '@angular/core';
import { tuiDefaultProp, tuiPure, AbstractTuiControl, typedFromEvent, tuiAssertIsHTMLElement, clamp, round, quantize, setNativeFocused, nonNegativeFiniteAssertion } from '@taiga-ui/cdk';
import { tuiPluralizeToICU } from '@taiga-ui/core';
import { NgControl } from '@angular/forms';
import { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';
import { TUI_FROM_TO_TEXTS } from '@taiga-ui/kit/tokens';
import { Subject, race, Observable } from 'rxjs';
import { map, switchMap, takeUntil } from 'rxjs/operators';

// eslint-disable-next-line @typescript-eslint/naming-convention
function quantumAssertion(quantum) {
    return quantum > 0;
}
/**
 * @internal
 * @deprecated TODO: 3.0 delete me after `InputSlider` and `InputRange` stop using it
 */
var AbstractTuiInputSlider = /** @class */ (function (_super) {
    __extends(AbstractTuiInputSlider, _super);
    function AbstractTuiInputSlider() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.min = 0;
        _this.max = Infinity;
        /**
         * @deprecated This input-property will be deleted in next major update.
         * Use `valueContent` for `InputSlider`.
         * Use `leftValueContent` for `InputRange`.
         * ___
         * TODO remove in v3.0.
         * Dont forget to delete backward-compatibility helpers inside `InputSlider` and `InputRange`:
         *** {@link legacyMinMaxLabel}
         */
        _this.minLabel = "";
        /**
         * @deprecated This input-property will be deleted in next major update.
         * Use `valueContent` for `InputSlider`.
         * Use `rightValueContent` for `InputRange`.
         * ___
         * TODO remove in v3.0.
         * Dont forget to delete backward-compatibility helpers inside `InputSlider` and `InputRange`:
         *** {@link legacyMinMaxLabel}
         */
        _this.maxLabel = "";
        _this.segments = 0;
        _this.steps = 0;
        _this.quantum = 1;
        _this.keySteps = null;
        /**
         * @deprecated use `tuiTextfieldSize` instead
         * TODO delete in v3.0
         */
        _this.size = "l";
        /**
         * @deprecated replace by input-property {@link pluralize} in v3.0
         */
        _this.pluralizeMap = null;
        /** @deprecated TODO remove in v3.0 */
        _this.segmentsPluralizeMap = null;
        /** @deprecated TODO remove in v3.0 */
        _this.pluralizeMapFallback = {
            one: "",
            few: "",
            many: "",
            other: "",
        };
        return _this;
    }
    Object.defineProperty(AbstractTuiInputSlider.prototype, "pluralize", {
        // TODO: remove setter in v3.0:
        set: function (pluralize) {
            this.pluralizeMap = Array.isArray(pluralize)
                ? tuiPluralizeToICU(pluralize)
                : pluralize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiInputSlider.prototype, "segmentsPluralize", {
        /**
         * @deprecated This input-property will be deleted in next major update.
         * You can create ticks labels below this input by yourself. It is easy!
         * Mixin `tui-slider-ticks-labels` will help with it. See examples in demo page `InputSlider`.
         * ___
         * TODO remove in v3.0.
         * Dont forget to delete:
         *** {@link segmentsPluralizeMap}
         *** {@link getTickPrefix}
         *** TuiFormatNumberPipeModule
         *** TuiRepeatTimesModule
         */
        set: function (pluralize) {
            this.segmentsPluralizeMap = Array.isArray(pluralize)
                ? tuiPluralizeToICU(pluralize)
                : pluralize;
        },
        enumerable: true,
        configurable: true
    });
    /** @deprecated TODO remove in v3.0 */
    AbstractTuiInputSlider.prototype.getTickPrefix = function (segment, segments, texts) {
        if (segments !== 1) {
            return "";
        }
        return segment === 0 ? "" + texts[0] : "" + texts[1];
    };
    Object.defineProperty(AbstractTuiInputSlider.prototype, "segmented", {
        get: function () {
            return this.segments > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiInputSlider.prototype, "length", {
        get: function () {
            return this.max - this.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiInputSlider.prototype, "computedSteps", {
        get: function () {
            return this.steps || this.length / this.quantum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiInputSlider.prototype, "step", {
        get: function () {
            return this.length / this.computedSteps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiInputSlider.prototype, "computedKeySteps", {
        get: function () {
            return this.computePureKeySteps(this.keySteps, this.min, this.max);
        },
        enumerable: true,
        configurable: true
    });
    AbstractTuiInputSlider.prototype.onHovered = function (hovered) {
        this.updateHovered(hovered);
    };
    AbstractTuiInputSlider.prototype.computePureKeySteps = function (keySteps, min, max) {
        return __spread([[0, min]], (keySteps || []), [[100, max]]);
    };
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "min", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "max", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "minLabel", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "maxLabel", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "pluralize", null);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "segmentsPluralize", null);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "segments", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "steps", void 0);
    __decorate([
        Input(),
        tuiDefaultProp(quantumAssertion, "Quantum must be positive")
    ], AbstractTuiInputSlider.prototype, "quantum", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "keySteps", void 0);
    __decorate([
        Input(),
        HostBinding("attr.data-size"),
        tuiDefaultProp()
    ], AbstractTuiInputSlider.prototype, "size", void 0);
    __decorate([
        tuiPure
    ], AbstractTuiInputSlider.prototype, "getTickPrefix", null);
    __decorate([
        HostBinding("class._segmented")
    ], AbstractTuiInputSlider.prototype, "segmented", null);
    __decorate([
        tuiPure
    ], AbstractTuiInputSlider.prototype, "computePureKeySteps", null);
    AbstractTuiInputSlider = __decorate([
        Directive()
    ], AbstractTuiInputSlider);
    return AbstractTuiInputSlider;
}(AbstractTuiControl));

var SLIDER_KEYBOARD_STEP = 0.05;
var DOT_WIDTH = {
    s: 8,
    m: 16,
};
/**
 * @awful TODO: 3.0 remove
 * @internal
 * @dynamic
 */
var AbstractTuiSlider = /** @class */ (function (_super) {
    __extends(AbstractTuiSlider, _super);
    function AbstractTuiSlider(ngControl, changeDetectorRef, documentRef, fromToTexts$) {
        var _this = _super.call(this, ngControl, changeDetectorRef) || this;
        _this.documentRef = documentRef;
        _this.fromToTexts$ = fromToTexts$;
        // @bad TODO: handle pointer events instead of mouse and touch events
        _this.pointerDown$ = new Subject();
        _this.min = 0;
        _this.max = Infinity;
        _this.segments = 0;
        _this.steps = 0;
        _this.quantum = 0;
        _this.size = "m";
        _this.keySteps = null;
        _this.focusVisibleLeft = false;
        _this.focusVisibleRight = false;
        _this.pluralizeMap = null;
        return _this;
    }
    Object.defineProperty(AbstractTuiSlider.prototype, "pluralize", {
        // TODO: remove setter in v3.0:
        set: function (pluralize) {
            this.pluralizeMap = Array.isArray(pluralize)
                ? tuiPluralizeToICU(pluralize)
                : pluralize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiSlider.prototype, "segmented", {
        get: function () {
            return this.segments > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiSlider.prototype, "discrete", {
        get: function () {
            return this.steps > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiSlider.prototype, "length", {
        get: function () {
            return this.max - this.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiSlider.prototype, "computedStep", {
        get: function () {
            if (this.steps) {
                return 1 / this.steps;
            }
            return this.quantum ? this.quantum / this.length : SLIDER_KEYBOARD_STEP;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiSlider.prototype, "isLeftFocusable", {
        get: function () {
            return !this.disabled && this.focusable && this.right !== 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractTuiSlider.prototype, "isRightFocusable", {
        get: function () {
            return !this.disabled && this.focusable && this.left !== 100;
        },
        enumerable: true,
        configurable: true
    });
    AbstractTuiSlider.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        var mouseMoves$ = typedFromEvent(this.documentRef, "mousemove");
        var mouseUps$ = typedFromEvent(this.documentRef, "mouseup");
        var touchMoves$ = typedFromEvent(this.documentRef, "touchmove");
        var touchEnds$ = typedFromEvent(this.documentRef, "touchend");
        var isPointerDownRight;
        this.pointerDown$
            .pipe(map(function (event) {
            tuiAssertIsHTMLElement(event.currentTarget);
            var rect = event.currentTarget.getBoundingClientRect();
            var clientX = event instanceof MouseEvent
                ? event.clientX
                : event.touches[0].clientX;
            var fraction = clamp(_this.getFractionFromEvents(rect, clientX), 0, 1);
            var deltaLeft = fraction * 100 - _this.left;
            var deltaRight = fraction * 100 - 100 + _this.right;
            isPointerDownRight =
                Math.abs(deltaLeft) > Math.abs(deltaRight) ||
                    deltaRight > 0 ||
                    (_this.left === 0 && _this.right === 100);
            var calibratedFraction = clamp(_this.getCalibratedFractionFromEvents(rect, clientX, isPointerDownRight), 0, 1);
            var value = _this.getValueFromFraction(_this.fractionGuard(calibratedFraction));
            _this.processValue(value, isPointerDownRight);
            _this.processFocus(isPointerDownRight);
            return rect;
        }), switchMap(function (rect) {
            return race([touchMoves$, mouseMoves$]).pipe(map(function (event) {
                return _this.getCalibratedFractionFromEvents(rect, event instanceof MouseEvent
                    ? event.clientX
                    : event.touches[0].clientX, isPointerDownRight);
            }), takeUntil(race([mouseUps$, touchEnds$])));
        }), map(function (fraction) { return _this.fractionGuard(fraction); }))
            .subscribe(function (fraction) {
            _this.processValue(_this.getValueFromFraction(fraction), isPointerDownRight);
        });
    };
    AbstractTuiSlider.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
        this.pointerDown$.complete();
    };
    AbstractTuiSlider.prototype.onMouseDown = function (event) {
        if (this.disabled) {
            return;
        }
        event.preventDefault();
        this.pointerDown$.next(event);
    };
    AbstractTuiSlider.prototype.onTouchStart = function (event) {
        if (this.disabled) {
            return;
        }
        event.preventDefault();
        this.pointerDown$.next(event);
    };
    AbstractTuiSlider.prototype.getSegmentLabel = function (segment) {
        return round(this.getValueFromFraction(segment / this.segments), 2);
    };
    AbstractTuiSlider.prototype.getSegmentPrefix = function (segment, texts) {
        if (this.segments !== 1) {
            return "";
        }
        if (segment === 0) {
            return texts[0] + " ";
        }
        return texts[1] + " ";
    };
    AbstractTuiSlider.prototype.onActiveZone = function (active) {
        this.updateFocused(active);
    };
    AbstractTuiSlider.prototype.onLeftFocusVisible = function (focusVisible) {
        this.focusVisibleLeft = focusVisible;
    };
    AbstractTuiSlider.prototype.onRightFocusVisible = function (focusVisible) {
        this.focusVisibleRight = focusVisible;
    };
    AbstractTuiSlider.prototype.getValueFromFraction = function (fraction) {
        return this.keySteps !== null
            ? this.fractionValueKeyStepConverter(fraction, true)
            : round(this.fractionGuard(fraction) * this.length + this.min, TUI_FLOATING_PRECISION);
    };
    AbstractTuiSlider.prototype.fractionGuard = function (fraction) {
        return this.discrete
            ? clamp(quantize(fraction, 1 / this.steps), 0, 1)
            : clamp(fraction, 0, 1);
    };
    AbstractTuiSlider.prototype.getFractionFromValue = function (value) {
        var fraction = (value - this.min) / this.length;
        return this.keySteps !== null
            ? this.fractionValueKeyStepConverter(value, false)
            : clamp(Number.isFinite(fraction) ? fraction : 1, 0, 1);
    };
    AbstractTuiSlider.prototype.getCalibratedFractionFromEvents = function (rect, clientX, _) {
        return this.getFractionFromEvents(rect, clientX);
    };
    AbstractTuiSlider.prototype.valueGuard = function (value) {
        return this.quantum
            ? clamp(round(Math.round(value / this.quantum) * this.quantum, TUI_FLOATING_PRECISION), this.min, this.max)
            : clamp(value, this.min, this.max);
    };
    AbstractTuiSlider.prototype.processFocus = function (right) {
        if (!this.focusable || !this.dotRight || !this.dotLeft) {
            return;
        }
        if (right) {
            setNativeFocused(this.dotRight.nativeElement);
        }
        else {
            setNativeFocused(this.dotLeft.nativeElement);
        }
    };
    /**
     * Function for converting the fullness of the slider to a value and vice versa
     * taking into account the steps of linear dependence.
     *
     * @param value passed value
     * @param isFraction translation is carried out from fullness to value
     */
    AbstractTuiSlider.prototype.fractionValueKeyStepConverter = function (value, isFraction) {
        var steps = [[0, this.min]].concat(this.keySteps, [
            [100, this.max],
        ]);
        var prevFraction = 0;
        var nextFraction = 100;
        var prevValue = this.min;
        var nextValue = this.max;
        for (var i = 1; i < steps.length; i++) {
            if ((isFraction && steps[i][0] / 100 > value) ||
                (!isFraction && steps[i][1] > value)) {
                prevFraction = steps[i - 1][0] || 0;
                nextFraction = steps[i][0];
                prevValue = steps[i - 1][1];
                nextValue = steps[i][1];
                break;
            }
        }
        var deltaFraction = nextFraction - prevFraction;
        var deltaValue = nextValue - prevValue;
        return isFraction
            ? round(((value * 100 - prevFraction) / deltaFraction) * deltaValue + prevValue, TUI_FLOATING_PRECISION)
            : clamp(((value - prevValue) / deltaValue) * deltaFraction + prevFraction, 0, 100) / 100;
    };
    AbstractTuiSlider.prototype.getFractionFromEvents = function (rect, clientX) {
        var value = clientX - rect.left - DOT_WIDTH[this.size] / 2;
        var total = rect.width - DOT_WIDTH[this.size];
        return round(value / total, TUI_FLOATING_PRECISION);
    };
    AbstractTuiSlider.ctorParameters = function () { return [
        { type: NgControl },
        { type: ChangeDetectorRef },
        { type: Document },
        { type: Observable, decorators: [{ type: Inject, args: [TUI_FROM_TO_TEXTS,] }] }
    ]; };
    __decorate([
        ViewChild("dotLeft", { read: ElementRef })
    ], AbstractTuiSlider.prototype, "dotLeft", void 0);
    __decorate([
        ViewChild("dotRight", { read: ElementRef })
    ], AbstractTuiSlider.prototype, "dotRight", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "min", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "max", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "segments", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "steps", void 0);
    __decorate([
        Input(),
        tuiDefaultProp(nonNegativeFiniteAssertion, "Quantum must be a non-negative number")
    ], AbstractTuiSlider.prototype, "quantum", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "pluralize", null);
    __decorate([
        Input(),
        HostBinding("attr.data-size"),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "size", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], AbstractTuiSlider.prototype, "keySteps", void 0);
    __decorate([
        HostBinding("class._segmented")
    ], AbstractTuiSlider.prototype, "segmented", null);
    AbstractTuiSlider = __decorate([
        Directive(),
        __param(3, Inject(TUI_FROM_TO_TEXTS))
    ], AbstractTuiSlider);
    return AbstractTuiSlider;
}(AbstractTuiControl));

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiInputSlider, AbstractTuiSlider, DOT_WIDTH, SLIDER_KEYBOARD_STEP, quantumAssertion };
//# sourceMappingURL=taiga-ui-kit-abstract.js.map
