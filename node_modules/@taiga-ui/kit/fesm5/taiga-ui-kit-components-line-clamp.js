import { __assign, __read, __decorate, __param } from 'tslib';
import { InjectionToken, ElementRef, Inject, Renderer2, ChangeDetectorRef, NgZone, ViewChild, Input, Output, HostListener, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { typedFromEvent, isCurrentTarget, tuiPx, tuiDefaultProp, tuiPure, TuiResizeModule, TuiLetModule } from '@taiga-ui/cdk';
import { PolymorpheusOutletComponent, PolymorpheusModule } from '@tinkoff/ng-polymorpheus';
import { BehaviorSubject, Subject, of } from 'rxjs';
import { distinctUntilChanged, startWith, pairwise, switchMap, filter, mapTo } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { TuiHintModule } from '@taiga-ui/core';

var TUI_LINE_CLAMP_DEFAULT_OPTIONS = {
    showHint: true,
};
var TUI_LINE_CLAMP_OPTIONS = new InjectionToken("Default parameters for line-clamp component", {
    factory: function () { return TUI_LINE_CLAMP_DEFAULT_OPTIONS; },
});
var tuiLineClampOptionsProvider = function (options) { return ({
    provide: TUI_LINE_CLAMP_OPTIONS,
    useValue: __assign(__assign({}, TUI_LINE_CLAMP_DEFAULT_OPTIONS), options),
}); };

var TuiLineClampComponent = /** @class */ (function () {
    function TuiLineClampComponent(elementRef, renderer, cd, ngZone, options) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.cd = cd;
        this.ngZone = ngZone;
        this.options = options;
        this.linesLimit$ = new BehaviorSubject(1);
        this.isOverflown$ = new Subject();
        this.initialized = false;
        this.lineHeight = 24;
        this.content = '';
        this.overflownChange = this.isOverflown$.pipe(distinctUntilChanged());
        this.skipInitialTransition();
    }
    Object.defineProperty(TuiLineClampComponent.prototype, "linesLimit", {
        set: function (linesLimit) {
            this.linesLimit$.next(linesLimit);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiLineClampComponent.prototype, "lineClamp$", {
        get: function () {
            var _this = this;
            return this.linesLimit$.pipe(startWith(1), pairwise(), switchMap(function (_a) {
                var _b = __read(_a, 2), prev = _b[0], next = _b[1];
                return next >= prev
                    ? of(next)
                    : typedFromEvent(_this.elementRef.nativeElement, 'transitionend').pipe(filter(isCurrentTarget), mapTo(next));
            }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiLineClampComponent.prototype, "overflown", {
        get: function () {
            if (!this.outlet) {
                return false;
            }
            var _a = this.outlet.nativeElement, scrollHeight = _a.scrollHeight, scrollWidth = _a.scrollWidth;
            var _b = this.elementRef.nativeElement, clientHeight = _b.clientHeight, clientWidth = _b.clientWidth;
            // 4px buffer for IE/Edge incorrectly rounding scrollHeight
            return scrollHeight - clientHeight > 4 || scrollWidth - clientWidth > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiLineClampComponent.prototype, "computedContent", {
        get: function () {
            return this.options.showHint && this.overflown ? this.content : '';
        },
        enumerable: true,
        configurable: true
    });
    TuiLineClampComponent.prototype.updateView = function () {
        this.cd.detectChanges();
    };
    TuiLineClampComponent.prototype.ngAfterViewInit = function () {
        this.initialized = true;
    };
    TuiLineClampComponent.prototype.ngDoCheck = function () {
        this.update();
        this.isOverflown$.next(this.overflown);
    };
    TuiLineClampComponent.prototype.skipInitialTransition = function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            setTimeout(function () {
                _this.renderer.addClass(_this.elementRef.nativeElement, '_initialized');
                _this.cd.detectChanges();
            });
        });
    };
    TuiLineClampComponent.prototype.update = function () {
        if (this.outlet) {
            this.renderer.setStyle(this.elementRef.nativeElement, 'height', tuiPx(this.outlet.nativeElement.scrollHeight + 4));
        }
        if (this.initialized) {
            this.renderer.setStyle(this.elementRef.nativeElement, 'max-height', tuiPx(this.lineHeight * this.linesLimit$.value));
        }
    };
    TuiLineClampComponent.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] },
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TUI_LINE_CLAMP_OPTIONS,] }] }
    ]; };
    __decorate([
        ViewChild(PolymorpheusOutletComponent, { read: ElementRef })
    ], TuiLineClampComponent.prototype, "outlet", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], TuiLineClampComponent.prototype, "linesLimit", null);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], TuiLineClampComponent.prototype, "lineHeight", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], TuiLineClampComponent.prototype, "content", void 0);
    __decorate([
        Output()
    ], TuiLineClampComponent.prototype, "overflownChange", void 0);
    __decorate([
        tuiPure
    ], TuiLineClampComponent.prototype, "lineClamp$", null);
    __decorate([
        HostListener('transitionend')
    ], TuiLineClampComponent.prototype, "updateView", null);
    TuiLineClampComponent = __decorate([
        Component({
            selector: 'tui-line-clamp',
            template: "<div\n    *tuiLet=\"lineClamp$ | async as lineClamp\"\n    polymorpheus-outlet\n    tuiHintId=\"unnecessary\"\n    tuiHintMode=\"overflow\"\n    class=\"t-wrapper\"\n    [tuiHint]=\"computedContent\"\n    [content]=\"content\"\n    [style.-webkit-line-clamp]=\"lineClamp\"\n    [style.word-break]=\"lineClamp > 1 ? 'break-word' : 'break-all'\"\n    (tuiResize)=\"updateView()\"\n></div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [":host{position:relative;display:block;overflow:hidden}:host._initialized{transition-property:max-height;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out}.t-wrapper{display:-webkit-box;-webkit-box-orient:vertical;overflow:hidden}"]
        }),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(Renderer2)),
        __param(2, Inject(ChangeDetectorRef)),
        __param(3, Inject(NgZone)),
        __param(4, Inject(TUI_LINE_CLAMP_OPTIONS))
    ], TuiLineClampComponent);
    return TuiLineClampComponent;
}());

var TuiLineClampModule = /** @class */ (function () {
    function TuiLineClampModule() {
    }
    TuiLineClampModule = __decorate([
        NgModule({
            imports: [
                CommonModule,
                PolymorpheusModule,
                TuiHintModule,
                TuiResizeModule,
                TuiLetModule,
            ],
            declarations: [TuiLineClampComponent],
            exports: [TuiLineClampComponent],
        })
    ], TuiLineClampModule);
    return TuiLineClampModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TUI_LINE_CLAMP_DEFAULT_OPTIONS, TUI_LINE_CLAMP_OPTIONS, TuiLineClampComponent, TuiLineClampModule, tuiLineClampOptionsProvider };
//# sourceMappingURL=taiga-ui-kit-components-line-clamp.js.map
