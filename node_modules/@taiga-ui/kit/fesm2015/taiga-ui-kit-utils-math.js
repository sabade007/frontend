import { round } from '@taiga-ui/cdk';
import { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';

/**
 * @internal
 */
function tuiHorizontalDirectionToNumber(direction) {
    switch (direction) {
        case `left`:
            return -1;
        case `right`:
            return 1;
    }
}

function tuiFindKeyStepsBoundariesByFn(keySteps, fn) {
    const keyStepUpperIndex = keySteps.findIndex((keyStep, i) => i && fn(keyStep));
    const lowerStep = keySteps[keyStepUpperIndex - 1];
    const upperStep = keySteps[keyStepUpperIndex];
    return [lowerStep, upperStep];
}
function tuiPercentageToKeyStepValue(valuePercentage, keySteps) {
    const [[lowerStepPercent, lowerStepValue], [upperStepPercent, upperStepValue]] = tuiFindKeyStepsBoundariesByFn(keySteps, ([keyStepPercentage, _]) => valuePercentage <= keyStepPercentage);
    const ratio = (valuePercentage - lowerStepPercent) / (upperStepPercent - lowerStepPercent);
    const controlValue = (upperStepValue - lowerStepValue) * ratio + lowerStepValue;
    return round(controlValue, TUI_FLOATING_PRECISION);
}
function tuiKeyStepValueToPercentage(value, keySteps) {
    const [[lowerStepPercent, lowerStepValue], [upperStepPercent, upperStepValue]] = tuiFindKeyStepsBoundariesByFn(keySteps, ([_, keyStepValue]) => value <= keyStepValue);
    const ratio = (value - lowerStepValue) / (upperStepValue - lowerStepValue) || 0;
    return (upperStepPercent - lowerStepPercent) * ratio + lowerStepPercent;
}
function tuiCheckKeyStepsHaveMinMaxPercents(steps) {
    return !steps.length || (steps[0][0] === 0 && steps[steps.length - 1][0] === 100);
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiCheckKeyStepsHaveMinMaxPercents, tuiHorizontalDirectionToNumber, tuiKeyStepValueToPercentage, tuiPercentageToKeyStepValue };
//# sourceMappingURL=taiga-ui-kit-utils-math.js.map
