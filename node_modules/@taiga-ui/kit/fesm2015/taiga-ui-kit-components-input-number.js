import { __decorate, __param } from 'tslib';
import { Optional, Self, Inject, ChangeDetectorRef, ViewChild, Input, ContentChildren, HostListener, Component, ChangeDetectionStrategy, forwardRef, Directive, NgModule } from '@angular/core';
import { NgControl } from '@angular/forms';
import { AbstractTuiNullableControl, EMPTY_QUERY, TUI_IS_IOS, tuiDefaultProp, TUI_FOCUSABLE_ITEM_ACCESSOR, AbstractTuiControl, TuiMapperPipeModule } from '@taiga-ui/cdk';
import { tuiCreateNumberMask, tuiEnableAutoCorrectDecimalSymbol, tuiCreateAutoCorrectedNumberPipe, maskedMoneyValueIsEmpty, tuiMaskedNumberStringToNumber, TUI_DECIMAL_SYMBOLS, getFractionPartPadded, formatNumber, TUI_NUMBER_FORMAT, TuiPrimitiveTextfieldComponent, TuiAbstractTextfieldHost, TUI_TEXTFIELD_HOST, TuiPrimitiveTextfieldModule, TuiTextfieldControllerModule, TuiTextfieldComponent } from '@taiga-ui/core';
import { PolymorpheusOutletComponent, PolymorpheusModule } from '@tinkoff/ng-polymorpheus';
import { CommonModule } from '@angular/common';
import { TuiValueAccessorModule } from '@taiga-ui/kit/directives';
import { TextMaskModule } from 'angular2-text-mask';

var TuiInputNumberComponent_1;
const DEFAULT_MAX_LENGTH = 18;
// @dynamic
let TuiInputNumberComponent = TuiInputNumberComponent_1 = class TuiInputNumberComponent extends AbstractTuiNullableControl {
    constructor(control, changeDetectorRef, numberFormat, isIOS) {
        super(control, changeDetectorRef);
        this.numberFormat = numberFormat;
        this.isIOS = isIOS;
        this.unfinishedValue = '';
        this.min = -Infinity;
        this.max = Infinity;
        this.decimal = 'not-zero';
        this.precision = 2;
        this.prefix = '';
        this.postfix = '';
        this.polymorpheusValueContent = EMPTY_QUERY;
        this.mask = (allowNegative, decimal, decimalLimit, nativeFocusableElement) => ({
            mask: tuiCreateNumberMask({
                allowNegative,
                decimalLimit,
                allowDecimal: decimal !== 'never',
                requireDecimal: decimal === 'always',
                decimalSymbol: this.numberFormat.decimalSeparator,
                thousandSymbol: this.numberFormat.thousandSeparator,
                autoCorrectDecimalSymbol: tuiEnableAutoCorrectDecimalSymbol(this.numberFormat),
            }),
            pipe: tuiCreateAutoCorrectedNumberPipe(decimal === 'always' ? decimalLimit : 0, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator, nativeFocusableElement, allowNegative, this.isIOS),
            guide: false,
        });
    }
    get nativeFocusableElement() {
        return !this.primitiveTextfield || this.computedDisabled
            ? null
            : this.primitiveTextfield.nativeFocusableElement;
    }
    get focused() {
        return !!this.primitiveTextfield && this.primitiveTextfield.focused;
    }
    get isNegativeAllowed() {
        return this.min < 0;
    }
    get inputMode() {
        if (this.isIOS && this.isNegativeAllowed) {
            // iphones do not have minus sign if inputMode is equal to 'numeric' / 'decimal'
            return 'text';
        }
        return this.decimal === 'never' ? 'numeric' : 'decimal';
    }
    get calculatedMaxLength() {
        const decimalPart = this.decimal !== 'never' &&
            this.nativeValue.includes(this.numberFormat.decimalSeparator);
        const precision = decimalPart ? this.precision + 1 : 0;
        const takeThousand = this.numberFormat.thousandSeparator.repeat(5).length;
        return DEFAULT_MAX_LENGTH + precision + takeThousand;
    }
    get formattedValue() {
        return this.getFormattedValue(this.value || 0);
    }
    get computedValue() {
        if (this.focused) {
            return this.nativeValue;
        }
        return this.value === null ? '' : this.formattedValue;
    }
    onZero(event) {
        const decimal = this.nativeValue.split(this.numberFormat.decimalSeparator)[1] || '';
        const { nativeFocusableElement } = this;
        if (decimal.length < this.precision ||
            !nativeFocusableElement ||
            !nativeFocusableElement.selectionStart ||
            this.nativeValue[nativeFocusableElement.selectionStart] !== '0') {
            return;
        }
        event.preventDefault();
        nativeFocusableElement.selectionStart++;
    }
    onValueChange(value) {
        if (maskedMoneyValueIsEmpty(value)) {
            this.updateValue(null);
            return;
        }
        if (this.isNativeValueNotFinished) {
            this.unfinishedValue = value;
            return;
        }
        this.unfinishedValue = null;
        const capped = this.absoluteCapInputValue(value);
        if (capped === null || Number.isNaN(capped)) {
            return;
        }
        this.updateValue(capped);
        if (capped !==
            tuiMaskedNumberStringToNumber(value, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator)) {
            this.nativeValue = this.formattedValue;
        }
    }
    onKeyDown(event) {
        if (!TUI_DECIMAL_SYMBOLS.includes(event.key)) {
            return;
        }
        if (this.decimal === 'never') {
            event.preventDefault();
            return;
        }
        if (this.nativeValue.includes(this.numberFormat.decimalSeparator)) {
            event.preventDefault();
            this.setCaretAfterComma();
        }
    }
    onFocused(focused) {
        this.updateFocused(focused);
        if (focused) {
            return;
        }
        const nativeNumberValue = this.unfinishedValue
            ? tuiMaskedNumberStringToNumber(this.unfinishedValue, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator)
            : this.nativeNumberValue;
        this.unfinishedValue = null;
        if (Number.isNaN(nativeNumberValue)) {
            this.clear();
            return;
        }
        const clamped = Math.min(this.max, Math.max(this.min, nativeNumberValue));
        this.updateValue(clamped);
        this.nativeValue = this.formattedValue;
    }
    onHovered(hovered) {
        this.updateHovered(hovered);
    }
    onPressed(pressed) {
        this.updatePressed(pressed);
    }
    getFormattedValue(value) {
        const absValue = Math.abs(value);
        const hasFraction = absValue % 1 > 0;
        let limit = this.decimal === 'always' || (hasFraction && this.decimal !== 'never')
            ? this.precision
            : 0;
        const fraction = hasFraction ? getFractionPartPadded(value, this.precision) : '';
        if (this.focused && this.decimal !== 'always') {
            limit = fraction.length;
        }
        return formatNumber(value, limit, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator, this.numberFormat.zeroPadding);
    }
    get isNativeValueNotFinished() {
        const nativeNumberValue = this.nativeNumberValue;
        return nativeNumberValue < 0
            ? nativeNumberValue > this.max
            : nativeNumberValue < this.min;
    }
    get nativeValue() {
        return this.nativeFocusableElement ? this.nativeFocusableElement.value : '';
    }
    set nativeValue(value) {
        if (!this.primitiveTextfield || !this.nativeFocusableElement) {
            return;
        }
        this.primitiveTextfield.value = value;
        this.nativeFocusableElement.value = value;
    }
    get nativeNumberValue() {
        return tuiMaskedNumberStringToNumber(this.nativeValue, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator);
    }
    clear() {
        this.nativeValue = '';
        this.updateValue(null);
    }
    absoluteCapInputValue(inputValue) {
        const value = tuiMaskedNumberStringToNumber(inputValue, this.numberFormat.decimalSeparator, this.numberFormat.thousandSeparator);
        const capped = value < 0
            ? Math.max(Math.max(this.min, Number.MIN_SAFE_INTEGER), value)
            : Math.min(value, Math.min(this.max, Number.MAX_SAFE_INTEGER));
        const ineligibleValue = Number.isNaN(capped) || capped < this.min || capped > this.max;
        return ineligibleValue ? null : capped;
    }
    setCaretAfterComma() {
        if (!this.nativeFocusableElement) {
            return;
        }
        const afterCommaPosition = this.nativeValue.length - this.precision;
        this.nativeFocusableElement.setSelectionRange(afterCommaPosition, afterCommaPosition);
    }
};
TuiInputNumberComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_NUMBER_FORMAT,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [TUI_IS_IOS,] }] }
];
__decorate([
    ViewChild(TuiPrimitiveTextfieldComponent)
], TuiInputNumberComponent.prototype, "primitiveTextfield", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiInputNumberComponent.prototype, "min", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiInputNumberComponent.prototype, "max", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiInputNumberComponent.prototype, "decimal", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiInputNumberComponent.prototype, "precision", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiInputNumberComponent.prototype, "prefix", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiInputNumberComponent.prototype, "postfix", void 0);
__decorate([
    ContentChildren(PolymorpheusOutletComponent)
], TuiInputNumberComponent.prototype, "polymorpheusValueContent", void 0);
__decorate([
    HostListener('keydown.0', ['$event'])
], TuiInputNumberComponent.prototype, "onZero", null);
TuiInputNumberComponent = TuiInputNumberComponent_1 = __decorate([
    Component({
        selector: 'tui-input-number',
        template: "<tui-primitive-textfield\n    tuiValueAccessor\n    class=\"t-textfield\"\n    [pseudoHovered]=\"computedHovered\"\n    [pseudoFocused]=\"computedFocused\"\n    [pseudoPressed]=\"computedPressed\"\n    [invalid]=\"computedInvalid\"\n    [tuiTextfieldInputMode]=\"inputMode\"\n    [tuiTextfieldMaxLength]=\"calculatedMaxLength\"\n    [readOnly]=\"readOnly\"\n    [disabled]=\"computedDisabled\"\n    [textMask]=\"isNegativeAllowed | tuiMapper: mask:decimal:precision:nativeFocusableElement\"\n    [value]=\"computedValue\"\n    [prefix]=\"prefix\"\n    [postfix]=\"postfix\"\n    [focusable]=\"focusable\"\n    (valueChange)=\"onValueChange($event)\"\n    (hoveredChange)=\"onHovered($event)\"\n    (focusedChange)=\"onFocused($event)\"\n    (pressedChange)=\"onPressed($event)\"\n    (keydown)=\"onKeyDown($event)\"\n>\n    <ng-content></ng-content>\n    <ng-content\n        select=\"input\"\n        ngProjectAs=\"input\"\n    ></ng-content>\n    <div\n        *ngIf=\"polymorpheusValueContent.length\"\n        polymorpheus-outlet\n        class=\"t-value-content\"\n        [content]=\"valueContent\"\n    ></div>\n</tui-primitive-textfield>\n\n<ng-container *ngIf=\"polymorpheusValueContent.changes | async\"></ng-container>\n\n<ng-template #valueContent>\n    <ng-content select=\"[polymorpheus-outlet]\"></ng-content>\n</ng-template>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [
            {
                provide: TUI_FOCUSABLE_ITEM_ACCESSOR,
                useExisting: forwardRef(() => TuiInputNumberComponent_1),
            },
            {
                provide: AbstractTuiControl,
                useExisting: forwardRef(() => TuiInputNumberComponent_1),
            },
        ],
        styles: [":host{display:block;border-radius:var(--tui-radius-m);text-align:left}.t-textfield{border-radius:inherit;text-align:inherit}.t-value-content{width:100%}"]
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(TUI_NUMBER_FORMAT)),
    __param(3, Inject(TUI_IS_IOS))
], TuiInputNumberComponent);

var TuiInputNumberDirective_1;
let TuiInputNumberDirective = TuiInputNumberDirective_1 = class TuiInputNumberDirective extends TuiAbstractTextfieldHost {
    get value() {
        return this.host.computedValue;
    }
    onValueChange(value) {
        this.host.onValueChange(value);
    }
    process(input) {
        this.input = input;
    }
    ngDoCheck() {
        if (!this.input) {
            return;
        }
        this.input.maxLength = this.host.calculatedMaxLength;
        this.input.inputMode = 'decimal';
    }
};
TuiInputNumberDirective = TuiInputNumberDirective_1 = __decorate([
    Directive({
        selector: 'tui-input-number',
        providers: [
            {
                provide: TUI_TEXTFIELD_HOST,
                useExisting: forwardRef(() => TuiInputNumberDirective_1),
            },
        ],
    })
], TuiInputNumberDirective);

let TuiInputNumberModule = class TuiInputNumberModule {
};
TuiInputNumberModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            TextMaskModule,
            TuiMapperPipeModule,
            TuiPrimitiveTextfieldModule,
            TuiTextfieldControllerModule,
            TuiValueAccessorModule,
            PolymorpheusModule,
        ],
        declarations: [TuiInputNumberComponent, TuiInputNumberDirective],
        exports: [TuiInputNumberComponent, TuiInputNumberDirective, TuiTextfieldComponent],
    })
], TuiInputNumberModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiInputNumberComponent, TuiInputNumberDirective, TuiInputNumberModule };
//# sourceMappingURL=taiga-ui-kit-components-input-number.js.map
