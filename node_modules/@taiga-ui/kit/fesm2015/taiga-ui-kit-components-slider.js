import { __decorate, __param } from 'tslib';
import { InjectionToken, Optional, Self, Inject, ChangeDetectorRef, ElementRef, Injector, Input, HostBinding, Component, ChangeDetectionStrategy, forwardRef, Output, HostListener, Directive, Pipe, ContentChild, NgModule } from '@angular/core';
import { NgModel, NgControl } from '@angular/forms';
import { watch, isEdgeOlderThan, CHROMIUM_EDGE_START_VERSION, tuiDefaultProp, tuiPure, AbstractTuiControl, typedFromEvent, isNativeFocused, clamp, tuiAssert, tuiCoerceBooleanProperty, TuiDestroyService, TUI_FOCUSABLE_ITEM_ACCESSOR, TuiRepeatTimesModule, TuiFocusableModule, TuiFocusVisibleModule, TuiActiveZoneModule } from '@taiga-ui/cdk';
import { tuiPercentageToKeyStepValue, tuiKeyStepValueToPercentage, tuiCheckKeyStepsHaveMinMaxPercents } from '@taiga-ui/kit/utils';
import { take, map, tap, mapTo, filter, takeUntil } from 'rxjs/operators';
import { USER_AGENT } from '@ng-web-apis/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { merge, combineLatest, Observable } from 'rxjs';
import { TuiFormatNumberPipeModule } from '@taiga-ui/core';
import { AbstractTuiSlider } from '@taiga-ui/kit/abstract';
import { TUI_FROM_TO_TEXTS } from '@taiga-ui/kit/tokens';

const TUI_SLIDER_DEFAULT_OPTIONS = {
    size: `m`,
    trackColor: `var(--tui-base-03)`,
};
const TUI_SLIDER_OPTIONS = new InjectionToken(`Default parameters for Slider component`, { factory: () => TUI_SLIDER_DEFAULT_OPTIONS });
function tuiSliderOptionsProvider(options) {
    return {
        provide: TUI_SLIDER_OPTIONS,
        useValue: Object.assign(Object.assign({}, TUI_SLIDER_DEFAULT_OPTIONS), options),
    };
}

let TuiSliderComponent = class TuiSliderComponent {
    constructor(control, changeDetectorRef, options, elementRef, userAgent, injector) {
        var _a;
        this.control = control;
        this.options = options;
        this.elementRef = elementRef;
        this.userAgent = userAgent;
        this.injector = injector;
        this.size = this.options.size;
        this.segments = 1;
        if (control instanceof NgModel) {
            /**
             * The ValueAccessor.writeValue method is called twice on any value accessor during component initialization,
             * when a control is bound using [(ngModel)], first time with a phantom null value.
             * With `changeDetection: ChangeDetectionStrategy.OnPush` the second call of writeValue with real value don't re-render the view.
             * ___
             * See this {@link https://github.com/angular/angular/issues/14988 issue}
             */
            (_a = control.valueChanges) === null || _a === void 0 ? void 0 : _a.pipe(watch(changeDetectorRef), take(1)).subscribe();
        }
    }
    get min() {
        return Number(this.elementRef.nativeElement.min);
    }
    get max() {
        return Number(this.elementRef.nativeElement.max || 100);
    }
    get step() {
        return Number(this.elementRef.nativeElement.step) || 1;
    }
    get value() {
        const { elementRef, control, hasKeySteps } = this;
        if (!hasKeySteps && control instanceof NgModel) {
            /**
             * If developer uses `[(ngModel)]` and programmatically change value,
             * the `elementRef.nativeElement.value` is equal to the previous value at this moment.
             */
            return control.viewModel;
        }
        return Number(elementRef.nativeElement.value) || 0;
    }
    set value(newValue) {
        this.elementRef.nativeElement.value = `${newValue}`;
    }
    get valuePercentage() {
        return (100 * (this.value - this.min)) / (this.max - this.min) || 0;
    }
    get segmentWidth() {
        return 100 / Math.max(1, this.segments);
    }
    get isOldEdge() {
        return isEdgeOlderThan(CHROMIUM_EDGE_START_VERSION, this.userAgent);
    }
    get hasKeySteps() {
        return Boolean(this.injector.get(TuiSliderKeyStepsDirective, null));
    }
};
TuiSliderComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_SLIDER_OPTIONS,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: String, decorators: [{ type: Inject, args: [USER_AGENT,] }] },
    { type: Injector, decorators: [{ type: Inject, args: [Injector,] }] }
];
__decorate([
    Input(),
    HostBinding('attr.data-size'),
    tuiDefaultProp()
], TuiSliderComponent.prototype, "size", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiSliderComponent.prototype, "segments", void 0);
__decorate([
    HostBinding('style.--tui-slider-fill-percentage.%')
], TuiSliderComponent.prototype, "valuePercentage", null);
__decorate([
    HostBinding('style.--tui-slider-segment-width.%')
], TuiSliderComponent.prototype, "segmentWidth", null);
__decorate([
    HostBinding('class._old-edge')
], TuiSliderComponent.prototype, "isOldEdge", null);
__decorate([
    tuiPure
], TuiSliderComponent.prototype, "hasKeySteps", null);
TuiSliderComponent = __decorate([
    Component({
        /**
         * We have to call our component as `<input tuiSlider type="range" ... />`
         * because otherwise built-in angular
         * {@link https://github.com/angular/angular/blob/master/packages/forms/src/directives/range_value_accessor.ts#L45 RangeValueAccessor}
         * cannot be matched by its CSS selector.
         */
        selector: 'input[type=range][tuiSlider]',
        template: '',
        host: {
            /**
             * For change detection.
             * Webkit does not have built-in method for customization of filling progress (as Firefox).
             * We draw filling of progress by `background: linear-gradient(...)` of the track.
             * This function triggers change detection (for {@link valuePercentage} function) when we drag thumb of the input.
             */
            '(input)': '0',
            '[style.--tui-slider-track-color]': 'options.trackColor',
        },
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{display:block;width:100%;color:var(--tui-primary);cursor:pointer}:host:active{cursor:ew-resize}:host:disabled{opacity:var(--tui-disabled-opacity);cursor:auto}:host:not(._old-edge){-webkit-appearance:none;-moz-appearance:none;appearance:none;height:.125rem;padding:.4375rem 0;background-color:transparent;background-clip:content-box;outline:0;border-radius:var(--tui-radius-m)}:host:not(._old-edge)::-webkit-slider-container{border-radius:inherit}:host:not(._old-edge)[data-size='m']::-webkit-slider-runnable-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0 .625rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width)),linear-gradient(to right,currentColor var(--tui-slider-fill-percentage),transparent var(--tui-slider-fill-percentage));background-position-x:0,.375rem,0;background-size:calc(100% - 1rem),calc(100% - 1rem),auto}:host:not(._old-edge)[data-size='s']::-webkit-slider-runnable-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0 .375rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width)),linear-gradient(to right,currentColor var(--tui-slider-fill-percentage),transparent var(--tui-slider-fill-percentage));background-position-x:0,.125rem,0;background-size:calc(100% - .5rem),calc(100% - .5rem),auto}:host:not(._old-edge)[data-size='m']::-moz-range-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0 .625rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width));background-position-x:0,.375rem;background-size:calc(100% - 1rem)}:host:not(._old-edge)[data-size='s']::-moz-range-track{height:.125rem;border-radius:inherit;background-repeat:no-repeat;background-color:var(--tui-slider-track-color);background-image:linear-gradient(to right,currentColor 0 .375rem,transparent .25rem),repeating-linear-gradient(to right,var(--tui-base-07) 0 .25rem,transparent 0 var(--tui-slider-segment-width));background-position-x:0,.125rem;background-size:calc(100% - .5rem)}:host:not(._old-edge)[data-size='m']::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:1rem;width:1rem;margin-top:-.4375rem}:not(:disabled):host:not(._old-edge)[data-size='m']::-webkit-slider-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size='m']::-webkit-slider-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size='m']::-webkit-slider-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size='m']::-webkit-slider-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)[data-size='s']::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:.5rem;width:.5rem;margin-top:-.1875rem}:not(:disabled):host:not(._old-edge)[data-size='s']::-webkit-slider-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size='s']::-webkit-slider-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size='s']::-webkit-slider-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size='s']::-webkit-slider-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)[data-size='m']::-moz-range-thumb{-moz-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:1rem;width:1rem}:not(:disabled):host:not(._old-edge)[data-size='m']::-moz-range-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size='m']::-moz-range-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size='m']::-moz-range-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size='m']::-moz-range-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)[data-size='s']::-moz-range-thumb{-moz-appearance:none;appearance:none;background-color:currentColor;border:none;border-radius:50%;height:.5rem;width:.5rem}:not(:disabled):host:not(._old-edge)[data-size='s']::-moz-range-thumb{cursor:ew-resize}:not(:disabled):host:not(._old-edge)[data-size='s']::-moz-range-thumb:hover{background:var(--tui-primary-hover)}:not(:disabled):host:not(._old-edge)[data-size='s']::-moz-range-thumb:active{background:var(--tui-primary-active)}:focus-visible:host:not(._old-edge)[data-size='s']::-moz-range-thumb{box-shadow:0 0 0 2px inset var(--tui-focus)}:host:not(._old-edge)::-moz-range-progress{background:currentColor;border-radius:inherit;border-top-right-radius:0;border-bottom-right-radius:0}:host._old-edge::-ms-thumb{background:currentColor;border-radius:50%}:host._old-edge::-ms-fill-lower{background:currentColor}:host._old-edge::-ms-track{background:var(--tui-slider-track-color);border:none}"]
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(TUI_SLIDER_OPTIONS)),
    __param(3, Inject(ElementRef)),
    __param(4, Inject(USER_AGENT)),
    __param(5, Inject(Injector))
], TuiSliderComponent);

// @dynamic
let TuiSliderKeyStepsDirective = class TuiSliderKeyStepsDirective extends AbstractTuiControl {
    constructor(control, changeDetectorRef, elementRef, slider) {
        super(control, changeDetectorRef);
        this.elementRef = elementRef;
        this.slider = slider;
        this.keySteps = [];
        this.keyStepsInput = typedFromEvent(this.elementRef.nativeElement, 'input').pipe(map(() => this.controlValue));
    }
    get nativeFocusableElement() {
        return this.computedDisabled ? null : this.elementRef.nativeElement;
    }
    get focused() {
        return isNativeFocused(this.nativeFocusableElement);
    }
    get min() {
        var _a;
        return ((_a = this.keySteps[0]) === null || _a === void 0 ? void 0 : _a[1]) || 0;
    }
    get max() {
        var _a;
        return ((_a = this.keySteps[this.keySteps.length - 1]) === null || _a === void 0 ? void 0 : _a[1]) || 100;
    }
    get controlValue() {
        return tuiPercentageToKeyStepValue(this.slider.valuePercentage, this.keySteps);
    }
    /**
     * TODO: 3.0
     * ___
     * Also add @HostListener(`input`): to be similar to
     * {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/range_value_accessor.ts#L47-L48 RangeValueAccessor}
     * ___
     * Remove {@link keyStepsInput}
     */
    updateControlValue() {
        this.updateValue(this.controlValue);
    }
    writeValue(controlValue) {
        if (controlValue === null) {
            return;
        }
        const clampedControlValue = clamp(controlValue, this.min, this.max);
        tuiAssert.assert(controlValue === clampedControlValue, '\n[SliderKeySteps]: You cannot programmatically set value which is less/more than min/max');
        this.slider.value = this.transformToNativeValue(clampedControlValue);
    }
    getFallbackValue() {
        return 0;
    }
    transformToNativeValue(controlValue) {
        const { min, max } = this.slider;
        const newValuePercentage = tuiKeyStepValueToPercentage(controlValue, this.keySteps);
        return (newValuePercentage * (max - min)) / 100 + min;
    }
};
TuiSliderKeyStepsDirective.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: TuiSliderComponent, decorators: [{ type: Inject, args: [forwardRef(() => TuiSliderComponent),] }] }
];
__decorate([
    Input(),
    tuiDefaultProp(tuiCheckKeyStepsHaveMinMaxPercents, 'Should contain min and max values')
], TuiSliderKeyStepsDirective.prototype, "keySteps", void 0);
__decorate([
    Output()
], TuiSliderKeyStepsDirective.prototype, "keyStepsInput", void 0);
__decorate([
    HostListener('change')
], TuiSliderKeyStepsDirective.prototype, "updateControlValue", null);
TuiSliderKeyStepsDirective = __decorate([
    Directive({
        selector: 'input[tuiSlider][keySteps]',
        host: {
            '[attr.aria-valuenow]': 'safeCurrentValue',
            '[attr.aria-valuemin]': 'min',
            '[attr.aria-valuemax]': 'max',
        },
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(ElementRef)),
    __param(3, Inject(forwardRef(() => TuiSliderComponent)))
], TuiSliderKeyStepsDirective);
/**
 * @deprecated DONT USE IT! It is just temporary solution for internal purposes only. We will delete it in next major release.
 * TODO delete it in v3.0
 *
 */
let TuiSliderTickLabelPipe = class TuiSliderTickLabelPipe {
    transform(tickIndex, totalSegments, keySteps) {
        const percentage = (100 / totalSegments) * tickIndex;
        return tuiPercentageToKeyStepValue(percentage, keySteps);
    }
};
TuiSliderTickLabelPipe = __decorate([
    Pipe({ name: 'tuiSliderTickLabel' })
], TuiSliderTickLabelPipe);

const SLIDER_INTERACTION_KEYS = new Set([
    'ArrowLeft',
    'ArrowRight',
    'ArrowUp',
    'ArrowDown',
    'Home',
    'End',
    'PageUp',
    'PageDown',
]);
/**
 * Native <input type='range' readonly> doesn't work.
 * This directive imitates this native behaviour.
 */
// @dynamic
let TuiSliderReadonlyDirective = class TuiSliderReadonlyDirective {
    constructor(elementRef, documentRef, destroy$) {
        this.readonly = true;
        const touchStart$ = typedFromEvent(elementRef.nativeElement, 'touchstart', {
            passive: false,
        });
        const touchMove$ = typedFromEvent(documentRef, 'touchmove', {
            passive: false,
        });
        const touchEnd$ = typedFromEvent(documentRef, 'touchend', {
            passive: true,
        });
        const shouldPreventMove$ = merge(touchStart$.pipe(tap(e => this.preventEvent(e)), mapTo(true)), touchEnd$.pipe(mapTo(false)));
        /**
         * @bad TODO think about another solution.
         * Keep in mind that preventing touch event (on slider) inside `@HostListener('touchstart')` doesn't work for mobile chrome.
         */
        combineLatest([touchMove$, shouldPreventMove$])
            .pipe(filter(([_, shouldPreventMove]) => shouldPreventMove), takeUntil(destroy$))
            .subscribe(([moveEvent]) => this.preventEvent(moveEvent));
    }
    preventEvent(event) {
        if (event.cancelable && tuiCoerceBooleanProperty(this.readonly)) {
            event.preventDefault();
        }
    }
    preventKeyboardInteraction(event) {
        if (SLIDER_INTERACTION_KEYS.has(event.key)) {
            this.preventEvent(event);
        }
    }
};
TuiSliderReadonlyDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
];
__decorate([
    Input(),
    tuiDefaultProp()
], TuiSliderReadonlyDirective.prototype, "readonly", void 0);
__decorate([
    HostListener('mousedown', ['$event'])
], TuiSliderReadonlyDirective.prototype, "preventEvent", null);
__decorate([
    HostListener('keydown', ['$event'])
], TuiSliderReadonlyDirective.prototype, "preventKeyboardInteraction", null);
TuiSliderReadonlyDirective = __decorate([
    Directive({
        selector: 'input[tuiSlider][readonly]',
        providers: [TuiDestroyService],
    }),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(DOCUMENT)),
    __param(2, Inject(TuiDestroyService))
], TuiSliderReadonlyDirective);

let TuiSliderThumbLabelComponent = class TuiSliderThumbLabelComponent {
    get size() {
        var _a;
        return ((_a = this.slider) === null || _a === void 0 ? void 0 : _a.size) || 'm';
    }
    get ratio() {
        var _a;
        return (((_a = this.slider) === null || _a === void 0 ? void 0 : _a.valuePercentage) || 0) / 100;
    }
    get ghostLeft() {
        var _a;
        return this.ratio * (((_a = this.slider) === null || _a === void 0 ? void 0 : _a.elementRef.nativeElement.offsetWidth) || 0);
    }
    ngAfterContentInit() {
        var _a;
        tuiAssert.assert(Boolean((_a = this.control) === null || _a === void 0 ? void 0 : _a.valueChanges), '\n[tuiSliderThumbLabel] expected <input tuiSlider type="range" /> to use Angular Forms.\n' +
            'Use [(ngModel)] or [formControl] or formControlName for correct work.');
    }
};
__decorate([
    ContentChild(TuiSliderComponent)
], TuiSliderThumbLabelComponent.prototype, "slider", void 0);
__decorate([
    ContentChild(NgControl)
], TuiSliderThumbLabelComponent.prototype, "control", void 0);
TuiSliderThumbLabelComponent = __decorate([
    Component({
        selector: '[tuiSliderThumbLabel]',
        template: "<ng-container *ngIf=\"control?.valueChanges | async\"></ng-container>\n\n<div\n    class=\"t-ghost\"\n    [attr.data-size]=\"size\"\n    [style.left.px]=\"ghostLeft\"\n    [style.--tui-slider-thumb-ratio]=\"ratio\"\n>\n    <ng-content></ng-content>\n</div>\n\n<ng-content select=\"input[type=range]\"></ng-content>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{position:relative}.t-ghost{position:absolute;top:0;bottom:0;margin:auto;border-radius:50%;pointer-events:none}.t-ghost[data-size='s']{width:.5rem;height:.5rem;transform:translateX(calc(var(--tui-slider-thumb-ratio) * -.5rem))}.t-ghost[data-size='m']{width:1rem;height:1rem;transform:translateX(calc(var(--tui-slider-thumb-ratio) * -1rem))}"]
    })
], TuiSliderThumbLabelComponent);

var TuiSliderOldComponent_1;
/**
 * @deprecated use {@link TuiSliderComponent} instead
 * TODO: 3.0 remove
 */
// @dynamic
let TuiSliderOldComponent = TuiSliderOldComponent_1 = class TuiSliderOldComponent extends AbstractTuiSlider {
    constructor(control, changeDetectorRef, documentRef, fromToTexts$) {
        super(control, changeDetectorRef, documentRef, fromToTexts$);
    }
    get nativeFocusableElement() {
        return this.dotRight ? this.dotRight.nativeElement : null;
    }
    get focused() {
        return isNativeFocused(this.nativeFocusableElement);
    }
    get left() {
        return 0;
    }
    get right() {
        return 100 - 100 * this.getFractionFromValue(this.value);
    }
    processValue(value) {
        this.updateValue(this.valueGuard(value));
    }
    decrement() {
        this.processStep(false);
    }
    increment() {
        this.processStep(true);
    }
    getFallbackValue() {
        return 0;
    }
    processStep(increment) {
        const fraction = this.getFractionFromValue(this.value);
        const step = this.computedStep;
        const value = this.getValueFromFraction(increment ? fraction + step : fraction - step);
        this.processValue(value);
    }
};
TuiSliderOldComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TUI_FROM_TO_TEXTS,] }] }
];
TuiSliderOldComponent = TuiSliderOldComponent_1 = __decorate([
    Component({
        selector: 'tui-slider',
        template: "<div\n    class=\"event-catcher\"\n    (tuiActiveZoneChange)=\"onActiveZone($event)\"\n    (mousedown)=\"onMouseDown($event)\"\n    (touchstart)=\"onTouchStart($event)\"\n>\n    <div class=\"wrapper\">\n        <div\n            *ngIf=\"segmented\"\n            class=\"segments\"\n        >\n            <span\n                *tuiRepeatTimes=\"let segmentIndex of segments + 1\"\n                automation-id=\"tui-slider__segment\"\n                class=\"segment\"\n            >\n                <span\n                    *ngIf=\"fromToTexts$ | async as fromToText\"\n                    class=\"number\"\n                >\n                    {{ getSegmentPrefix(segmentIndex, fromToText) }}\n                    {{ getSegmentLabel(segmentIndex) | tuiFormatNumber }}\n                    <span *ngIf=\"pluralizeMap\">\n                        {{ getSegmentLabel(segmentIndex) | i18nPlural: pluralizeMap }}\n                    </span>\n                </span>\n            </span>\n        </div>\n        <div\n            automation-id=\"tui-slider__bar\"\n            class=\"bar\"\n            [style.left.%]=\"left\"\n            [style.right.%]=\"right\"\n        >\n            <div\n                #dotLeft\n                automation-id=\"tui-slider__left\"\n                class=\"dot\"\n                [class.dot_focus-visible]=\"focusVisibleLeft && computedFocused\"\n                [tuiFocusable]=\"isLeftFocusable\"\n                (tuiFocusVisibleChange)=\"onLeftFocusVisible($event)\"\n                (keydown.arrowLeft.prevent)=\"decrement()\"\n                (keydown.arrowDown.prevent)=\"decrement()\"\n                (keydown.arrowRight.prevent)=\"increment()\"\n                (keydown.arrowUp.prevent)=\"increment()\"\n            ></div>\n            <div\n                #dotRight\n                automation-id=\"tui-slider__right\"\n                class=\"dot\"\n                [class.dot_focus-visible]=\"focusVisibleRight && computedFocused\"\n                [tuiFocusable]=\"isRightFocusable\"\n                (tuiFocusVisibleChange)=\"onRightFocusVisible($event)\"\n                (keydown.arrowLeft.prevent)=\"decrement()\"\n                (keydown.arrowDown.prevent)=\"decrement()\"\n                (keydown.arrowRight.prevent)=\"increment()\"\n                (keydown.arrowUp.prevent)=\"increment()\"\n            ></div>\n        </div>\n    </div>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        providers: [
            {
                provide: TUI_FOCUSABLE_ITEM_ACCESSOR,
                useExisting: forwardRef(() => TuiSliderOldComponent_1),
            },
        ],
        styles: [":host{display:block;border-radius:var(--tui-radius-m);color:var(--tui-base-03);min-height:.125rem;font-size:1rem}:host[data-size='s']{min-height:.125rem;font-size:.5rem}:host._segmented{padding-bottom:1.25rem}:host._disabled{cursor:default;pointer-events:none;opacity:var(--tui-disabled-opacity)}.event-catcher{min-height:inherit;border-radius:inherit;padding:.4375rem 0;cursor:pointer}.wrapper{position:relative;min-height:inherit;border-radius:inherit;background-color:currentColor;border:solid transparent;border-width:0 1em}.bar{position:absolute;top:0;bottom:0;margin:0 -1em;border-radius:inherit;background-color:var(--tui-primary)}:host-context(tui-input-slider) .bar{margin-left:calc(var(--tui-radius-m)/ 2);border-bottom-left-radius:calc(var(--tui-radius-m) * 5) calc(var(--tui-radius-m) * 1.5)}.dot{transition-property:background-color;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out;position:absolute;top:50%;z-index:1;width:1em;height:1em;transform:translate(0,-50%);border-radius:100%;background-color:var(--tui-primary);outline:0;cursor:ew-resize}.dot:last-child{right:0;transform:translate(0,-50%)}.dot:hover{background-color:var(--tui-primary-hover)}.dot:active{background-color:var(--tui-primary-active)}.dot_focus-visible{box-shadow:inset 0 0 0 2px var(--tui-focus)}.segments{position:relative;z-index:1;display:flex;justify-content:space-between;min-height:inherit;margin:0 -1em}.segments-spacer{height:1.625rem}.segment{position:relative;height:inherit;width:.25rem;background-color:rgba(0,0,0,.36);pointer-events:none}.segment:first-of-type,.segment:last-of-type{background-color:transparent}.number{position:absolute;left:50%;transform:translate(-50%,0);top:100%;font:var(--tui-font-text-s);margin-top:.5rem;color:var(--tui-text-02);white-space:nowrap}.segment:first-of-type .number{left:-.05em;transform:none}.segment:last-of-type .number{left:auto;right:-.05em;transform:none}:host._disabled .number{color:var(--tui-text-01)}", ".dot:first-child{display:none}.wrapper{border-left:none}.bar,.segments{margin-left:0}"]
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(DOCUMENT)),
    __param(3, Inject(TUI_FROM_TO_TEXTS))
], TuiSliderOldComponent);

let TuiSliderModule = class TuiSliderModule {
};
TuiSliderModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            TuiRepeatTimesModule,
            TuiFocusableModule,
            TuiFocusVisibleModule,
            TuiActiveZoneModule,
            TuiFormatNumberPipeModule,
        ],
        declarations: [
            TuiSliderComponent,
            TuiSliderThumbLabelComponent,
            TuiSliderKeyStepsDirective,
            TuiSliderReadonlyDirective,
            TuiSliderTickLabelPipe,
            TuiSliderOldComponent,
        ],
        exports: [
            TuiSliderComponent,
            TuiSliderThumbLabelComponent,
            TuiSliderKeyStepsDirective,
            TuiSliderReadonlyDirective,
            TuiSliderTickLabelPipe,
            TuiSliderOldComponent,
        ],
    })
], TuiSliderModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TUI_SLIDER_DEFAULT_OPTIONS, TUI_SLIDER_OPTIONS, TuiSliderComponent, TuiSliderKeyStepsDirective, TuiSliderModule, TuiSliderOldComponent, TuiSliderReadonlyDirective, TuiSliderThumbLabelComponent, TuiSliderTickLabelPipe, tuiSliderOptionsProvider };
//# sourceMappingURL=taiga-ui-kit-components-slider.js.map
