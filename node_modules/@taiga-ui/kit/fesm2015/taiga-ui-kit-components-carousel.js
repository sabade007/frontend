import { __decorate, __param } from 'tslib';
import { EventEmitter, ChangeDetectorRef, Inject, ElementRef, Input, HostBinding, Output, ContentChildren, TemplateRef, HostListener, Component, ChangeDetectionStrategy, Directive, NgModule } from '@angular/core';
import { EMPTY_QUERY, clamp, TUI_IS_MOBILE, tuiDefaultProp, TuiItemDirective, tuiPure, typedFromEvent, TuiPanModule, TuiSwipeModule, TuiItemModule } from '@taiga-ui/cdk';
import { PAGE_VISIBILITY } from '@ng-web-apis/common';
import { Observable, BehaviorSubject, merge, combineLatest, interval, EMPTY } from 'rxjs';
import { mapTo, switchMap, filter, throttleTime, map, tap } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { IntersectionObserverModule } from '@ng-web-apis/intersection-observer';
import { TUI_BUTTON_OPTIONS } from '@taiga-ui/core';

// @dynamic
let TuiCarouselComponent = class TuiCarouselComponent {
    constructor(changeDetectorRef, elementRef, isMobile) {
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.isMobile = isMobile;
        this.translate = 0;
        this.draggable = false;
        this.itemsCount = 1;
        this.index = 0;
        this.indexChange = new EventEmitter();
        this.items = EMPTY_QUERY;
        this.transitioned = true;
    }
    get transform() {
        const x = this.transitioned ? this.computedTranslate : this.translate;
        return `translateX(${100 * x}%)`;
    }
    onTransitioned(transitioned) {
        this.transitioned = transitioned;
        if (!transitioned) {
            this.translate = this.computedTranslate;
        }
    }
    getStyle(itemsCount) {
        const percent = `${100 / itemsCount}%`;
        return {
            flexBasis: percent,
            minWidth: percent,
            maxWidth: percent,
        };
    }
    next() {
        this.updateIndex(this.index + 1);
    }
    prev() {
        this.updateIndex(this.index - 1);
    }
    isDisabled(index) {
        return index < this.index || index > this.index + this.itemsCount;
    }
    onIntersection({ intersectionRatio }, index) {
        if (intersectionRatio && intersectionRatio !== 1 && !this.transitioned) {
            this.updateIndex(index - Math.floor(this.itemsCount / 2));
        }
    }
    onScroll(delta) {
        if (!this.isMobile) {
            this.updateIndex(this.index + delta);
        }
    }
    onPan(x) {
        if (!this.computedDraggable) {
            return;
        }
        const { clientWidth } = this.elementRef.nativeElement;
        const min = 1 - this.items.length / this.itemsCount;
        this.translate = clamp(x / clientWidth + this.translate, min, 0);
    }
    onSwipe(direction) {
        if (direction === 'left') {
            this.next();
        }
        else if (direction === 'right') {
            this.prev();
        }
    }
    onAutoscroll() {
        this.updateIndex(this.index === this.items.length - 1 ? 0 : this.index + 1);
    }
    get computedTranslate() {
        return -this.index / this.itemsCount;
    }
    get computedDraggable() {
        return this.isMobile || this.draggable;
    }
    updateIndex(index) {
        this.index = clamp(index, 0, this.items.length - 1);
        this.indexChange.emit(this.index);
        this.changeDetectorRef.markForCheck();
    }
};
TuiCarouselComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Boolean, decorators: [{ type: Inject, args: [TUI_IS_MOBILE,] }] }
];
__decorate([
    Input(),
    HostBinding('class._draggable'),
    tuiDefaultProp()
], TuiCarouselComponent.prototype, "draggable", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiCarouselComponent.prototype, "itemsCount", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiCarouselComponent.prototype, "index", void 0);
__decorate([
    Output()
], TuiCarouselComponent.prototype, "indexChange", void 0);
__decorate([
    ContentChildren(TuiItemDirective, { read: TemplateRef })
], TuiCarouselComponent.prototype, "items", void 0);
__decorate([
    HostBinding('class._transitioned')
], TuiCarouselComponent.prototype, "transitioned", void 0);
__decorate([
    HostListener('touchstart', ['false']),
    HostListener('touchend', ['true']),
    HostListener('mousedown', ['false']),
    HostListener('document:mouseup.silent', ['true'])
], TuiCarouselComponent.prototype, "onTransitioned", null);
__decorate([
    tuiPure
], TuiCarouselComponent.prototype, "getStyle", null);
TuiCarouselComponent = __decorate([
    Component({
        selector: 'tui-carousel',
        template: "<ng-container *ngIf=\"items.changes | async\"></ng-container>\n<div\n    class=\"t-scroller\"\n    (tuiCarouselScroll)=\"onScroll($event)\"\n>\n    <div\n        waIntersectionRoot\n        waIntersectionObserver\n        waIntersectionThreshold=\"0,1\"\n        waIntersectionRootMargin=\"100px 1000000px 100px -51%\"\n        class=\"t-wrapper\"\n    >\n        <div\n            class=\"t-items\"\n            [style.transform]=\"transform\"\n            (tuiPan)=\"onPan($event[0])\"\n            (tuiSwipe)=\"onSwipe($event.direction)\"\n            (tuiCarouselAutoscroll)=\"onAutoscroll()\"\n        >\n            <fieldset\n                *ngFor=\"let item of items; let i = index\"\n                class=\"t-item\"\n                [disabled]=\"isDisabled(i)\"\n                [ngStyle]=\"getStyle(itemsCount)\"\n                (waIntersectionObservee)=\"onIntersection($event[0], i)\"\n            >\n                <ng-container [ngTemplateOutlet]=\"item\"></ng-container>\n            </fieldset>\n        </div>\n    </div>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{position:relative;display:block;overflow:hidden}:host._draggable{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host._draggable:hover{cursor:-webkit-grab;cursor:grab}:host._draggable:active{cursor:-webkit-grabbing;cursor:grabbing}.t-items{display:flex}:host._transitioned .t-items{transition-property:transform;transition-duration:var(--tui-duration,300ms);transition-timing-function:ease-in-out}.t-item{display:flex;flex-direction:column;justify-content:center;padding:0 1.25rem;flex:1;min-width:100%;max-width:100%;box-sizing:border-box;border:none;margin:0}.t-wrapper{position:-webkit-sticky;position:sticky;left:0;right:0;min-width:100%;overflow:hidden}.t-scroller{scrollbar-width:none;-ms-overflow-style:none;display:flex;overflow:auto;overscroll-behavior-x:none;padding-bottom:2rem;margin-bottom:-2rem}.t-scroller::-webkit-scrollbar,.t-scroller::-webkit-scrollbar-thumb{background:0 0;width:0;height:0}.t-scroller:after,.t-scroller:before{content:'';display:block;min-width:1rem}"]
    }),
    __param(0, Inject(ChangeDetectorRef)),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(TUI_IS_MOBILE))
], TuiCarouselComponent);

let TuiCarouselDirective = class TuiCarouselDirective extends Observable {
    constructor(elementRef, visible$) {
        super(subscriber => this.output$.subscribe(subscriber));
        this.elementRef = elementRef;
        this.visible$ = visible$;
        this.duration$ = new BehaviorSubject(0);
        this.running$ = merge(typedFromEvent(this.elementRef.nativeElement, 'mouseenter').pipe(mapTo(false)), typedFromEvent(this.elementRef.nativeElement, 'touchstart').pipe(mapTo(false)), typedFromEvent(this.elementRef.nativeElement, 'touchend').pipe(mapTo(true)), typedFromEvent(this.elementRef.nativeElement, 'mouseleave').pipe(mapTo(true)), this.visible$);
        this.output$ = combineLatest([this.duration$, this.running$]).pipe(switchMap(([duration, running]) => duration && running ? interval(duration) : EMPTY));
    }
    set duration(duration) {
        this.duration$.next(duration);
    }
    set index(_) {
        this.duration$.next(this.duration$.value);
    }
};
TuiCarouselDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [PAGE_VISIBILITY,] }] }
];
__decorate([
    Input()
], TuiCarouselDirective.prototype, "duration", null);
__decorate([
    Input()
], TuiCarouselDirective.prototype, "index", null);
TuiCarouselDirective = __decorate([
    Directive({
        selector: 'tui-carousel',
    }),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(PAGE_VISIBILITY))
], TuiCarouselDirective);

let TuiCarouselAutoscrollDirective = class TuiCarouselAutoscrollDirective {
    constructor(tuiCarouselAutoscroll) {
        this.tuiCarouselAutoscroll = tuiCarouselAutoscroll;
    }
};
TuiCarouselAutoscrollDirective.ctorParameters = () => [
    { type: Observable, decorators: [{ type: Inject, args: [TuiCarouselDirective,] }] }
];
TuiCarouselAutoscrollDirective = __decorate([
    Directive({
        selector: '[tuiCarouselAutoscroll]',
        outputs: ['tuiCarouselAutoscroll'],
    }),
    __param(0, Inject(TuiCarouselDirective))
], TuiCarouselAutoscrollDirective);

// TODO: 3.0 remove in ivy compilation
const CAROUSEL_BUTTON_OPTIONS = {
    appearance: "secondary" /* Secondary */,
    shape: 'rounded',
    size: 'm',
};
let TuiCarouselButtonsDirective = class TuiCarouselButtonsDirective {
};
TuiCarouselButtonsDirective = __decorate([
    Directive({
        selector: '[tuiCarouselButtons]',
        providers: [
            {
                provide: TUI_BUTTON_OPTIONS,
                useValue: CAROUSEL_BUTTON_OPTIONS,
            },
        ],
    })
], TuiCarouselButtonsDirective);

let TuiCarouselScrollDirective = class TuiCarouselScrollDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.tuiCarouselScroll = typedFromEvent(this.elementRef.nativeElement, 'wheel').pipe(filter(({ deltaX }) => Math.abs(deltaX) > 20), throttleTime(500), map(({ deltaX }) => Math.sign(deltaX)), tap(() => {
            // So we always have space to scroll and overflow-behavior saves us from back nav
            this.elementRef.nativeElement.scrollLeft = 10;
        }));
    }
};
TuiCarouselScrollDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] }
];
__decorate([
    Output()
], TuiCarouselScrollDirective.prototype, "tuiCarouselScroll", void 0);
TuiCarouselScrollDirective = __decorate([
    Directive({
        selector: '[tuiCarouselScroll]',
    }),
    __param(0, Inject(ElementRef))
], TuiCarouselScrollDirective);

let TuiCarouselModule = class TuiCarouselModule {
};
TuiCarouselModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            IntersectionObserverModule,
            TuiPanModule,
            TuiSwipeModule,
            TuiItemModule,
        ],
        declarations: [
            TuiCarouselComponent,
            TuiCarouselDirective,
            TuiCarouselButtonsDirective,
            TuiCarouselAutoscrollDirective,
            TuiCarouselScrollDirective,
        ],
        exports: [
            TuiCarouselComponent,
            TuiCarouselDirective,
            TuiCarouselButtonsDirective,
            TuiItemDirective,
        ],
    })
], TuiCarouselModule);

/**
 * Generated bundle index. Do not edit.
 */

export { CAROUSEL_BUTTON_OPTIONS, TuiCarouselAutoscrollDirective, TuiCarouselButtonsDirective, TuiCarouselComponent, TuiCarouselDirective, TuiCarouselModule, TuiCarouselScrollDirective };
//# sourceMappingURL=taiga-ui-kit-components-carousel.js.map
