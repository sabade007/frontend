import { __decorate, __param } from 'tslib';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Directive, Optional, Self, Inject, ChangeDetectorRef, ElementRef, Input, HostBinding, ViewChildren, HostListener, Component, ChangeDetectionStrategy, forwardRef, EventEmitter, Output, NgModule } from '@angular/core';
import { NgControl, FormsModule } from '@angular/forms';
import { EMPTY_QUERY, isNativeFocusedIn, clamp, quantize, round, tuiAssert, tuiDefaultProp, nonNegativeFiniteAssertion, tuiPure, TUI_FOCUSABLE_ITEM_ACCESSOR, typedFromEvent, TuiDestroyService, TuiRepeatTimesModule, TuiFocusableModule } from '@taiga-ui/cdk';
import { AbstractTuiSlider, SLIDER_KEYBOARD_STEP } from '@taiga-ui/kit/abstract';
import { TuiSliderComponent, TuiSliderModule } from '@taiga-ui/kit/components/slider';
import { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';
import { TUI_FROM_TO_TEXTS } from '@taiga-ui/kit/tokens';
import { tuiPercentageToKeyStepValue, tuiKeyStepValueToPercentage, tuiCheckKeyStepsHaveMinMaxPercents } from '@taiga-ui/kit/utils';
import { Observable, merge } from 'rxjs';
import { TuiFormatNumberPipeModule } from '@taiga-ui/core';
import { filter, map, tap, switchMap, startWith, takeUntil, repeat } from 'rxjs/operators';

var TuiRangeComponent_1;
/**
 * Turn on new mode for `Range` and `InputRange`.
 * The new version of component will behave almost the same as the same component from the next major release.
 * @deprecated TODO remove me in v3.0 and make `Range` and `InputRange` always "new".
 */
let TuiNewRangeDirective = class TuiNewRangeDirective {
};
TuiNewRangeDirective = __decorate([
    Directive({
        selector: 'tui-range[new], tui-input-range[new]',
    })
], TuiNewRangeDirective);
// @dynamic
let TuiRangeComponent = TuiRangeComponent_1 = 
/**
 * `AbstractTuiSlider` includes all legacy code (it can be deleted in v3.0)
 * TODO replace `extends AbstractTuiSlider<[number, number]>` by `extends AbstractTuiControl<[number, number]> implements TuiWithOptionalMinMax<number>, TuiFocusableElementAccessor`
 */
class TuiRangeComponent extends AbstractTuiSlider {
    constructor(control, changeDetectorRef, documentRef, elementRef, fromToTexts$, isNew) {
        super(control, changeDetectorRef, documentRef, fromToTexts$);
        this.elementRef = elementRef;
        this.isNew = isNew;
        this.min = 0;
        /**
         * TODO: make `100` as default value (to be like native sliders) in v3.0
         */
        this.max = Infinity;
        /**
         * TODO: think about replacing this props by `step` (to be like native slider).
         * It can be done after removing backward compatibility code inside {@link computePureKeySteps} in v3.0
         */
        this.steps = 0;
        /**
         * TODO: think about replacing this props by `step` (to be like native slider).
         * It can be done after removing backward compatibility code inside {@link computePureKeySteps} in v3.0
         * */
        this.quantum = 0;
        this.size = 'm';
        this.segments = 0;
        this.keySteps = null;
        this.slidersRefs = EMPTY_QUERY;
        this.lastActiveThumb = 'right';
    }
    get nativeFocusableElement() {
        const [sliderLeftRef, sliderRightRef] = this.slidersRefs;
        if (this.computedDisabled || !sliderLeftRef || !sliderRightRef) {
            return null;
        }
        return this.isLeftFocusable
            ? sliderLeftRef.nativeElement
            : sliderRightRef.nativeElement;
    }
    get focused() {
        return isNativeFocusedIn(this.elementRef.nativeElement);
    }
    get fractionStep() {
        if (this.steps) {
            return 1 / this.steps;
        }
        return this.quantum ? this.quantum / (this.max - this.min) : SLIDER_KEYBOARD_STEP;
    }
    get computedKeySteps() {
        return this.computePureKeySteps(this.keySteps, this.min, this.max);
    }
    get left() {
        return this.getPercentageFromValue(this.value[0]);
    }
    get right() {
        return 100 - this.getPercentageFromValue(this.value[1]);
    }
    onFocused(focused) {
        this.updateFocused(focused);
    }
    changeByStep(coefficient, target) {
        const [sliderLeftRef, sliderRightRef] = this.slidersRefs;
        const leftThumbElement = sliderLeftRef.nativeElement;
        const rightThumbElement = sliderRightRef.nativeElement;
        const isRightThumb = target === this.elementRef.nativeElement
            ? this.lastActiveThumb === 'right'
            : target === rightThumbElement;
        const activeThumbElement = isRightThumb ? rightThumbElement : leftThumbElement;
        const previousValue = isRightThumb ? this.value[1] : this.value[0];
        /** @bad TODO think about a solution without twice conversion */
        const previousFraction = this.getPercentageFromValue(previousValue) / 100;
        const newFractionValue = previousFraction + coefficient * this.fractionStep;
        this.processValue(this.getValueFromFraction(newFractionValue), isRightThumb);
        if (activeThumbElement) {
            activeThumbElement.focus();
        }
    }
    processValue(value, right) {
        const guardedValue = this.valueGuard(value);
        if (right) {
            this.updateEnd(guardedValue);
        }
        else {
            this.updateStart(guardedValue);
        }
        this.lastActiveThumb = right ? 'right' : 'left';
    }
    fractionGuard(fraction) {
        return clamp(quantize(fraction, this.fractionStep), 0, 1);
    }
    getValueFromFraction(fraction) {
        const percentage = this.fractionGuard(fraction) * 100;
        return tuiPercentageToKeyStepValue(percentage, this.computedKeySteps);
    }
    getPercentageFromValue(value) {
        return tuiKeyStepValueToPercentage(value, this.computedKeySteps);
    }
    valueGuard(value) {
        return clamp(this.quantum
            ? round(Math.round(value / this.quantum) * this.quantum, TUI_FLOATING_PRECISION)
            : value, this.min, this.max);
    }
    getFallbackValue() {
        return [0, 0];
    }
    computePureKeySteps(keySteps, min, max) {
        if (keySteps && tuiCheckKeyStepsHaveMinMaxPercents(keySteps)) {
            return keySteps;
        }
        // TODO replace all function by `return keySteps || [[0, min], [100, max]]` in v3.0
        tuiAssert.assert(!keySteps, '\n' +
            'Input property [keySteps] should contain min and max percents.\n' +
            'We have taken [min] and [max] properties of your component for now (but it will not work in v3.0).\n' +
            'See example how properly use [keySteps]: https://taiga-ui.dev/components/range#key-steps');
        return [[0, min], ...(keySteps || []), [100, max]];
    }
    updateStart(value) {
        this.updateValue([Math.min(value, this.value[1]), this.value[1]]);
    }
    updateEnd(value) {
        this.updateValue([this.value[0], Math.max(value, this.value[0])]);
    }
};
TuiRangeComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TUI_FROM_TO_TEXTS,] }] },
    { type: TuiNewRangeDirective, decorators: [{ type: Optional }, { type: Inject, args: [TuiNewRangeDirective,] }] }
];
__decorate([
    Input(),
    tuiDefaultProp()
], TuiRangeComponent.prototype, "min", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiRangeComponent.prototype, "max", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiRangeComponent.prototype, "steps", void 0);
__decorate([
    Input(),
    tuiDefaultProp(nonNegativeFiniteAssertion, 'Quantum must be a non-negative number')
], TuiRangeComponent.prototype, "quantum", void 0);
__decorate([
    Input(),
    HostBinding('attr.data-size'),
    tuiDefaultProp()
], TuiRangeComponent.prototype, "size", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiRangeComponent.prototype, "segments", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], TuiRangeComponent.prototype, "keySteps", void 0);
__decorate([
    ViewChildren(TuiSliderComponent, { read: ElementRef })
], TuiRangeComponent.prototype, "slidersRefs", void 0);
__decorate([
    HostBinding('style.--left.%')
], TuiRangeComponent.prototype, "left", null);
__decorate([
    HostBinding('style.--right.%')
], TuiRangeComponent.prototype, "right", null);
__decorate([
    HostListener('focusin', ['true']),
    HostListener('focusout', ['false'])
], TuiRangeComponent.prototype, "onFocused", null);
__decorate([
    HostListener('keydown.arrowUp.prevent', ['1', '$event.target']),
    HostListener('keydown.arrowRight.prevent', ['1', '$event.target']),
    HostListener('keydown.arrowLeft.prevent', ['-1', '$event.target']),
    HostListener('keydown.arrowDown.prevent', ['-1', '$event.target'])
], TuiRangeComponent.prototype, "changeByStep", null);
__decorate([
    tuiPure
], TuiRangeComponent.prototype, "computePureKeySteps", null);
TuiRangeComponent = TuiRangeComponent_1 = __decorate([
    Component({
        selector: 'tui-range',
        template: "<div class=\"t-track\">\n    <input\n        tuiSlider\n        readonly\n        type=\"range\"\n        step=\"any\"\n        automation-id=\"tui-range__left\"\n        class=\"t-thumb\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [ngModel]=\"value[0]\"\n        [size]=\"size\"\n        [keySteps]=\"computedKeySteps\"\n        [tuiFocusable]=\"focusable\"\n        [attr.disabled]=\"computedDisabled || null\"\n    />\n    <input\n        tuiSlider\n        readonly\n        type=\"range\"\n        step=\"any\"\n        automation-id=\"tui-range__right\"\n        class=\"t-thumb\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [ngModel]=\"value[1]\"\n        [size]=\"size\"\n        [keySteps]=\"computedKeySteps\"\n        [tuiFocusable]=\"focusable\"\n        [attr.disabled]=\"computedDisabled || null\"\n    />\n</div>\n\n<!-- TODO backward compatibility only (remove in v3.0) -->\n<div\n    *ngIf=\"segments > 0\"\n    class=\"t-segments\"\n>\n    <span\n        *tuiRepeatTimes=\"let tickIndex of segments + 1\"\n        automation-id=\"tui-slider__segment\"\n        class=\"t-segment\"\n    >\n        <ng-container *ngIf=\"fromToTexts$ | async as fromToText\">\n            <span\n                *ngIf=\"!isNew\"\n                class=\"t-number\"\n            >\n                {{ getSegmentPrefix(tickIndex, fromToText) }}\n                {{ tickIndex | tuiSliderTickLabel: segments:computedKeySteps | tuiFormatNumber }}\n                <span *ngIf=\"pluralizeMap\">\n                    {{ tickIndex | tuiSliderTickLabel: segments:computedKeySteps | i18nPlural: pluralizeMap }}\n                </span>\n            </span>\n        </ng-container>\n    </span>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        host: {
            '[attr.tabindex]': '-1',
            '[attr.aria-disabled]': 'computedDisabled',
        },
        providers: [
            {
                provide: TUI_FOCUSABLE_ITEM_ACCESSOR,
                useExisting: forwardRef(() => TuiRangeComponent_1),
            },
        ],
        styles: [":host{position:relative;display:block;height:.125rem;border-radius:var(--tui-radius-m);background:var(--tui-base-03);cursor:pointer;outline:0;margin:.4375rem 0;touch-action:pan-x}:host:active{cursor:ew-resize}:host:after{content:'';position:absolute;top:-.4375rem;bottom:-.4375rem;width:100%}:host._disabled{opacity:var(--tui-disabled-opacity);cursor:auto}:host[data-size='s'] .t-track{position:relative;margin:0 .25rem;height:100%}:host[data-size='s'] .t-track:after{content:'';position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 -.25rem}:host[data-size='m'] .t-track{position:relative;margin:0 .5rem;height:100%}:host[data-size='m'] .t-track:after{content:'';position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 -.5rem}.t-thumb{pointer-events:none;position:absolute;top:.0625rem;left:0;right:0;z-index:1;transform:translate(0,-50%)}.t-thumb::-webkit-slider-thumb{pointer-events:all}.t-thumb::-moz-range-thumb{pointer-events:all}input[type=range].t-thumb::-webkit-slider-runnable-track{background:0 0}input[type=range].t-thumb::-moz-range-track{background:0 0}input[type=range].t-thumb::-moz-range-progress{background:0 0}input[type=range].t-thumb::-ms-track{background:0 0}input[type=range].t-thumb::-ms-fill-lower{background:0 0}.t-thumb:last-of-type::-webkit-slider-thumb{transform:translate(50%,0)}.t-thumb:first-of-type::-webkit-slider-thumb{transform:translate(-50%,0)}.t-thumb:last-of-type::-moz-range-thumb{transform:translate(50%,0)}.t-thumb:first-of-type::-moz-range-thumb{transform:translate(-50%,0)}:host._disabled .t-thumb{opacity:1}.t-segments{position:absolute;top:0;left:0;bottom:0;right:0}:host[data-size='s'] .t-segments{display:flex;margin:0 .25rem;font:var(--tui-font-text-s);padding:0 .25rem}:host[data-size='s'] .t-segments>*{position:relative;flex:2;text-align:center}:host[data-size='s'] .t-segments>:first-child{left:-.25rem;flex:1;text-align:left}:host[data-size='s'] .t-segments>:last-child{right:-.25rem;flex:1;text-align:right}tui-input-slider+:host[data-size='s'] .t-segments{margin-left:calc(var(--tui-radius-m)/ 2 + .25rem)}tui-input-range+:host[data-size='s'] .t-segments,tui-range+:host[data-size='s'] .t-segments{margin-left:.5rem;margin-right:.5rem}tui-input-range+:host[data-size='s'] .t-segments>:first-child,tui-range+:host[data-size='s'] .t-segments>:first-child{left:-.5rem}tui-input-range+:host[data-size='s'] .t-segments>:last-child,tui-range+:host[data-size='s'] .t-segments>:last-child{right:-.5rem}:host[data-size='m'] .t-segments{display:flex;margin:0 .5rem;font:var(--tui-font-text-s);padding:0 .5rem}:host[data-size='m'] .t-segments>*{position:relative;flex:2;text-align:center}:host[data-size='m'] .t-segments>:first-child{left:-.5rem;flex:1;text-align:left}:host[data-size='m'] .t-segments>:last-child{right:-.5rem;flex:1;text-align:right}tui-input-slider+:host[data-size='m'] .t-segments{margin-left:calc(var(--tui-radius-m)/ 2 + .5rem)}tui-input-range+:host[data-size='m'] .t-segments,tui-range+:host[data-size='m'] .t-segments{margin-left:1rem;margin-right:1rem}tui-input-range+:host[data-size='m'] .t-segments>:first-child,tui-range+:host[data-size='m'] .t-segments>:first-child{left:-1rem}tui-input-range+:host[data-size='m'] .t-segments>:last-child,tui-range+:host[data-size='m'] .t-segments>:last-child{right:-1rem}.t-segment:not(:last-of-type):not(:first-of-type):before{content:'';position:absolute;left:0;right:0;margin:auto;background:var(--tui-base-07);width:.25rem;height:100%}.t-segment:last-of-type .t-number{margin-right:-.5rem}.t-segment:first-of-type .t-number{margin-left:-.5rem}.t-number{display:inline-block;margin-top:.5rem}"]
    })
    /**
     * `AbstractTuiSlider` includes all legacy code (it can be deleted in v3.0)
     * TODO replace `extends AbstractTuiSlider<[number, number]>` by `extends AbstractTuiControl<[number, number]> implements TuiWithOptionalMinMax<number>, TuiFocusableElementAccessor`
     */
    ,
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Inject(ChangeDetectorRef)),
    __param(2, Inject(DOCUMENT)),
    __param(3, Inject(ElementRef)),
    __param(4, Inject(TUI_FROM_TO_TEXTS)),
    __param(5, Optional()),
    __param(5, Inject(TuiNewRangeDirective))
], TuiRangeComponent);

// @dynamic
let TuiRangeChangeDirective = class TuiRangeChangeDirective {
    constructor(documentRef, elementRef, range, destroy$) {
        this.documentRef = documentRef;
        this.elementRef = elementRef;
        this.range = range;
        /**
         * TODO replace with pointer events (when all supported browsers can handle them).
         * Dont forget to use setPointerCapture instead of listening all documentRef events
         */
        this.pointerDown$ = merge(typedFromEvent(this.elementRef.nativeElement, 'touchstart', { passive: true }).pipe(filter(({ touches }) => touches.length === 1), map(({ touches }) => touches[0])), typedFromEvent(this.elementRef.nativeElement, 'mousedown', { passive: true }));
        this.pointerMove$ = merge(typedFromEvent(this.documentRef, 'touchmove').pipe(filter(({ touches }) => touches.length === 1), map(({ touches }) => touches[0])), typedFromEvent(this.documentRef, 'mousemove'));
        this.pointerUp$ = merge(typedFromEvent(this.documentRef, 'touchend', { passive: true }), typedFromEvent(this.documentRef, 'mouseup', { passive: true }));
        this.activeThumbChange = new EventEmitter();
        let activeThumb;
        this.pointerDown$
            .pipe(tap(({ clientX, target }) => {
            activeThumb = this.detectActiveThumb(clientX, target);
            this.activeThumbChange.emit(activeThumb);
            if (this.range.focusable) {
                elementRef.nativeElement.focus();
            }
        }), switchMap(event => this.pointerMove$.pipe(startWith(event))), map(({ clientX }) => clamp(this.getFractionFromEvents(clientX), 0, 1)), takeUntil(this.pointerUp$), repeat(), takeUntil(destroy$))
            .subscribe(fraction => {
            const value = this.range.getValueFromFraction(this.range.fractionGuard(fraction));
            this.range.processValue(value, activeThumb === 'right');
        });
    }
    getFractionFromEvents(clickClientX) {
        const hostRect = this.elementRef.nativeElement.getBoundingClientRect();
        const value = clickClientX - hostRect.left;
        const total = hostRect.width;
        return round(value / total, TUI_FLOATING_PRECISION);
    }
    detectActiveThumb(clientX, target) {
        const [leftSliderRef, rightSliderRef] = this.range.slidersRefs;
        switch (target) {
            case leftSliderRef.nativeElement:
                return 'left';
            case rightSliderRef.nativeElement:
                return 'right';
            default:
                return this.findNearestActiveThumb(clientX);
        }
    }
    findNearestActiveThumb(clientX) {
        const fraction = this.getFractionFromEvents(clientX);
        const deltaLeft = fraction * 100 - this.range.left;
        const deltaRight = fraction * 100 - 100 + this.range.right;
        return Math.abs(deltaLeft) > Math.abs(deltaRight) ||
            deltaRight > 0 ||
            (this.range.left === 0 && this.range.right === 100)
            ? 'right'
            : 'left';
    }
};
TuiRangeChangeDirective.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: TuiRangeComponent, decorators: [{ type: Inject, args: [TuiRangeComponent,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
];
__decorate([
    Output()
], TuiRangeChangeDirective.prototype, "activeThumbChange", void 0);
TuiRangeChangeDirective = __decorate([
    Directive({
        selector: 'tui-range',
        providers: [TuiDestroyService],
    }),
    __param(0, Inject(DOCUMENT)),
    __param(1, Inject(ElementRef)),
    __param(2, Inject(TuiRangeComponent)),
    __param(3, Inject(TuiDestroyService))
], TuiRangeChangeDirective);

let TuiRangeModule = class TuiRangeModule {
};
TuiRangeModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            TuiRepeatTimesModule,
            TuiFocusableModule,
            TuiFormatNumberPipeModule,
            TuiSliderModule,
            FormsModule,
        ],
        declarations: [TuiRangeComponent, TuiRangeChangeDirective, TuiNewRangeDirective],
        exports: [TuiRangeComponent, TuiRangeChangeDirective, TuiNewRangeDirective],
    })
], TuiRangeModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiNewRangeDirective, TuiRangeChangeDirective, TuiRangeComponent, TuiRangeModule };
//# sourceMappingURL=taiga-ui-kit-components-range.js.map
