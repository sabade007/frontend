import { __decorate, __param } from 'tslib';
import { Optional, Self, Inject, Input, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { NgControl, FormArrayName, FormGroupName, FormGroupDirective, ReactiveFormsModule } from '@angular/forms';
import { TuiValidationError, tuiDefaultProp, tuiPure } from '@taiga-ui/cdk';
import { TUI_VALIDATION_ERRORS } from '@taiga-ui/kit/tokens';
import { merge, EMPTY, of, isObservable } from 'rxjs';
import { map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { TuiErrorModule } from '@taiga-ui/core';

const EMPTY_RECORD = {};
// @dynamic
let TuiFieldErrorComponent = class TuiFieldErrorComponent {
    constructor(ngControl, formArrayName, formGroupName, formGroup, validationErrors) {
        this.ngControl = ngControl;
        this.formArrayName = formArrayName;
        this.formGroupName = formGroupName;
        this.formGroup = formGroup;
        this.validationErrors = validationErrors;
        this.order = [];
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    get change$() {
        var _a, _b;
        return merge(((_a = this.control) === null || _a === void 0 ? void 0 : _a.valueChanges) || EMPTY, ((_b = this.control) === null || _b === void 0 ? void 0 : _b.statusChanges) || EMPTY);
    }
    get computedError() {
        return (this.invalid && this.touched && this.error) || of(null);
    }
    registerOnChange() { }
    registerOnTouched() { }
    setDisabledState() { }
    writeValue() { }
    get error() {
        const { errorId } = this;
        if (!errorId) {
            return of(null);
        }
        const firstError = this.controlErrors[errorId];
        const errorContent = this.validationErrors[errorId];
        return this.getError(firstError, errorContent);
    }
    get invalid() {
        return !!this.control && this.control.invalid;
    }
    get touched() {
        return !!this.control && this.control.touched;
    }
    get control() {
        if (this.ngControl) {
            return this.ngControl.control;
        }
        if (this.formArrayName) {
            return this.formArrayName.control;
        }
        if (this.formGroupName) {
            return this.formGroupName.control;
        }
        if (this.formGroup) {
            return this.formGroup.control;
        }
        return null;
    }
    get errorId() {
        return this.getErrorId(this.order, this.controlErrors);
    }
    get controlErrors() {
        var _a;
        return ((_a = this.control) === null || _a === void 0 ? void 0 : _a.errors) || EMPTY_RECORD;
    }
    getErrorId(order, controlErrors) {
        const id = order === null || order === void 0 ? void 0 : order.find(errorId => controlErrors[errorId]);
        const fallback = Object.keys(controlErrors)[0];
        return id || fallback || '';
    }
    getError(firstError, errorContent) {
        if (firstError instanceof TuiValidationError) {
            return of(firstError);
        }
        if (errorContent === undefined && typeof firstError === 'string') {
            return of(new TuiValidationError(firstError));
        }
        if (isObservable(errorContent)) {
            return errorContent.pipe(map(error => new TuiValidationError(error || '', firstError)));
        }
        return of(new TuiValidationError(errorContent || '', firstError));
    }
};
TuiFieldErrorComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: FormArrayName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormArrayName,] }] },
    { type: FormGroupName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormGroupName,] }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormGroupDirective,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_VALIDATION_ERRORS,] }] }
];
__decorate([
    Input(),
    tuiDefaultProp()
], TuiFieldErrorComponent.prototype, "order", void 0);
__decorate([
    tuiPure
], TuiFieldErrorComponent.prototype, "change$", null);
__decorate([
    tuiPure
], TuiFieldErrorComponent.prototype, "getErrorId", null);
__decorate([
    tuiPure
], TuiFieldErrorComponent.prototype, "getError", null);
TuiFieldErrorComponent = __decorate([
    Component({
        selector: 'tui-field-error',
        // @bad TODO: find a way to get 'touched' state change
        // https://github.com/angular/angular/issues/10887
        changeDetection: ChangeDetectionStrategy.Default,
        template: "<ng-container *ngIf=\"change$ | async\"></ng-container>\n\n<tui-error [error]=\"computedError | async\"></tui-error>\n",
        styles: [":host{display:block}"]
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Optional()),
    __param(1, Self()),
    __param(1, Inject(FormArrayName)),
    __param(2, Optional()),
    __param(2, Self()),
    __param(2, Inject(FormGroupName)),
    __param(3, Optional()),
    __param(3, Self()),
    __param(3, Inject(FormGroupDirective)),
    __param(4, Inject(TUI_VALIDATION_ERRORS))
], TuiFieldErrorComponent);

/**
 * @deprecated use {@link TuiFieldErrorPipeModule} (from '@taiga-ui/kit') instead
 */
let TuiFieldErrorModule = class TuiFieldErrorModule {
};
TuiFieldErrorModule = __decorate([
    NgModule({
        imports: [CommonModule, TuiErrorModule, ReactiveFormsModule],
        declarations: [TuiFieldErrorComponent],
        exports: [TuiFieldErrorComponent],
    })
], TuiFieldErrorModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiFieldErrorComponent, TuiFieldErrorModule };
//# sourceMappingURL=taiga-ui-kit-components-field-error.js.map
